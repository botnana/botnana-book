<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Botnana Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 簡介</a></li><li class="chapter-item expanded "><a href="hardware.html"><strong aria-hidden="true">2.</strong> 硬體規格</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="botnana-a2.html"><strong aria-hidden="true">2.1.</strong> Botnana BN-A2A</a></li><li class="chapter-item expanded "><a href="botnana-bn-j4a.html"><strong aria-hidden="true">2.2.</strong> Botnana BN-J4A</a></li></ol></li><li class="chapter-item expanded "><a href="software.html"><strong aria-hidden="true">3.</strong> 軟體規格</a></li><li class="chapter-item expanded "><a href="roadmap.html"><strong aria-hidden="true">4.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">5.</strong> 入門教學</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="botnana-a2-tutorial.html"><strong aria-hidden="true">5.1.</strong> Botnana A2 入門</a></li><li class="chapter-item expanded "><a href="botnana-control-tutorial.html"><strong aria-hidden="true">5.2.</strong> Botnana Control 入門</a></li></ol></li><li class="chapter-item expanded "><a href="configuration-file.html"><strong aria-hidden="true">6.</strong> 設定檔</a></li><li class="chapter-item expanded "><a href="programming.html"><strong aria-hidden="true">7.</strong> 程式開發界面</a></li><li class="chapter-item expanded "><a href="json-api.html"><strong aria-hidden="true">8.</strong> JSON API</a></li><li class="chapter-item expanded "><a href="real-time-script-api.html"><strong aria-hidden="true">9.</strong> Real-time Script API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="host-primitives.html"><strong aria-hidden="true">9.1.</strong> Botnana 基本指令集</a></li><li class="chapter-item expanded "><a href="ethercat-primitives.html"><strong aria-hidden="true">9.2.</strong> EtherCAT 指令集</a></li><li class="chapter-item expanded "><a href="ethercat-drive-primitives.html"><strong aria-hidden="true">9.3.</strong> EtherCAT Drive 指令集</a></li><li class="chapter-item expanded "><a href="ethercat-io-primitives.html"><strong aria-hidden="true">9.4.</strong> EtherCAT IO 指令集</a></li><li class="chapter-item expanded "><a href="ethercat-uart-primitives.html"><strong aria-hidden="true">9.5.</strong> EtherCAT UART 指令集</a></li><li class="chapter-item expanded "><a href="ethercat-encoder-primitives.html"><strong aria-hidden="true">9.6.</strong> EtherCAT Encoder 指令集</a></li><li class="chapter-item expanded "><a href="ethercat-gateway-primitives.html"><strong aria-hidden="true">9.7.</strong> EtherCAT Gateway 指令集</a></li><li class="chapter-item expanded "><a href="axis-group.html"><strong aria-hidden="true">9.8.</strong> 軸組 Axis Group 指令集</a></li><li class="chapter-item expanded "><a href="sfc.html"><strong aria-hidden="true">9.9.</strong> 狀態流程圖 Sequential Function Chart (SFC)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sfc-example/servo-on-off.html"><strong aria-hidden="true">9.9.1.</strong> Servo On/OFF</a></li><li class="chapter-item expanded "><a href="sfc-example/motion-state.html"><strong aria-hidden="true">9.9.2.</strong> Motion State</a></li><li class="chapter-item expanded "><a href="sfc-example/axes-homing.html"><strong aria-hidden="true">9.9.3.</strong> Homing State</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="known-working-hardware.html"><strong aria-hidden="true">10.</strong> 支援的硬體清單</a></li><li class="chapter-item expanded "><a href="update-software.html"><strong aria-hidden="true">11.</strong> 軟體更新</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">12.</strong> 常見問題</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="faq/network.html"><strong aria-hidden="true">12.1.</strong> 網路設定</a></li><li class="chapter-item expanded "><a href="faq/gadget.html"><strong aria-hidden="true">12.2.</strong> USB連線IP設定</a></li><li class="chapter-item expanded "><a href="faq/windows7_rndis.html"><strong aria-hidden="true">12.3.</strong> Windows 7 RNDIS 驅動程式安裝</a></li><li class="chapter-item expanded "><a href="faq/windows10_rndis.html"><strong aria-hidden="true">12.4.</strong> Windows 10 RNDIS 驅動程式安裝</a></li><li class="chapter-item expanded "><a href="faq/win10_permission.html"><strong aria-hidden="true">12.5.</strong> Windows 10 檔案權限修改</a></li><li class="chapter-item expanded "><a href="faq/mount.html"><strong aria-hidden="true">12.6.</strong> 磁碟掛載 Mount</a></li><li class="chapter-item expanded "><a href="faq/manual_install_deb/manual_install_deb.html"><strong aria-hidden="true">12.7.</strong> 手動安裝 Botnana Control 更新檔</a></li><li class="spacer"></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Botnana Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="簡介"><a class="header" href="#簡介">簡介</a></h1>
<p>霸那控制器 (Botnana Control) 是一款工業以太網 EtherCAT 控制器的快速開發以及學習環境。
目標是幫使用者快速開發以工業以太網 EtherCAT 為基礎的自動控制以及工業物聯網應用。</p>
<p><img src="./botnana-a2-in-box.png" alt="霸那控制器" /></p>
<h2 id="應用領域"><a class="header" href="#應用領域">應用領域</a></h2>
<p>霸那控制器軟體適合以下應用</p>
<ul>
<li>資料收集：做為 Remote Control Unit (RTU) 使用。</li>
<li>資料分析：透過內建類似試算表的工具及 Javascript，分析收集到的資料。</li>
<li>軸控：可透過 EtherCAT 控制 1-32 軸以上的馬達。目前已支援台達電、Panasonic、Sanyo Denki 以及 Yaskawa 的 EtherCAT 馬達驅動器，以及台達電的脈波產生器。
未來將支援 Coply 的 EtherCAT 驅動器。</li>
<li>類 PLC 控制：可透過 EtherCAT IO 模組進行類似 PLC 的控制，目前支援台達電及 Beckhoff 的 IO 模組。</li>
<li>IIoT：透過內建的 Websocket 或 MTConnect 伺服器，和客戶的雲端服務或 HMI 整合。</li>
<li>CNC 控制器。</li>
</ul>
<h2 id="文件網址"><a class="header" href="#文件網址">文件網址：</a></h2>
<p>Botnana Book: <a href="https://botnana.github.io/botnana-book/">https://botnana.github.io/botnana-book/</a><br>
Botnana Book PDF 檔案連結: <a href="https://drive.google.com/file/d/17MOBkEqNVOuN4Zg8fdbMBsCs7Ws-be-H/view?usp=sharing">https://drive.google.com/file/d/17MOBkEqNVOuN4Zg8fdbMBsCs7Ws-be-H/view?usp=sharing</a><br>
rtForth: <a href="https://mapacode.github.io/rtforth/">https://mapacode.github.io/rtforth/</a><br>
rtForth PDF 檔案連結: <a href="https://drive.google.com/file/d/1DtmB3rDQxERpZAV0gcrQtP_0uRcDQTwc/view?usp=sharing">https://drive.google.com/file/d/1DtmB3rDQxERpZAV0gcrQtP_0uRcDQTwc/view?usp=sharing</a><br>
API 函式庫: <a href="https://github.com/botnana/botnana-apis">https://github.com/botnana/botnana-apis</a><br></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="硬體規格"><a class="header" href="#硬體規格">硬體規格</a></h1>
<p>Botnana Control 支援以下幾種硬體：</p>
<ul>
<li>
<p><a href="./botnana-a2.html">Botnana A2</a></p>
</li>
<li>
<p><a href="./botnana-box.html">Botnana Box</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="botnana-bn-a2a"><a class="header" href="#botnana-bn-a2a">Botnana BN-A2A</a></h2>
<p>霸那控制器 (Botnana Control) 支援霸那  BN-A2A/BN-B2A。</p>
<p>霸那 BN-A2A/BN-B2A 規格如下：</p>
<ul>
<li>AM3357 800MHz ARM Cortex A8</li>
<li>512MB DDR3L@400MHz RAM</li>
<li>4GB 8-bit eMMC on-board flash storage</li>
<li>1x microSD</li>
<li>NEON floating-point accelerator</li>
<li>1x micro USB 2.0 client (USB0) for power and communication</li>
<li>1x USB 2.0 host (USB1), TYPE A socket</li>
<li>2x Ethernet 10/100MHz</li>
<li>Power Consumption: 3.6W</li>
<li>BN-A2A Dimension: 100.2 x 56.2 x 15 mm</li>
<li>BN-B2A Dimension: 105.0 x 60.0 x 31.2 mm </li>
</ul>
<p><strong>BN-A2A</strong></p>
<p><img src="./botnana-a2.png" alt="" /></p>
<p><strong>BN-B2A</strong></p>
<p><img src="./botnana-a2-in-box.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="botnana-bn-j4a"><a class="header" href="#botnana-bn-j4a">Botnana BN-J4A</a></h2>
<p>霸那控制器 (Botnana Control) 支援 x86 電腦。</p>
<p><img src="Q190.png" alt="" /></p>
<p>x86 電腦規格如下：</p>
<ul>
<li>Dimension   : 
<ul>
<li>134x126x38mm</li>
</ul>
</li>
<li>Onboard CPU :
<ul>
<li>Intel Celeron Processor J1900 |</li>
</ul>
</li>
<li>Front-Panel Connectors:
<ul>
<li>Power on/off</li>
<li>Power LED</li>
<li>2 x USB 2.0 Ports </li>
<li>1 x VGA Port</li>
<li>WiFi</li>
</ul>
</li>
<li>Back-Panel Connectors
<ul>
<li>1 × DV 12V input</li>
<li>Power LED, HDD LED</li>
<li>LAN1 (EtherCAT)</li>
<li>LAN2 (Reserved for EtherCAT)</li>
<li>LAN3 (Reserved for Ethernet)</li>
<li>LAN4 (Ethernet) (ip: 192.168.7.2)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="軟體規格"><a class="header" href="#軟體規格">軟體規格</a></h1>
<p>霸那控制器出廠時預裝了 Linux 以及實時作業系統，以及動程科技自行開發的 <em>Botnana Control</em>，針對 EtherCAT 開發的多軸控制軟體。</p>
<h2 id="軸控軟體"><a class="header" href="#軸控軟體">軸控軟體</a></h2>
<p>所有等級的 Botnana Control 都支援以下規格：</p>
<ul>
<li>可控制至 16 台 EtherCAT 從站。</li>
<li>支援 Panasonic、Delta、Sanyo Denki 和 Yaskawa 的 EtherCAT 馬達驅動器。基本上有符合 CiA 402 規範的馬達驅動器都有支援。</li>
<li>支援 Beckhoff，Delta 的類比及數位輸出入模組。因應客戶需求陸續整合其他廠牌的 EtherCAT 模組。</li>
</ul>
<h3 id="基本功能"><a class="header" href="#基本功能">基本功能</a></h3>
<ul>
<li>Real-time extenstion (Xenomai)</li>
<li>系統掃描與設定軟體，自動偵測 EtherCAT 從站。</li>
<li>支援 EtherCAT 馬達驅動器 <em>HM</em>, <em>PP</em>, <em>CSP</em>, <em>PV</em>, <em>CSV</em>, <em>TQ</em> 與 <em>CST</em> 模式。</li>
<li>監控軟體。支援 EtherCAT 馬達驅動器與 IO 模組。</li>
<li>可進行二與三軸同動及直線圓弧補間。補間支援具 <em>CSP</em> 模式的馬達驅動器。</li>
<li>多軸組功能。</li>
<li>即時腳本 （rtForth）。</li>
</ul>
<h3 id="開發中與未來加值的功能"><a class="header" href="#開發中與未來加值的功能">開發中與未來加值的功能</a></h3>
<ul>
<li>Modbus TCP。</li>
<li>四至六軸補間。</li>
<li>工件程式解譯器。</li>
<li>CNC 人機界面。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<ul>
<li>2017/02/01 Botnana Control P2P (level 1)</li>
<li>2017/11/01 Botnana Control Profiling (level 2)</li>
<li>2018/01/01 Botnana CNC (level 3)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入門教學-tutorial"><a class="header" href="#入門教學-tutorial">入門教學 (Tutorial)</a></h1>
<hr />
<h2 id="系統概念"><a class="header" href="#系統概念">系統概念</a></h2>
<pre><code>    +---------------+------------+               +-----------+
    | User Program  |  Botnana   |               |           |
    |               |  API       |               |           |
    | Main thread   |------------|   JSON  1ms   |           |
    |               |         Tx |--------------&gt;|           |
    |         call -----&gt; Thread |               | Websocket |
    |               |------------|   tag|value   | Server    |
    |               |         Rx |&lt;--------------|           |
    |     callback &lt;----- Thread |               |           |
    |               |------------|     100ms     |           |
    |               |       Poll |--------------&gt;|           |
    |               |     Thread |               |         | |
    |---------------+------------|               |---------|-|
    | Device management software |               | Config. v |
    | on Browser                 |               | File      |
    |                            |               |           |
    |     Learning               |   Webapp      |-----------|
    |     Testing                |&lt;--------------| HTTP      |
    |     Configuration          |               | Server    |
    |     Software update        |               |           |
    |----------------------------|               |-----------|
    | Windows/Linux              |               | Linux     |
    +----------------------------+               +-----------+
</code></pre>
<p>以上架構圖左方為此軸控／IIoT 平台的客戶端，分三個部份，</p>
<ol>
<li>應用程式：應用程式可能是一台半導體設備或一個產線的控制系統。此一控制系統有自己的線程。</li>
<li>Botnana API：是用動程科技提供的應用程式界面。又由三個線程構成。</li>
<li>瀏覽器上的 Webapp。此一 Webapp 是右方軸控平台的 HTTP 伺服器產生。提供以下四種裝置管理服務：學習、測試、建構與軟體更新。</li>
</ol>
<hr />
<h2 id="botnana-控制平台"><a class="header" href="#botnana-控制平台">Botnana 控制平台</a></h2>
<pre><code>    +-------------+------------------+-----------------------+
    |             |                  | Background task (NC)  |
    |             |                  +-----------------------+
    |             |                  | Background task (PLC) |
    |             | Real-time script +-----------------------+
    | Web socket  |&lt;----------------&gt;| Foreground task 2     |
    | Server      | Real-time script +-----------------------+
    |             |&lt;----------------&gt;| Foreground task 1     |
    |             |                  +-----------------------+
    |             |                  | Control Task          |
    |             |                  +-----------------------+
    |             | Realtime script VM (4MB Data + 4MB Code) |
    +-------------+---------+------------+-------------------+
    | Config.     |         | Axis Group | Kinematics        |
    | File        |         +------------+-------------------+
    |             |         | Look ahead | Interpolations    |
    |             |         +------------+-------------------+
    |             | Control | I/O        | SFC Engine        |
    +-------------+---------+------------+-----+-------------+
    | HTTP        | Hardware abstraction/detection layer     |
    | Server      |                                          |
    +-------------+------------------------------------------+
    | Linux       | Real-time kernel                         |
    +-------------+------------------------------------------+
     Non-real-time                                  Real-time
</code></pre>
<p>動程於 2015 開始投入此一平台的開發，從最底層的工業以太網路 (EtherCAT) 的硬體抽象層開始做起，上圖為到 2018 年十月已完成的架構。</p>
<p>此一架構分成兩大部份，左方為非實時的部份，在 Linux 作業系統下執行，具有兩個伺服器：HTTP 伺服器和 Websocket 伺服器，以及此一系統的各種建構檔案。</p>
<p>右端為實時的部份，在實時系統上建置了一層硬體抽象層。此一硬體抽象層支援各家的 EtherCAT 從站。以硬體抽象層為基礎，其上為軸控的引擎。又包括了軸組、運動學、路徑預視、補間功能、順序流程圖的執行引擎。</p>
<p>在軸控引擎之上是執行實時腳本語言 rtForth 的虚擬機，具直譯／編譯功能。虚擬機內建 4MB 的資料空間及 4MB 的程式碼空間，能儲存數十萬指令的 rtForth 程式。並以合作式多工的方式實作了五個工作：</p>
<ul>
<li>Control 工作：執行以控制下軸控引擎。</li>
<li>前景工作一和二：透過其左方非實時部份的 Websocket 伺服器，接受最多兩個客戶端應用程式的指令。</li>
<li>PLC 工作：使用底下軸控引擎中順序流程圖引擎 (SFC Engine) 來執行可程式邏輯控制程式。</li>
<li>NC 工作：使用底下軸控引擎中的各種功能執行複雜的運動及加工行為。虚擬機內建的空間使其能儲存相當於十萬行 CNC 工件程式的實時腳本。這些實時腳本可由是客戶端程式從工作程式轉譯得到，或是由客戶端直接以 C# 或其他語言規畫產生。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="botnana-a2-入門"><a class="header" href="#botnana-a2-入門">Botnana A2 入門</a></h2>
<hr />
<h3 id="登入"><a class="header" href="#登入">登入</a></h3>
<p>使用 micro USB 連結到電腦的 USB port，再以 ssh 登入，</p>
<pre><code>ssh debian@192.168.7.2
</code></pre>
<p>密碼為 temppwd</p>
<p>如果有必要切換使用者為 root，可執行</p>
<pre><code>sudo su
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="botnana-control-入門"><a class="header" href="#botnana-control-入門">Botnana Control 入門</a></h2>
<p>Botnana A2 預設於開機時自動啟動動程科技的 Botnana Control P2P 軸控軟體。此一軸控軟體安裝於 <code>/opt/mapacode/botnana-control</code>。</p>
<p>因此，使用瀏覽器連上 http://192.168.7.2:3000 。可見到以下畫面。</p>
<p><img src="./botnana-control-controlsheet.png" alt="Botnana Controlsheet" /></p>
<p>如果 Botnana A2 上未安裝 Botnana Control P2P，可以以下列方式安裝：</p>
<pre><code>dpkg -i botnana-control_0.0.1-1_armhf.deb
</code></pre>
<p>解安裝請執行</p>
<pre><code>dpkg -r botnana-control
</code></pre>
<p>若要用 etherCAT Master RTDM ，且不用 Botnana Control P2P 軸控軟體，則需自行設定如下︰ </p>
<pre><code>1. 執行 dpkg -r botnana-control
2. 於檔案 /etc/rc.local 中，確認有如下的註解行(3.14.26 會因 kernel 版本而異)
   #insmod /lib/modules/3.14.26/kernel/drivers/net/ethernet/ti/ti_cpsw.ko
3. 執行 insserv ethercat
</code></pre>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>請參考 <a href="./configuration-file.html">設定檔</a> 章節，若無必要，請勿手動修改設定檔。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="設定檔"><a class="header" href="#設定檔">設定檔</a></h2>
<p>Botnana Control Motion Server 的設定檔位於 /opt/mapacode/botnana-control/config/motion.toml 。</p>
<p>設定檔使用 <a href="https://github.com/toml-lang/toml">Toml</a> 格式。說明如下。</p>
<h3 id="file-section"><a class="header" href="#file-section">File section</a></h3>
<ul>
<li><em>spec_version</em> 欄位：列出使用的設定檔格式的版本，本文件目前的版本是 0.0.1。</li>
</ul>
<h3 id="slave-section"><a class="header" href="#slave-section">Slave section</a></h3>
<p>可以有多個 slaves，因此使用 <code>[[slave]]</code>。每個 slave 有以下欄位。</p>
<ul>
<li><em>position</em>: slave 的位置。</li>
<li><em>vendor_id</em></li>
<li><em>product_code</em></li>
<li><em>homing_method</em></li>
<li><em>home_offset</em></li>
<li><em>homing_speed_1</em></li>
<li><em>homing_speed_2</em></li>
<li><em>homing_acceleration</em></li>
<li><em>profile_velocity</em></li>
<li><em>profile_acceleration</em></li>
<li><em>profile_deceleration</em></li>
</ul>
<h3 id="example-of-a-motiontoml"><a class="header" href="#example-of-a-motiontoml">Example of a motion.toml</a></h3>
<pre><code>[file]
  spec_version = &quot;0.0.1&quot;
[[slave]]
  position = 1
  vendor_id = 6661
  product_code = 22049
  homing_method = 33
  home_offset = 0
  homing_speed_1 = 50
  homing_speed_2 = 5
  homing_acceleration = 8
  profile_velocity = 8000
  profile_acceleration = 9000
  profile_deceleration = 9000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程式開發界面"><a class="header" href="#程式開發界面">程式開發界面</a></h1>
<p>Botnana Control 內建伺服器。伺服器提供以下程式開發界面：</p>
<ul>
<li><a href="./json-api.html">JSON API</a>：程式可以使用 JSON 格式和 Botnana Control 溝通。適用於各種
支援 JSON 及 Websocket 的語言，如 Java、C#、C++、Python、Ruby 等。</li>
<li><a href="./javascript-api.html">Javascript API</a> 提供 Javascript 程式和 Botnana Control 溝通的界面。 </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-api"><a class="header" href="#json-api">JSON API</a></h1>
<p>Botnana Control 的 JSON API 採用 <a href="http://www.jsonrpc.org/specification">JSON-RPC 2.0</a> 。</p>
<p>程式可以使用 JSON 格式和 Botnana Control 溝通。此一方法適用於各種支援 JSON 格式且具有 Websocket 函式庫的語言，例如：</p>
<ul>
<li>Java</li>
<li>C#</li>
<li>C++</li>
<li>Python</li>
<li>Ruby</li>
<li>Go</li>
</ul>
<h2 id="回傳資料格式"><a class="header" href="#回傳資料格式">回傳資料格式</a></h2>
<p>Botnana Control 若回傳資料，格式一律為</p>
<pre><code>tag1|value1|tag2|value2...
</code></pre>
<p>注意回傳格式不是 JSON 格式。</p>
<h2 id="version-api"><a class="header" href="#version-api">Version API</a></h2>
<p>程式可以使用 Version API 取得 Botnana Control 的版本。</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;version.get&quot;
}
</code></pre>
<p>會回傳以下字串：</p>
<pre><code>version|1.0.0
</code></pre>
<h2 id="configuration-api"><a class="header" href="#configuration-api">Configuration API</a></h2>
<p>程式可以使用 Configuration API 來處理參數設定檔。參數檔的設定，在重開機或重新讀取參數檔後生效。</p>
<h3 id="修改設定參數"><a class="header" href="#修改設定參數">修改設定參數</a></h3>
<p>修改設定參數並不會立刻將設定值儲存至參數設定檔，也不會影響到各裝置目前使用的參數。</p>
<h4 id="ethercat-position-與-alias-說明"><a class="header" href="#ethercat-position-與-alias-說明">EtherCAT Position 與 Alias 說明：</a></h4>
<p><strong>EtherCAT Position</strong>: 依據 EtherCAT 網路佈局，最靠近主站的 Position 為 1, 依序遞增。</p>
<p><strong>EtherCAT Alias</strong>: 每一個 EtherCAT 從站都可以設定一個站號的別名。一般設定此別名的方法有兩種：</p>
<ol>
<li>EtherCAT 從站內的 EEPROM，</li>
<li>EtherCAT 從站的硬體旋鈕。</li>
</ol>
<p>在設定參數時,如果 alias 不為 0，就會以 alias 選擇從站。當 alias 為 0，就以 position 選擇從站。</p>
<h4 id="設定-ethercat-slave-參數-configslaveset"><a class="header" href="#設定-ethercat-slave-參數-configslaveset">設定 EtherCAT Slave 參數 <code>config.slave.set</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.slave.set&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;alias&quot;: Slave Alis。
&quot;position&quot;: Slave Position。
&quot;channel&quot;: Device Channel，從 1 開始計數。
</code></pre>
<p>可設定參數：可以單獨設定一個或是多個</p>
<pre><code>&quot;homing_method&quot; : Homing method ,參考驅動器 0x6098:0x00 的描述。
&quot;homing_speed_1&quot; : Speed during search for switch ,參考驅動器 0x6099:0x01 的描述。
&quot;homing_speed_2&quot; : Speed during search for zero。參照選用驅動器 0x6099:0x02 的描述。
&quot;homing_acceleration&quot;: Homing acceleration。參照選用驅動器 0x609A:0x00 的描述。
&quot;profile_velocity&quot;: Profile velocity。參照選用驅動器 0x6081:0x00 的描述。
&quot;profile_acceleration&quot;: Profile acceleration。參照選用驅動器 0x6083:0x00 的描述。
&quot;profile_deceleration&quot;: Profile deceleration。參照選用驅動器 0x6084:0x00 的描述。
&quot;baud_rate&quot;: UART baud rate。參照 Beckhoff EL600x 或是 EL602X 0x8000:0x11 的描述。
&quot;data_frame&quot;: UART data frame。參照 Beckhoff EL600x 或是 EL602X 0x8000:0x15 的描述。
&quot;half_duplex&quot;: Uart Half Duplex Transmission。參照 Beckhoff EL600x 或是 EL602X 0x8000:0x06 的描述。
&quot;uart_p2p&quot;:  UART point to point。參照 Beckhoff EL600x 或是 EL602X 0x8000:0x07 的描述。
&quot;tx_optimization&quot;: UART Tx optimization。參照 Beckhoff EL600x 或是 EL602X 0x8000:0x07 的描述。
</code></pre>
<p>範例 1：修改 slave 1 channel 1 驅動器的回歸原點方法。</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.slave.set&quot;,
  &quot;params&quot;: {
    &quot;alias&quot;: 0,
    &quot;position&quot;: 1,
    &quot;channel&quot;: 1,
    &quot;homing_method&quot; : 33,
  }
}
</code></pre>
<p>範例 2：修改 slave 2 channel 3 驅動器的回歸原點的速度與加速度。</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.slave.set&quot;,
  &quot;params&quot;: {
    &quot;alias&quot;: 0,
    &quot;position&quot;: 2,
    &quot;channel&quot;: 3,
    &quot;homing_speed_1&quot; : 10000,
    &quot;homing_speed_2&quot; : 100,
    &quot;homing_acceleration&quot;: 5000,
  }
}    
</code></pre>
<h4 id="設定運動控制參數-configmotionset"><a class="header" href="#設定運動控制參數-configmotionset">設定運動控制參數 <code>config.motion.set</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.motion.set&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>None
</code></pre>
<p>可設定參數：可以單獨設定一個或是多個</p>
<pre><code>&quot;period_us&quot;: 執行周期 [us]
&quot;group_capacity&quot;: 軸組數
&quot;axis_capacity&quot;: 軸數
</code></pre>
<p>範例： </p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.motion.set&quot;,
  &quot;params&quot;: {
    &quot;period_us&quot;: 2000,
    &quot;group_capacity&quot;: 5,
    &quot;axis_capacity&quot;: 5
   }
}
</code></pre>
<h4 id="設定軸組參數-configgroupset"><a class="header" href="#設定軸組參數-configgroupset">設定軸組參數 <code>config.group.set</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.group.set&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;position&quot;: 指定軸組，從 1 開始計數。
</code></pre>
<p>可設定參數：可以單獨設定一個或是多個</p>
<pre><code>&quot;name&quot;: 軸組名稱
&quot;gtype&quot;: 軸組型態，可以設定 &quot;1D&quot;,&quot;2D&quot;,&quot;3D&quot;,&quot;SINE&quot;
&quot;mapping&quot;: 指定對應的運動軸，例如 [1, 2] 或是 [2, 1, 3]
&quot;vmax&quot;: 最大速度 [m/s],[rad/s],[pulse/s]
&quot;amax&quot;: 最大加速度 [m/s^2],[rad/s^2],[pulse/s^2]
&quot;jmax&quot;: 最大加加速度 [m/s^3],[rad/s^3],[pulse/s^3]    
</code></pre>
<p>範例： 設定 Group 1 的參數 </p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.group.set&quot;,
  &quot;params&quot;: {
    &quot;position&quot;: 1,
    &quot;name&quot;: &quot;BotnanaGo&quot;,
    &quot;gtype&quot;: &quot;2D&quot;,
    &quot;mapping&quot;: [1, 2],
    &quot;vmax&quot;: 0.5,
    &quot;amax&quot;: 5.0,
    &quot;jmax&quot;: 80.0, 
  }
}
</code></pre>
<h4 id="設定運動軸參數-configaxisset"><a class="header" href="#設定運動軸參數-configaxisset">設定運動軸參數 <code>config.axis.set</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.axis.set&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;position&quot;: 指定運動軸，從 1 開始計數。
</code></pre>
<p>可設定參數：可以單獨設定一個或是多個</p>
<pre><code>&quot;name&quot;: 運動軸名稱,
&quot;home_offset&quot;: Home offset,
&quot;encoder_ppu&quot;: encoder pulses per unit [pulses]
&quot;encoder_length_unit&quot;: encoder length unit [m],[rev],[pulse]
&quot;encoder_direction&quot;: encode direction, 1 or -1
&quot;vmax&quot;: 最大速度 [m/s],[rad/s],[pulse/s]
&quot;amax&quot;: 最大加速度 [m/s^2],[rad/s^2],[pulse/s^2]
&quot;slave_position&quot;: 對應驅動器的 EtherCAT 從站位置。
&quot;drive_channel&quot;: 對應驅動器上的第幾個 Channel。一般設定為 1,如果是東方馬達AZ系列多軸驅動器，就有可能是 2~3 。
</code></pre>
<p>範例： </p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.axis.set&quot;,
  &quot;params&quot;: {
    &quot;position&quot;: 1,
    &quot;name&quot;: &quot;X&quot;,
    &quot;home_offset&quot;: 0.05,
    &quot;encoder_ppu&quot;: 2000000.0,
    &quot;encoder_length_unit&quot;:&quot;Meter&quot;,
    &quot;encoder_direction&quot;: 1,
  }
}
</code></pre>
<h3 id="取得設定參數"><a class="header" href="#取得設定參數">取得設定參數</a></h3>
<h4 id="取得-ethercat-slave-參數-configslaveget"><a class="header" href="#取得-ethercat-slave-參數-configslaveget">取得 EtherCAT slave 參數 <code>config.slave.get</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.slave.get&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;alias&quot;: Slave Alias。
&quot;position&quot;: Slave Position。
&quot;channel&quot;: Device Channel，從 1 開始計數。
</code></pre>
<p>範例：</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.slave.get&quot;,
  &quot;params&quot;: {
    &quot;alias&quot;: 0,
    &quot;position&quot;: 1,
    &quot;channel&quot;: 1,
  }
}

回傳封包

config_slave_alias.1|0
|config_homing_method.1.1|33
|config_homing_speed_1.1.1|1000
|config_homing_speed_2.1.1|250
|config_homing_acceleration.1.1|500
|config_profile_velocity.1.1|1000000
|config_profile_acceleration.1.1|50000
|config_profile_deceleration.1.1|50000
|config_baud_rate.1.1|6
|config_data_frame.1.1|3
|config_half_duplex.1.1|1
|config_uart_p2p.1.1|0
|config_tx_optimization.1.1|1
</code></pre>
<h4 id="取得運動參數-configmotionget"><a class="header" href="#取得運動參數-configmotionget">取得運動參數 <code>config.motion.get</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.motion.get&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>None
</code></pre>
<p>範例： 取得 motion 設定</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.motion.get&quot;,
}

回傳封包:

config_period_us|2000
|config_group_capacity|7
|config_axis_capacity|10
</code></pre>
<h4 id="取得軸組參數-configgroupget"><a class="header" href="#取得軸組參數-configgroupget">取得軸組參數 <code>config.group.get</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.motion.get&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;position&quot;: 指定軸組，從 1 開始計數。
</code></pre>
<p>範例： 取得 Group 1 設定</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.group.get&quot;,
  &quot;params&quot;: {
    &quot;position&quot;: 1,
  }
}

回傳封包

config_group_name.1|BotnanaGo
|config_group_type.1|2D
|config_group_mapping.1|2,3
|config_group_vmax.1|0.200
|config_group_amax.1|5.000
|config_group_jmax.1|40.000
</code></pre>
<h4 id="取得軸組參數-configaxisget"><a class="header" href="#取得軸組參數-configaxisget">取得軸組參數 <code>config.axis.get</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;config.axis.get&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;position&quot;: 指定運動軸，從 1 開始計數。
</code></pre>
<p>範例： 取得 Axis 1</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.axis.get&quot;,
  &quot;params&quot;: {
    &quot;position&quot;: 1,
  }
}


回傳封包

config_axis_name.1|Anonymous
|config_axis_home_offset.1|0.0000
|config_encoder_ppu.1|1000000.00000
|config_encoder_length_unit.1|Meter
|config_encoder_direction.1|1
|config_slave_position.1|2
|config_drive_channel.1|2
</code></pre>
<h3 id="儲存設定參數"><a class="header" href="#儲存設定參數">儲存設定參數</a></h3>
<p>儲存設定參數會立刻將設定值儲存至參數設定檔，但不會影響到各裝置目前使用的參數。</p>
<p>關機再開後系統會使用新的設定。</p>
<p>範例：要求儲存 configuration：</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;config.save&quot;
}
</code></pre>
<h3 id="取得-pitch-補正表內容"><a class="header" href="#取得-pitch-補正表內容">取得 Pitch 補正表內容</a></h3>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;corrector.pitch.get&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;name&quot;: 補正表檔案名稱。檔案名稱格式為 PXXXX-YY.sdx，XXXX 表示 EtherCAT Slave Position 的位置（16 進位表示），YY 表示該  EtherCAT Slave 上的第幾個驅動器（16 進位表示）。
</code></pre>
<p>範例：取得 EtherCAT Slave Position 1 Drive Channel 1 的補正表</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;corrector.pitch.get&quot;,
  &quot;params&quot;: {
    &quot;name&quot;: &quot;P0001-01.sdx&quot;,
  }
}
</code></pre>
<h3 id="設定-pitch-補正表內容"><a class="header" href="#設定-pitch-補正表內容">設定 Pitch 補正表內容</a></h3>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;corrector.pitch.set&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;name&quot;: 補正表檔案名稱。檔案名稱格式為 PXXXX-YY.sdx，XXXX 表示 EtherCAT Slave Position 的位置（16 進位表示），YY 表示該  EtherCAT Slave 上的第幾個驅動器（16 進位表示）。
&quot;script&quot;: 補正表內容
</code></pre>
<p>範例：取得：</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;corrector.pitch.set&quot;,
  &quot;params&quot;: {
    &quot;name&quot;: &quot;P0001-01.sdx&quot;,
    &quot;script&quot;: &quot;內容範例如下&quot;
  }
}        


補正表內容範例：

{
    &quot;description&quot;: &quot;example&quot;,
    &quot;date&quot;: &quot;date&quot;,
    &quot;name&quot;: &quot;P0001-01.sdx&quot;,
    &quot;factor&quot;: 0.001,
    &quot;entries&quot;: [
        {
            &quot;position&quot;: 0.0,
            &quot;forward&quot;: 0.0,
            &quot;backward&quot;: 0.0
        },
        {
            &quot;position&quot;: 10.0,
            &quot;forward&quot;: 10.0,
            &quot;backward&quot;: 10.0
        },
   ]
}

position 表示命令位置。 Botnana-Control 的軸運動命令是 axis command = drive_command + home offset,
         查表時是使用 drive_command （避免受 home offset 調整影響）。
forward  表示正向運動時的實際位置。
backward 表示負向運動時的實際位置。
factor   表示 position, forward, backward 轉換到 Botnana-Control 的單位係數，
         一般 Botnana-Control 的單位可能會是 [m], [rad], [pulse]
</code></pre>
<h2 id="subscription-api"><a class="header" href="#subscription-api">Subscription API</a></h2>
<h3 id="subscription"><a class="header" href="#subscription">Subscription</a></h3>
<pre><code>{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;ec_slave.subscribe&quot;,
    &quot;params&quot;: {
        &quot;alias&quot;: 0,
        &quot;position&quot;: 1,
    }
}
</code></pre>
<h3 id="unsubscription"><a class="header" href="#unsubscription">Unsubscription</a></h3>
<pre><code>{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;ec_slave.subscribe&quot;,
    &quot;params&quot;: {
        &quot;alias&quot;: 0,
        &quot;position&quot;: 1,
    }
}
</code></pre>
<h2 id="real-time-scripting-api"><a class="header" href="#real-time-scripting-api">Real-time Scripting API</a></h2>
<p>Botnana Control 在其 real-time event loop 提供 Real-time script 來滿足更複雜的程式需求。為此提供兩個 JSON-RPC：</p>
<ul>
<li>script.evaluate: 解譯 real-time script。注意不可以使用 <code>script.evaluate</code> 來編譯 real-time script。</li>
<li>script.deploy: 編譯 real-time script。</li>
</ul>
<p>Real-time script 的指令集請見 <a href="./real-time-script-api.html">Real-time scripting API</a></p>
<h4 id="解譯-real-time-script-scriptevaluate"><a class="header" href="#解譯-real-time-script-scriptevaluate">解譯 real-time script <code>script.evaluate</code></a></h4>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;script.evaluate&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;script&quot;:real-time script 。
</code></pre>
<p>範例：以下 RPC 呼叫設定 Drive channel 1 of Slave 1 回歸原點方法的 JSON 命令。</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;script.evaluate&quot;,
  &quot;params&quot;: {
    &quot;script&quot;: &quot;33 1 1 homing-method!&quot;
  }
}
</code></pre>
<h4 id="部署-real-time-script-scriptdeploy"><a class="header" href="#部署-real-time-script-scriptdeploy">部署 real-time script <code>script.deploy</code></a></h4>
<p>此一命令將 script 轉交至背景執行的 Task 解譯或編譯，避免影響和使用者互動中的 Task。常用於大型 script 的解譯和執行。</p>
<p>方法：</p>
<pre><code>&quot;method&quot;: &quot;script.deploy&quot; 
</code></pre>
<p>必要參數：</p>
<pre><code>&quot;script&quot;: real-time script 。
</code></pre>
<p>範例：以下 RPC 呼叫編譯了一名為 p1 的程式。當 p1 執行時會設定 Drive channel 1 of Slave 1 回歸原點方法。</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;script.deploy&quot;,
  &quot;params&quot;: {
    &quot;script&quot;: &quot;: p1  33 1 1 homing-method! ;&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>Botnana Control 在其 real-time event loop 中使用了 Forth VM 以滿足更複雜的程式需求。透過 Forth 執行的命令會立刻影響裝置的行為。</p>
<p>文件網址:</p>
<p><a href="https://botnana.github.io/botnana-book/real-time-script-api.html">https://botnana.github.io/botnana-book/real-time-script-api.html</a></p>
<hr />
<h2 id="指令集"><a class="header" href="#指令集">指令集</a></h2>
<p>除了標準的 Forth 指令，Botnana Control 增加了以下 Forth 指令集。</p>
<ul>
<li><a href="./host-primitives.html">基本指令集</a></li>
<li><a href="./ethercat-primitives.html">EtherCAT 指令集</a></li>
<li><a href="./ethercat-drive-primitives.html">EtherCAT Drive 指令集</a></li>
<li><a href="./ethercat-io-primitives.html">EtherCAT IO 指令集</a></li>
<li><a href="./ethercat-uart-primitives.html">EtherCAT UART 指令集</a></li>
<li><a href="./ethercat-encoder-primitives.html">EtherCAT Encoder 指令集</a></li>
<li><a href="./ethercat-gateway-primitives.html">EtherCAT Gateway 指令集</a></li>
<li><a href="./axis-group.html">軸組 Axis Group 指令集</a>   </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="host-primitives"><a class="header" href="#host-primitives">Host primitives</a></h3>
<h4 id="mtime-----n-"><a class="header" href="#mtime-----n-"><code>mtime ( -- n )</code></a></h4>
<p>Current time in milliseconds</p>
<h4 id="cpu-timing-----"><a class="header" href="#cpu-timing-----"><code>.cpu-timing ( -- )</code></a></h4>
<p>Print information of CPU timing</p>
<h4 id="0cpu-timing-----"><a class="header" href="#0cpu-timing-----"><code>0cpu-timing ( -- )</code></a></h4>
<p>Reset CPU timing</p>
<h4 id="verbose-----"><a class="header" href="#verbose-----"><code>.verbose ( -- )</code></a></h4>
<p>Print verbose infornatiom</p>
<p>回傳訊息範例 :</p>
<pre><code>version_number|1.3.1|period_us|2000|launch_time|2018-08-09T10:19:21Z
</code></pre>
<h4 id="motion-----"><a class="header" href="#motion-----"><code>.motion ( -- )</code></a></h4>
<p>Print information of motion.</p>
<p>只能透過 Json API 進行設定。</p>
<p>命令範例:</p>
<pre><code>.motion
</code></pre>
<p>回傳訊息：</p>
<pre><code>period_us|2000
|group_capacity|7
|axis_capacity|10 
</code></pre>
<h4 id="本節指令集"><a class="header" href="#本節指令集">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>mtime</code></td><td>( -- n )</td></tr>
<tr><td><code>.cpu-timing</code></td><td>( -- )</td></tr>
<tr><td><code>0cpu-timing</code></td><td>( -- )</td></tr>
<tr><td><code>.verbose</code></td><td>( -- )</td></tr>
<tr><td><code>.motion</code></td><td>( -- )</td></tr>
</tbody></table>
<hr />
<h3 id="定時器指令-timer"><a class="header" href="#定時器指令-timer">定時器指令 （timer）</a></h3>
<p>可以使用的定時器總計有 100 個，編號從 1 ~ 100。</p>
<p>內部使用的計時單位是 Nanosecond，64 bits 的無號長整數計數，整個時間周期可以接近 500 年而不溢位。</p>
<p>定時器的定時時間使用 32 bits 的有號整數設定， 所以可以設定最長的時間是 24.8 天。</p>
<p>使用範例：</p>
<pre><code>   100 1 timer-ms!  \ 設定編號 1 定時器的計時時間為 100 ms。
   1 0timer             \ 定時器編號 1 重新計時。
   1 timer-expired? .   \ 檢視定時器編號 1 是否已經超過計時時間。
</code></pre>
<h4 id="timer--no----"><a class="header" href="#timer--no----"><code>.timer ( no -- )</code></a></h4>
<p>顯示定時器編號 <code>no</code> 的狀態。</p>
<p>命令範例:</p>
<pre><code>1 .timer
</code></pre>
<p>回傳訊息：</p>
<pre><code>timer_name.1|None|timer_duration.1|0.0 ms|
timer_expired.1|1|elapsed_time.1|307537.1 ms|
start_time.1|0.0 ms|current_time.1|307537.1 ms
</code></pre>
<h4 id="0timer--no----"><a class="header" href="#0timer--no----"><code>0timer ( no -- )</code></a></h4>
<p>定時器編號 <code>no</code> 重新計時。</p>
<h4 id="timer-ms--ms-no----"><a class="header" href="#timer-ms--ms-no----"><code>timer-ms! ( ms no -- )</code></a></h4>
<p>設定定時器編號 <code>no</code> 的計時時間為 <code>ms</code> Millisecond。</p>
<h4 id="timer-expired---no----t-"><a class="header" href="#timer-expired---no----t-"><code>timer-expired?  ( no -- t )</code></a></h4>
<p>定時器編號 <code>no</code> 是否已經超過計時時間？</p>
<h4 id="本節指令集-1"><a class="header" href="#本節指令集-1">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>.timer</code></td><td>( no -- )</td></tr>
<tr><td><code>0timer</code></td><td>( no -- )</td></tr>
<tr><td><code>timer-ms!</code></td><td>( ms no -- )</td></tr>
<tr><td><code>timer-expired?</code></td><td>( no -- t )</td></tr>
</tbody></table>
<hr />
<h3 id="數位正反器-flip-flop"><a class="header" href="#數位正反器-flip-flop">數位正反器 （Flip-flop）</a></h3>
<p>數位正反器可用來偵測數位訊號狀態轉移，可以偵測的型態有：</p>
<ul>
<li>高準位觸發(High Level Trigger）</li>
<li>低準位觸發(Low Level Trigger）</li>
<li>上緣觸發 (Rising Edge Trigger）</li>
<li>下緣觸發 (Falling Edge Trigger）</li>
</ul>
<p><strong>高準位觸發條件</strong></p>
<pre><code> True              +--------------
                   |
 False ------------+

                   |-----------|
                     Hold Time

   只要滿足 Hold Time 的時間，數位正反器就會切換為真（True）的狀態，
   反之則為假（False）。

   當條件滿足，數位正反器可以一直持續輸出為 True，直到原始訊號轉態為 False。

</code></pre>
<p><strong>低準位觸發條件</strong></p>
<pre><code> True  ------------+
                   |
 False             +--------------

                   |-----------|
                     Hold Time

   只要滿足 Hold Time 的時間，數位正反器就會切換為真（True）的狀態，
   反之則為假（False）。

   當條件滿足，數位正反器可以一直持續輸出為 True，直到原始訊號轉態為 True。

</code></pre>
<p><strong>上緣觸發條件</strong></p>
<pre><code> True              +---------
                   |
 False ------------+

         |---------|------|
           Set-up    Hold
           Time      Time

   要同時滿足 Set-up time 與 Hold Time 的時間，數位正反器才會切換為真（True）的狀態，
   反之則為假（False）。

   因為是邊緣觸發，所以數位正反器只有一個周期的輸出為 True。

</code></pre>
<p><strong>下緣觸發條件</strong></p>
<pre><code> True  ------------+
                   |
 False             +---------

         |---------|------|
           Set-up    Hold
           Time      Time

   要同時滿足 Set-up time 與 Hold Time 的時間，數位正反器才會切換為真（True）的狀態，
   反之則為假（False）。

   因為是邊緣觸發，所以數位正反器只有一個周期的輸出為 True。

</code></pre>
<p>可以使用的數位正反器總計有 100 個，編號從 1 ~ 100。因為數位正反器常用於 SFC 邏輯內，為效率上的考量，
所以名稱是 <code>_uc</code> 結尾的指令沒有檢查編號是否在正確的範圍，所以使用上要特別留意。</p>
<p>使用範例：</p>
<pre><code>   3 1 ff-type!           \ 設定數位正反器編號 1 為上緣觸發。
   2000 1 ff-setup!       \ 設定數位正反器編號 1 的建立時間。
   2000 1 ff-hold!        \ 設定數位正反器編號 1 的保持時間。
   true 1 ff-forth-uc     \ 設定數位正反器編號 1 的原始狀態，應該每個周期執行。
   ...
   1 ff-triggered-uc? .   \ 檢視數位正反器編號 1 是否已經觸發？
</code></pre>
<h4 id="ff--no----"><a class="header" href="#ff--no----"><code>.ff ( no -- )</code></a></h4>
<p>顯示數位正反器編號 <code>no</code> 的狀態。</p>
<p>命令範例:</p>
<pre><code>1 .ff
</code></pre>
<p>回傳訊息：</p>
<pre><code>ff_type.1|High Level|setup_time.1|2000|hold_time.1|2000|
setup_count.1|0|hold_count.1|0|last.1|0|triggered.1|0
</code></pre>
<h4 id="ff-forth-uc--t-no----"><a class="header" href="#ff-forth-uc--t-no----"><code>ff-forth-uc ( t no -- )</code></a></h4>
<p>每個周期設定給數位正反器編號 <code>no</code> 的狀態 <code>t</code>。</p>
<p><strong>此命令沒有檢查堆疊個數與 <code>no</code> 範圍，使用上要特別注意。</strong></p>
<h4 id="ff-hold--us-no----"><a class="header" href="#ff-hold--us-no----"><code>ff-hold! ( us no -- )</code></a></h4>
<p>設定數位正反器編號 <code>no</code> 的 Hold Time <code>us</code> Microsecond。</p>
<h4 id="ff-last-uc--no----t-"><a class="header" href="#ff-last-uc--no----t-"><code>ff-last-uc@ ( no -- t )</code></a></h4>
<p>數位正反器編號 <code>no</code> 最後/新的原始狀態？</p>
<p><strong>此命令沒有檢查堆疊個數與 <code>no</code> 範圍，使用上要特別注意。</strong></p>
<h4 id="ff-setup--us-no----"><a class="header" href="#ff-setup--us-no----"><code>ff-setup! ( us no -- )</code></a></h4>
<p>設定數位正反器編號 <code>no</code> 的 Setup Time <code>us</code> Microsecond。</p>
<h4 id="ff-triggered-uc--no----t-"><a class="header" href="#ff-triggered-uc--no----t-"><code>ff-triggered-uc? ( no -- t )</code></a></h4>
<p>數位正反器編號 <code>no</code> 是否滿足觸發條件？</p>
<p><strong>此命令沒有檢查堆疊個數與 <code>no</code> 範圍，使用上要特別注意。</strong></p>
<h4 id="ff-type--type-no----"><a class="header" href="#ff-type--type-no----"><code>ff-type! ( type no -- )</code></a></h4>
<p>設定數位正反器編號 <code>no</code> 的觸發型態 <code>type</code>。</p>
<p>觸發型態 <code>type</code> 設定值如下：</p>
<ul>
<li>1: 高準位觸發</li>
<li>2: 低準位觸發</li>
<li>3: 上緣觸發</li>
<li>4: 下緣觸發</li>
</ul>
<h4 id="has-ff--no----t-"><a class="header" href="#has-ff--no----t-"><code>has-ff? ( no -- t )</code></a></h4>
<p>是否有編號 <code>no</code> 的數位正反器？</p>
<h4 id="reset-ff--no----"><a class="header" href="#reset-ff--no----"><code>reset-ff ( no -- )</code></a></h4>
<p>重置數位正反器編號 <code>no</code>。不修改條件，只清除內部狀態。</p>
<h4 id="本節指令集-2"><a class="header" href="#本節指令集-2">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>.ff</code></td><td>( no -- )</td></tr>
<tr><td><code>ff-forth-uc</code></td><td>( t no -- )</td></tr>
<tr><td><code>ff-hold!</code></td><td>( us no -- )</td></tr>
<tr><td><code>ff-last-uc@</code></td><td>( no -- t )</td></tr>
<tr><td><code>ff-setup!</code></td><td>( us no -- )</td></tr>
<tr><td><code>ff-triggered-uc?</code></td><td>( no -- t )</td></tr>
<tr><td><code>ff-type!</code></td><td>( type no -- )</td></tr>
<tr><td><code>has-ff?</code></td><td>( no -- t )</td></tr>
<tr><td><code>reset-ff</code></td><td>( no -- )</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethercat-指令集"><a class="header" href="#ethercat-指令集">EtherCAT 指令集</a></h3>
<h4 id="ec-dc-----"><a class="header" href="#ec-dc-----"><code>.ec-dc ( -- )</code></a></h4>
<p>顯示 EtherCAT 通訊時間同步的狀況。</p>
<p>命令範例:</p>
<pre><code>.dc-dc
</code></pre>
<p>回傳訊息:</p>
<pre><code>dc_adjust_ns|65|dc_diff_ns|-865935|reference_time_diff_ns|2003080
|application_time_diff_ns|2052185
</code></pre>
<p>其中的：</p>
<pre><code>dc_adjust_ns:               EtherCAT 主站周期的調整量。
dc_diff_ns:                 EtherCAT 主從站之間的時間相位差。
reference_time_diff_ns:     EtherCAT 從站的周期。
application_time_diff_ns:   EtherCAT 主站的周期。
</code></pre>
<h4 id="ec-emcy--n----"><a class="header" href="#ec-emcy--n----"><code>.ec-emcy ( n -- )</code></a></h4>
<p>顯示 EtherCAT Slave Position <code>n</code> 的emergemcy message 訊息。目前 Botnana-Control 會依據 status word 中的 fault bit 自動送出 ?ec-emcy 的命令。</p>
<p>命令範例:</p>
<pre><code>1 .ec-emcy  \ 取得 EtherCAT 第 1 個從站的 emergemcy message
</code></pre>
<p>回傳訊息:</p>
<pre><code>error_code.1|0x5441
|error_register.1|0x20
|error_data.1.1|0
|error_data.2.1|19
|error_data.3.1|0
|error_data.4.1|0
|error_data.5.1|0
|error_message_cout|1
</code></pre>
<p>其中的：</p>
<pre><code>error code:                     等同於 Object 0x603F:00
error register:                 等同於 Object 0x1001: 00
error_data.1 ~ error_data.5:    為驅動器廠家定義的異警訊息。
                                此範例為台達電A2-E 驅動器所回傳的訊息,
                                error_data.2.1 = 19 表示異警碼 0x13 (緊急停止)
</code></pre>
<h4 id="ec-links-----"><a class="header" href="#ec-links-----"><code>.ec-links ( -- )</code></a></h4>
<p>顯示 EtherCAT 通訊的連線狀態</p>
<p>命令範例:</p>
<pre><code>.ec-links
</code></pre>
<p>回傳訊息:</p>
<pre><code>slaves_responding|3|al_states|8|link_up|1
|input_wc|3|output_wc|3|input_wc_state|1|output_wc_state|1
|input_wc_error|8187|output_wc_error|8233
|waiting_sdos_len|0|ec_ready|1
</code></pre>
<p>其中的：</p>
<pre><code>slaves_responding:  EtherCAT 從站的連線數
al_states:          所有 EtherCAT 從站的狀態。8 代表所有從站都在操作模式。
input_wc:           Input Data Working Count。有處理 Input Data 的從站數。
output_wc:          Output Data Working Count。有處理 Output Data 的從站數。
input_wc_state:     Input Data Working Count 正常與否，1 表示正常。
output_wc_state:    Output Data Working Count 正常與否，1 表示正常。
input_wc_error:     計數 input_wc_state = 0 的周期數。
                    通常在開機時因為時間還不能同步，所以在開機初期會增加。
output_wc_error:    計數 output_wc_state = 0 的周期數。
                    通常在開機時因為時間還不能同步，所以在開機初期會增加。
waiting_sdos_len:   等待處理的 SDO 命令數。
ec_ready:           1 表示 EtherCAT 通訊正常。
</code></pre>
<h4 id="ec-wdt-proc-data--n----"><a class="header" href="#ec-wdt-proc-data--n----"><code>.ec-wdt-proc-data ( n -- )</code></a></h4>
<p>顯示 EtherCAT Slave Position <code>n</code> 的 ESC Watchdog Time Process Data 的暫存器設定值。</p>
<p>命令範例:</p>
<pre><code>1 .ec-wdt-proc-data
</code></pre>
<p>回傳訊息:</p>
<pre><code>ec_wdt_proc_data.1|1000|ec_wdt_proc_data_busy.1|0|ec_wdt_proc_data_error.1|0
</code></pre>
<p>其中的：</p>
<pre><code>ec_wdt_proc_data:       ESC Watchdog Time Process Data 的暫存器設定值
ec_wdt_proc_data_busy:  要求設定或是讀取的指令是否還在執行中?
ec_wdt_proc_data_error: 要求設定或是讀取的指令是否執行失敗?
</code></pre>
<h4 id="sdo--n----"><a class="header" href="#sdo--n----"><code>.sdo ( n -- )</code></a></h4>
<p>顯示 EtherCAT Slave Position <code>n</code> 的 SDO 指令執行結果。</p>
<p>命令範例:</p>
<pre><code>2 .sdo
</code></pre>
<p>回傳訊息：</p>
<pre><code>sdo_index.2|0x6041
|sdo_subindex.2|0x00
|sdo_error.2|false
|sdo_busy.2|false
|sdo_data.2|24
|sdo_data_hex.2|0x0018
</code></pre>
<p>其中的：</p>
<pre><code>以 sdo_index.2 為例, .2 表示第 2 個 slave。
sdo_index   : EtherCAT object index。
sdo_subindex: EtherCAT object subindex。
sdo_error   : 此 sdo request 是否有問題,
              可能原因有 index 錯誤, 資料型態錯誤 ... 等等。
sdo_busy    : 此 SDO request 是否還在處理中。
sdo_data    : Object 的值。
sdo_data_hex: 以 16 進位表示 Object 的值。
</code></pre>
<h4 id="slave--n----"><a class="header" href="#slave--n----"><code>.slave ( n -- )</code></a></h4>
<p>顯示 EtherCAT Slave Position <code>n</code> 的資訊。</p>
<p>命令範例:</p>
<pre><code>2 .slave
</code></pre>
<p>以第 2 個 slave 為士林電機 SDP 驅動器為例，</p>
<p>回傳訊息：</p>
<pre><code>vendor.2|0x000005BC
|product.2|0x00000001
|description.2|SDP-E CoE Drive
|alias.2|0
|device_type.2|0x00020192
|profile_deceleration.1.2|50000
|profile_acceleration.1.2|50000
|profile_velocity.1.2|1000000
|operation_mode.1.2|6
|home_offset.1.2|0
|homing_method.1.2|33
|homing_speed_1.1.2|1000
|homing_speed_2.1.2|250
|homing_acceleration.1.2|500
|supported_drive_mode.1.2|0x000003ED
|control_word.1.2|0x0000
|target_position.1.2|2641624
|target_velocity.1.2|0
|status_word.1.2|0x0050
|real_position.1.2|2641624
|digital_inputs.1.2|0x00000000
|pds_state.1.2|Switch On Disabled
|pds_goal.1.2|Switch On Disabled
</code></pre>
<p>其中的</p>
<pre><code>vendor.2 表示第 2 個 slave 的 vendor id
product.2 表示第 2 個 slave 的 product code
description.2 表示第 2 個 slave 的 description
device_type.2 表示第 2 個 slave 的 device type, 其值為 0x00020192
profile_deceleration.1.2 表示第 2 個 slave 上第 1 個 drive 的 profile deceleration [pulse/s^2], 
profile_acceleration.1.2 表示第 2 個 slave 上第 1 個 drive 的 profile acceleration [pulse/s^2],
profile_velocity.1.2 表示第 2 個 slave 上第 1 個 drive 的 profile velocity [pulse/s],
operation_mode.1.2 表示第 2 個 slave 上第 1 個 drive 的 operation mode, 目前有支援的模式如下：
    1: profile position mode
    3: profile velocity mode
    6: homing mode
    8: cycle sync. position mode
homing_method.1.2 表示第 2 個 slave 上第 1 個 drive 的 homing method, 常用的模式有：
    1 : homing on negative limit and index pulse
    2 : homing on positive limit and index pulse
    3, 4 : homing on positive home switch and index pulse
    5, 6 : homing on negative home switch and index pulse
    33: homing on negative index pulse
    34: homing on positive index pulse
    35: homing on the current position
    其他: 參考驅動器 0x6098::0x00 的說明
homing_speed_1.1.2 表示第 2 個 slave 上第 1 個 drive 的 speed for search switch [pulse/s]        
homing_speed_2.1.2 表示第 2 個 slave 上第 1 個 drive 的 speed for search zero [pulse/s]
homing_acceleration 表示第 2 個 slave 上第 1 個 drive 的 homing acceleration [pulse/s^2]    
supported_drive_mode.1.2 表示第 2 個 slave 上第 1 個 drive 的 supported drive mode, 定義如下：
    Bit 0 : profile posiiton mode
    Bit 2 : profile velocity mode
    Bit 5 : homing  mode
    Bit 7 : cycle sync. position mode
    其他: 參考驅動器 0x6502::0x00 的說明    
control_word.1.2 表示第 2 個 slave 上第 1 個 drive 的 control word, 定義如下：
    Bit 0 : switch on
    Bit 1 : enable voltage
    Bit 2 : quick stop
    Bit 3 : enable operation
    Bit 4~6 : operation mode specification
    Bit 7 : fault Reset
    Bit 8 : halt
    其他: 參考驅動器 0x6040::0x00 的說明       
target_position.1.2 表示第 2 個 slave 上第 1 個 drive 的 target position [pulse]
target_velocity.1.2 表示第 2 個 slave 上第 1 個 drive 的 target velocity [pulse/s]
status_word.1.2  表示第 2 個 slave 上第 1 個 drive 的 status word, 定義如下：
    Bit 0 : ready to switch on
    Bit 1 : switch on
    Bit 2 : operation enabled (servo on)
    Bit 3 : fault
    Bit 4 : voltage enabled
    Bit 5 : quick stop
    Bit 6 : switch on disabled
    Bit 7 : warning
    Bit 10 : target reached
    其他: 參考驅動器 0x6041::0x00 的說明      
real_position.1.2  表示第 2 個 slave 上第 1 個 drive 的 real position [pulse]
digital_inputs.1.2 表示第 2 個 slave 上第 1 個 drive 的 digital inputs, 定義如下：
    Bit 0 : negative limit
    Bit 1 : positive limit
    Bit 2 : home switch
    其他: 參考驅動器 0x60FD::0x00 的說明 

Note: 單位會因驅動器而有不同
</code></pre>
<p>數位輸出回傳資料範例，以台達電 EC7062 為例：</p>
<pre><code>vendor.3|Delta|product.3|EC7062|dout.1.3|0|dout.2.3|0|dout.3.3|0|
dout.4.3|0|dout.5.3|0|dout.6.3|0|dout.7.3|0|dout.8.3|0|dout.9.3|0|
dout.10.3|0|dout.11.3|0|dout.12.3|0|dout.13.3|0|dout.14.3|0|
dout.15.3|0|dout.16.3|0

其中的 dout.11.3 代表是第 3 個 Slave 的第 11 個數位輸出。
</code></pre>
<p>數位輸入回傳資料範例，以台達電 EC6022 為例：</p>
<pre><code>vendor.7|Delta|product.7|EC6022|din.1.7|0|din.2.7|0|din.3.7|0|
din.4.7|0|din.5.7|0|din.6.7|0|din.7.7|0|din.8.7|0|din.9.7|0|
din.10.7|0|din.11.7|0|din.12.7|0|din.13.7|0|din.14.7|0|din.15.7|0|
din.16.7|0

其中的 din.15.7 代表是第 7 個 Slave 的第 15 個數位輸入。
</code></pre>
<p>類比輸出回傳資料範例，以台達電 EC9144 為例：</p>
<pre><code>vendor.5|Delta|product.5|EC9144|aout.1.5|0|aout.2.5|0|
aout.3.5|0|aout.4.5|0
</code></pre>
<p>類比輸入回傳資料範例，以台達電 EC8124 為例：</p>
<pre><code>vendor.4|Delta|product.4|EC8124|ain.1.4|0|ain.2.4|0|
ain.3.4|0|ain.4.4|0
</code></pre>
<h4 id="slave-diff--n----"><a class="header" href="#slave-diff--n----"><code>.slave-diff ( n -- )</code></a></h4>
<p>顯示 EtherCAT Slave Position <code>n</code> 的資訊。 只回傳與上次要求不同的資訊。</p>
<p>使用者可以使用 <code>.slave</code> 取得所有參數。使用 <code>.slave-diff</code> 取得自上次執行 <code>.slave</code>
或是 <code>.slave-diff</code> 後被改變的狀態。 如果上次執行 <code>.slave</code> 或 <code>.slave-diff</code> 後狀態都沒有改變，
回傳資料為空字串。</p>
<p>命令範例: </p>
<pre><code>2 .slave-diff
</code></pre>
<h4 id="ec-emcy--n-----1"><a class="header" href="#ec-emcy--n-----1"><code>?ec-emcy ( n -- )</code></a></h4>
<p>當驅動器發生異警時，可以使用此命令讓驅動器將異警訊息（emergency message）傳送回來。</p>
<h4 id="ec-wdt-proc-data--n-----1"><a class="header" href="#ec-wdt-proc-data--n-----1"><code>@ec-wdt-proc-data ( n -- ) </code></a></h4>
<p>從 EtherCAT 從站 <code>n</code> 讀回 ESC Watchdog Time Process data 暫存器的值。此命令是要求 EtherCAT 從站將暫存器值傳送回來，不會馬上取得結果。
可以透過 <code>ec-wdt-proc-data-busy?</code> 的結果得知是否已經回傳。</p>
<h4 id="ec-an--alias----n-"><a class="header" href="#ec-an--alias----n-"><code>ec-a&gt;n ( alias -- n )</code></a></h4>
<p>利用 EtherCAT slaves alias <code>alias</code> 找到對應的 Slave position <code>n</code></p>
<p>Note:</p>
<ol>
<li><code>alias</code> 不可以為零</li>
<li>假如 <code>alias</code> 不存在，則會回傳錯誤訊息</li>
</ol>
<h4 id="ec-ain--ch-n----t-"><a class="header" href="#ec-ain--ch-n----t-"><code>ec-ain? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>channel</code> 是否為類比輸入？</p>
<h4 id="ec-alias--alias-n----"><a class="header" href="#ec-alias--alias-n----"><code>ec-alias! ( alias n -- )</code></a></h4>
<p>設定 EtherCAT slave position <code>n</code> 的 alias 為 <code>alias</code>。</p>
<p>Note:</p>
<ol>
<li><code>alias</code> 除了 0 以外，不可重複。</li>
<li>此設定命令是修改 SII EEPROM 對應的暫存器。如果是由硬體旋鈕控制的，就不需要由此命令設定。</li>
<li>不可以有重複的 alias。</li>
<li>此命令會造成 Real Time Cycle Overrun。要在所有驅動器 Servo OFF 情況執行。</li>
</ol>
<h4 id="ec-alias--alias----t-"><a class="header" href="#ec-alias--alias----t-"><code>ec-alias? ( alias -- t )</code></a></h4>
<p>EtherCAT slave alias <code>alias</code> 是否存在？ </p>
<h4 id="ec-aout--ch-n----t-"><a class="header" href="#ec-aout--ch-n----t-"><code>ec-aout? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為類比輸出？</p>
<h4 id="ec-din--ch-n----t-"><a class="header" href="#ec-din--ch-n----t-"><code>ec-din? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為數位輸入？</p>
<h4 id="ec-dout--ch-n----t-"><a class="header" href="#ec-dout--ch-n----t-"><code>ec-dout? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為數位輸出？</p>
<h4 id="ec-drive--ch-n----t-"><a class="header" href="#ec-drive--ch-n----t-"><code>ec-drive? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為馬達驅動器？</p>
<h4 id="ec-emcy-busy--n----t-"><a class="header" href="#ec-emcy-busy--n----t-"><code>ec-emcy-busy? ( n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> 的 <code>?ec-emcy</code> 是否等待執行中？</p>
<h4 id="ec-encoder--ch-n----t-"><a class="header" href="#ec-encoder--ch-n----t-"><code>ec-encoder? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為編碼器輸入模組？</p>
<h4 id="ec-gateway--ch-n----t-"><a class="header" href="#ec-gateway--ch-n----t-"><code>ec-gateway? ( ch n -- t )</code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為閘道器 (Gateway) 模組？</p>
<h4 id="ec-load--n----"><a class="header" href="#ec-load--n----"><code>ec-load ( n -- )</code></a></h4>
<p>將 EtherCAT slave position <code>n</code> 的設定值回復到原廠預設值。相當設定 Object 0x1011:1 為 0x64616F6C (ASCII: l:0x6C, o:0x6F, a:61, d:64)。</p>
<p>如果 EtherCAT slave 有提供回復到原廠預設值功能，大部份會使用此方式。</p>
<h4 id="ec-ready-----t-"><a class="header" href="#ec-ready-----t-"><code>ec-ready? ( -- t )</code></a></h4>
<p>EtherCAT 通訊是否備妥或是正常？</p>
<h4 id="ec-save--n----"><a class="header" href="#ec-save--n----"><code>ec-save ( n -- )</code></a></h4>
<p>將 EtherCAT slave position <code>n</code> 目前的設定值存到 EEPROM。相當設定 Object 0x1010:1 為 0x65766173 (ASCII: s:0x73, a:0x61, v:76, e:65)。</p>
<p>如果 EtherCAT slave 有提供設定參數到 EEPROM 的功能，大部份會使用此方式。</p>
<h4 id="ec-uart---ch-n----t-"><a class="header" href="#ec-uart---ch-n----t-"><code>ec-uart?  ( ch n -- t ) </code></a></h4>
<p>EtherCAT slave position <code>n</code> Channel <code>ch</code> 是否為 UART 模組？</p>
<h4 id="ec-wdt-proc-data---n----interval-"><a class="header" href="#ec-wdt-proc-data---n----interval-"><code>ec-wdt-proc-data@  ( n -- interval )</code></a></h4>
<p>將 EtherCAT 從站 <code>n</code> 的 Watchdog time <code>interval</code> 放到整數堆疊上。</p>
<h4 id="ec-wdt-proc-data---interval-n----"><a class="header" href="#ec-wdt-proc-data---interval-n----"><code>ec-wdt-proc-data!  ( interval n -- )</code></a></h4>
<p>設定 EtherCAT 從站 <code>n</code> 的 Watchdog time 設定為 <code>interval</code>。其 <code>interval</code> 的時間必須參考從站的 Watchdog 設定。</p>
<p>如果要將 Watchdog 關閉就將 <code>interval</code> 設定為 0 。</p>
<h4 id="ec-wdt-proc-data-busy---n----t-"><a class="header" href="#ec-wdt-proc-data-busy---n----t-"><code>ec-wdt-proc-data-busy?  ( n -- t )</code></a></h4>
<p>是否正在執行 <code>@ec-wdt-proc-data</code> 中？</p>
<h4 id="ec-wdt-proc-data-error--n----t-"><a class="header" href="#ec-wdt-proc-data-error--n----t-"><code>ec-wdt-proc-data-error? ( n -- t )</code></a></h4>
<p>執行 <code>@ec-wdt-proc-data</code> 的結果是否有錯誤？</p>
<h4 id="list-slaves-----"><a class="header" href="#list-slaves-----"><code>list-slaves ( -- )</code></a></h4>
<p>顯示所以 EtherCAT 從站的 vendor id 與 product code。</p>
<p>測試範例： 第 1 個從站為台達電 A2-E驅動器 , 第 2 個從站為士林電機驅動器。</p>
<p>回傳訊息：</p>
<pre><code>slaves|477,271601776,1468,1

台達電 A2-E:  vendor_id = 477 (0x1DD)
             product_code =  271601776 (0x10305070)
士林電機 SDP: vendor_id = 1468 (0x5BC)
             product_code =  1 (0x1)
</code></pre>
<h4 id="sdo-busy--n----t-"><a class="header" href="#sdo-busy--n----t-"><code>sdo-busy? ( n -- t )</code></a></h4>
<p>EtherCAT slave  position <code>n</code> 的 SDO 命令是否等待執行？</p>
<p>命令範例 1: </p>
<pre><code>2 sdo-busy?
</code></pre>
<p>命令範例 2: 讀取 Slave 2 0x6064:0x00 位址的值，等待該命令完成後輸出訊息。</p>
<pre><code>: test-sdo 0 $6064 2 sdo-upload-i32 
           begin 2 sdo-busy? while pause repeat
           2 .sdo ;
 deploy test-sdo ;deploy
 
 Note: 
 1. pause: 表示當下的命令暫停, 等待下一個real time cycle 執行時，再從命令暫停的地方開始執行。
 2. deploy test-sdo ;deploy : 將 test-sdo 指令放到背景執行。
        因為 test-sdo 所定義的命令中有含有等待的指令, 如在當前的 Task 執行，
        就無法再處理後續由 client 端送進來的指令。
</code></pre>
<h4 id="sdo-data--n----data-"><a class="header" href="#sdo-data--n----data-"><code>sdo-data@ ( n -- data )</code></a></h4>
<p>取得 EtherCAT slave  position <code>n</code> 的 SDO 命令的資料 <code>data</code>。</p>
<h4 id="sdo-error--n----t-"><a class="header" href="#sdo-error--n----t-"><code>sdo-error? ( n -- t )</code></a></h4>
<p>EtherCAT slave  position <code>n</code> 的 SDO 命令的執行結果是否有問題？</p>
<h4 id="sdo-download-i16--data-subindex-index-n----"><a class="header" href="#sdo-download-i16--data-subindex-index-n----"><code>sdo-download-i16 ( data subindex index n -- )</code></a></h4>
<p>將設定值 <code>data</code> 以 16 bits 有號整數的型式透過 SDO 寫到 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-download-i32--data-subindex-index-n----"><a class="header" href="#sdo-download-i32--data-subindex-index-n----"><code>sdo-download-i32 ( data subindex index n -- )</code></a></h4>
<p>將設定值 <code>data</code> 以 32 bits 有號整數的型式透過 SDO 寫到 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<p>命令範例：</p>
<pre><code>100 0 $60FF 2 sdo-download-i32 \ 將 `100` 寫到 slave position `2` Object `0x60ff`:`0`
</code></pre>
<h4 id="sdo-download-i8--data-subindex-index-n----"><a class="header" href="#sdo-download-i8--data-subindex-index-n----"><code>sdo-download-i8 ( data subindex index n -- )</code></a></h4>
<p>將設定值 <code>data</code> 以 8 bits 有號整數的型式透過 SDO 寫到 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-download-u16--data-subindex-index-n----"><a class="header" href="#sdo-download-u16--data-subindex-index-n----"><code>sdo-download-u16 ( data subindex index n -- )</code></a></h4>
<p>將設定值 <code>data</code> 以 16 bits 無號整數的型式透過 SDO 寫到 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-download-u32--data-subindex-index-n----"><a class="header" href="#sdo-download-u32--data-subindex-index-n----"><code>sdo-download-u32 ( data subindex index n -- )</code></a></h4>
<p>將設定值 <code>data</code> 以 32 bits 無號整數的型式透過 SDO 寫到 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-download-u8--data-subindex-index-n----"><a class="header" href="#sdo-download-u8--data-subindex-index-n----"><code>sdo-download-u8 ( data subindex index n -- )</code></a></h4>
<p>將設定值 <code>data</code> 以 8 bits 無號整數的型式透過 SDO 寫到 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-upload-i16--subindex-index-n----"><a class="header" href="#sdo-upload-i16--subindex-index-n----"><code>sdo-upload-i16 ( subindex index n -- )</code></a></h4>
<p>以 16 bits 有號整數的型式透過 SDO 讀取 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-upload-i32--subindex-index-n----"><a class="header" href="#sdo-upload-i32--subindex-index-n----"><code>sdo-upload-i32 ( subindex index n -- )</code></a></h4>
<p>以 32 bits 有號整數的型式透過 SDO 讀取 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<p>命令範例:</p>
<pre><code>0 $6064 2 sdo-upload-i32 \ 讀取 slave position `2` Object `0x6064`:`0`
</code></pre>
<h4 id="sdo-upload-i8---subindex-index-n----"><a class="header" href="#sdo-upload-i8---subindex-index-n----"><code>sdo-upload-i8  ( subindex index n -- )</code></a></h4>
<p>以 8 bits 有號整數的型式透過 SDO 讀取 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-upload-u16--subindex-index-n----"><a class="header" href="#sdo-upload-u16--subindex-index-n----"><code>sdo-upload-u16 ( subindex index n -- )</code></a></h4>
<p>以 16 bits 無號整數的型式透過 SDO 讀取 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-upload-u32--subindex-index-n----"><a class="header" href="#sdo-upload-u32--subindex-index-n----"><code>sdo-upload-u32 ( subindex index n -- )</code></a></h4>
<p>以 32 bits 無號整數的型式透過 SDO 讀取 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="sdo-upload-u8---subindex-index-n----"><a class="header" href="#sdo-upload-u8---subindex-index-n----"><code>sdo-upload-u8  ( subindex index n -- )</code></a></h4>
<p>以 8 bits 無號整數的型式透過 SDO 讀取 EtherCAT slave <code>n</code> 的 Object Index <code>index</code>: subindex <code>subindex</code>。</p>
<h4 id="until-no-requests-----"><a class="header" href="#until-no-requests-----"><code>until-no-requests ( -- )</code></a></h4>
<p>等待所有的 SDO Requests 完成。</p>
<p>相當於</p>
<pre><code>: until-no-requests ( -- )
    .&quot; log|until-no-requests&quot; cr
    begin
        waiting-requests?
    while
        pause
    repeat ;
</code></pre>
<h4 id="waiting-requests-----t-"><a class="header" href="#waiting-requests-----t-"><code>waiting-requests? ( -- t )</code></a></h4>
<p>是否所有的 SDO 命令都已經執行完畢 ？</p>
<h4 id="本節指令集-3"><a class="header" href="#本節指令集-3">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>.ec-dc</code></td><td>( -- )</td></tr>
<tr><td><code>.ec-emcy</code></td><td>( n -- )</td></tr>
<tr><td><code>.ec-links</code></td><td>( -- )</td></tr>
<tr><td><code>.ec-wdt-proc-data</code></td><td>( n -- )</td></tr>
<tr><td><code>.sdo</code></td><td>( n --  )</td></tr>
<tr><td><code>.slave</code></td><td>( n -- )</td></tr>
<tr><td><code>.slave-diff</code></td><td>( n -- )</td></tr>
<tr><td><code>?ec-emcy</code></td><td>( n -- )</td></tr>
<tr><td><code>@ec-wdt-proc-data</code></td><td>( n -- )</td></tr>
<tr><td><code>ec-a&gt;n</code></td><td>( alias -- n )</td></tr>
<tr><td><code>ec-ain?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-alias!</code></td><td>( alias n -- )</td></tr>
<tr><td><code>ec-alias?</code></td><td>( alias -- t )</td></tr>
<tr><td><code>ec-aout?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-din?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-dout?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-drive?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-emcy-busy?</code></td><td>( n -- t )</td></tr>
<tr><td><code>ec-encoder?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-gateway?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-load</code></td><td>( n -- )</td></tr>
<tr><td><code>ec-ready?</code></td><td>( -- t )</td></tr>
<tr><td><code>ec-save</code></td><td>( n -- )</td></tr>
<tr><td><code>ec-uart?</code></td><td>( ch n -- t )</td></tr>
<tr><td><code>ec-wdt-proc-data@</code></td><td>( n -- data )</td></tr>
<tr><td><code>ec-wdt-proc-data!</code></td><td>( cmd n -- )</td></tr>
<tr><td><code>ec-wdt-proc-data-busy?</code></td><td>( n -- t )</td></tr>
<tr><td><code>ec-wdt-proc-data-error?</code></td><td>( n -- t )</td></tr>
<tr><td><code>list-slaves</code></td><td>( -- )</td></tr>
<tr><td><code>sdo-busy?</code></td><td>( n -- t )</td></tr>
<tr><td><code>sdo-data@</code></td><td>( n -- data )</td></tr>
<tr><td><code>sdo-error?</code></td><td>( n -- t )</td></tr>
<tr><td><code>sdo-download-i16</code></td><td>( data subindex index n -- )</td></tr>
<tr><td><code>sdo-download-i32</code></td><td>( data subindex index n -- )</td></tr>
<tr><td><code>sdo-download-i8</code></td><td>( data subindex index n -- )</td></tr>
<tr><td><code>sdo-download-u16</code></td><td>( data subindex index n -- )</td></tr>
<tr><td><code>sdo-download-u32</code></td><td>( data subindex index n -- )</td></tr>
<tr><td><code>sdo-download-u8</code></td><td>( data subindex index n -- )</td></tr>
<tr><td><code>sdo-upload-i16</code></td><td>( subindex index n -- )</td></tr>
<tr><td><code>sdo-upload-i32</code></td><td>( subindex index n -- )</td></tr>
<tr><td><code>sdo-upload-i8</code></td><td>( subindex index n -- )</td></tr>
<tr><td><code>sdo-upload-u16</code></td><td>( subindex index n -- )</td></tr>
<tr><td><code>sdo-upload-u32</code></td><td>( subindex index n -- )</td></tr>
<tr><td><code>sdo-upload-u8</code></td><td>( subindex index n -- )</td></tr>
<tr><td><code>until-no-requests</code></td><td>( -- )</td></tr>
<tr><td><code>waiting-requests?</code></td><td>( -- t )</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethercat-drive-指令集"><a class="header" href="#ethercat-drive-指令集">EtherCAT Drive 指令集</a></h3>
<p>EtherCAT 驅動器通常都會符合 CiA 402 規範，此規範定義了驅動器的操作模式與介面。實際上驅動器並不會實現所有 CiA 402 規範提到的所有功能，在選用驅動器時還是要留意。</p>
<p>目前 Botnana Control 支援以下幾種驅動器的運動模式：</p>
<ul>
<li>位置控制模式 PP (Profile Position Mode）</li>
<li>速度控制模式 PV (Profile Velocity Mode）</li>
<li>原點復歸模式 HM (Homing mode)</li>
<li>扭力控制模式 TQ (Profile  Torque Mode)</li>
<li>週期同步位置模式 CSP (Cyclic Sync Position Mode)</li>
<li>週期同步速度模式 CSV (Cyclic Sync Velocity Mode)</li>
<li>週期同步扭力模式 CST (Cyclic Sync Torque Mode)</li>
</ul>
<p>就應用面來看週期同步模式適合用來做多軸同動或是特殊的軌跡規劃。</p>
<p><strong>位置模式方塊圖：</strong></p>
<pre><code>               +--------+
               | +----&gt; |----------------------- +
               | |CSP   |                        |
               | |      |      +-------------+   v    +-----------+
Target   -----&gt;|-+----&gt; |-----&gt;| Position    |--&gt;o---&gt;|  Position |----&gt; Control
Position       |  PP    |      | Trajectory  |        |  Control  |      Effect
               |        |      | Generation  |        |           |
               +--------+      +-------------+        +-----------+
              Mode Seletor

</code></pre>
<p><strong>速度模式方塊圖：</strong></p>
<pre><code>               +--------+
               | +----&gt; |----------------------- +
               | |CSV   |                        |
               | |      |      +-------------+   v    +-----------+
Target   -----&gt;|-+----&gt; |-----&gt;| Velocity    |--&gt;o---&gt;|  Velocity |----&gt; Control
Velocity       |  PV    |      | Trajectory  |        |  Control  |      Effect
               |        |      | Generation  |        |           |
               +--------+      +-------------+        +-----------+
              Mode Seletor

</code></pre>
<p><strong>扭力模式方塊圖：</strong></p>
<pre><code>               +--------+
               | +----&gt; |----------------------- +
               | |CST   |                        |
               | |      |      +-------------+   v    +-----------+
Target   -----&gt;|-+----&gt; |-----&gt;| Torque      |--&gt;o---&gt;|  Torque   |----&gt; Control
Torque         |  TQ    |      | Trajectory  |        |  Control  |      Effect
               |        |      | Generation  |        |           |
               +--------+      +-------------+        +-----------+
              Mode Seletor

</code></pre>
<p><strong>原點復歸模式</strong>：以下是幾種常見的復歸方法，每一種驅動器必須依該廠家的所支援的方法為準。</p>
<ul>
<li>Method 1 and 2 : Homing on the limit switch and index pulse</li>
</ul>
<p>依據所選擇的負/正方向，原點位置在遇到 limit switch 反轉後最靠近的 index pulse。</p>
<pre><code>++                    ++                     ++
||--------------------||---------------------||
||--------------------||---------------------||
++                    ++                     ++
                       |
     +-----------------|
     |.     .          |
     +-----(1)-&gt;
      .     .
      .     |         |       |    Index Pulse
------------+---------+-------+----------------
------+
      |                    Negativ Limit Switch
      +----------------------------------------
                       |             .   .
                       |-------------------+
                       |             .   . |
                                  &lt;-(2)----+
                                     .   .
                                     .   .
Index Pulse            |       |     |   .
-----------------------+-------+-----+----------
                                         +------
Positive Limit Switch                    |
-----------------------------------------+
</code></pre>
<ul>
<li>Methods 3 to 6: Homing on the home switch and index pulse</li>
</ul>
<p>依據所選擇的負/正方向與方法，原點位置在遇到 home switch 後最靠近的 index pulse。</p>
<pre><code>++                                           ++
||-------------------------------------------||
||-------------------------------------------||
++                                           ++
    |
    |------------------+
    |            .    .|   .
              &lt;-(3)----+   .
                 .    .    .             |
              &lt;-(3)----------------------|
                 .    .    .             |
    |            .    .    .
    |---------------------(4)-&gt;
    |            .    .    .             |
                 .   +-------------------|
                 .   |.    .             |
                 .   +----(4)-&gt;
                 .    .    .
Index Pulse      |    .    |
-----------------+----------------------------
                      +-----------------------
Home Switch           |
----------------------+
     |             .   .    .
     |---------------------(5)-&gt;
     |             .   .    .            |
                   .  +------------------|
                   .  |.    .            |
                   .  +----(5)-&gt;
     |             .   .    .
     |------------------+   .
     |             .   .|   .
                &lt;-(6)--.+   .
                   .   .    .              |
                &lt;-(6)----------------------|
                   .   .    .              |
Index Pulse        |   .    |
-------------------+--------+--------------------
Home Switch            .
-----------------------+
                       |
                       +-------------------------
</code></pre>
<ul>
<li>Methods 7 to 10: Homing on positive limit switch, home switch and index pulse</li>
</ul>
<p>與 Methods 3 to 6 的方法類似，遇到正極限開關後反轉，會依其設定方式尋找 index pulse。</p>
<pre><code>++                                                                ++
||----------------------------------------------------------------||
||----------------------------------------------------------------||
++                                                                ++
    |           .     .      .           .      .         .
    |--------------------------------------------+------(10)-&gt;
    |           .     .      .           .      .|        .
    |------------------+----(8)-&gt;     &lt;-(9)------+        .
                .     .|     .           .      .         .
             &lt;-(7)-----+     .           .      .         .
                .     .      .     |     .      .         .
             &lt;-(7)---+-------------+-------------+------(10)-&gt;
                .    |.      .     |     .      .|        .
                .    +------(8)-&gt;     &lt;-(9)------+        .
                .     .      .           .      .       | .  .
                .     .      .           .      .       |-----+
                .     .      .           .      .       | .  .|
                .     .      .           .      .         .  .|
             &lt;-(7)---+----------------------------------------+
                .    |.      .           .      .         .  .|
                .    +------(8)-&gt;     &lt;-(9)----+--------------+
                .     .      .           .     |.         .  .
                .     .      .           .     +--------(10)-&gt;
                .     .      .           .      .         .  .
Index Pulse     |     .      |           |      .         |  .
-------------------------------------------------------------------
                      +-------------------------+            .
Home Switch           |                         |            .
----------------------+                         +------------------
                                                             +-----
Positive Limit Switch                                        |
-------------------------------------------------------------+
</code></pre>
<ul>
<li>Methods 11 to 14: Homing on negative limit switch, home switch and index pulse</li>
</ul>
<p>與 Methods 3 to 6 的方法類似，遇到負極限開關後反轉，會依其設定方式尋找 index pulse。</p>
<pre><code>++                                                                       ++
||-----------------------------------------------------------------------||
||-----------------------------------------------------------------------||
++                                                                       ++
                  .      .     .           .      .      .         |
              &lt;-(14)----+-------------------------.----------------|
                  .     |.     .           .      .      .         |
                  .     +-----(13)-&gt;   &lt;-(12)---+-.----------------|
                  .      .     .           .    | .      .         |
                  .      .     .           .    +-.-----(11)-&gt;
                  .      .     .     |     .      .      .
              &lt;-(14)----+------------+-------------+----(11)-&gt;
                  .     |.     .     |     .      .|     .
                  .     +-----(13)-&gt;   &lt;-(12)------+     .
       .     |    .      .     .           .      .      .
      +------|    .      .     .           .      .      .
      |.     |    .      .     .           .      .      .
      |.          .      .     .           .      .      .
      +--------------------------------------------+----(11)-&gt;
      |.          .      .     .           .      .|     .
      +-------------------+---(13)-&gt;   &lt;-(12)------+     .
       .          .      .|    .           .      .      .
       .      &lt;-(14)------+    .           .      .      .
       .          .      .     .           .      .      .
Index Pulse       |      .     |           |      .      |
---------------------------------------------------------------------
       .                 +------------------------+
Home Switch              |                        |
+------------------------+                        +------------------
       +-------------------------------------------------------------
       |                                      Negative Limit Switch
+------+
</code></pre>
<ul>
<li>Methods 17 and 18: Homing on limit switch without an index pulse</li>
</ul>
<p>依據所選擇的負/正方向，原點位置在 limit switch 上。</p>
<pre><code> ++                 ++                        ++
 ||-----------------||------------------------||
 ||-----------------||------------------------||
 ++                 ++                        ++
       .             |
    +----------------|
    |  .             |
    +-(17)-&gt;
       .
 ------+
       |                    Negative Limit Switch
       +-----------------------------------------
                      |                   .
                      |-----------------------+
                      |                   .   |
                                       &lt;-(18)-+
                                          .
                                          +------
Positive Limit Switch                     |
------------------------------------------+
</code></pre>
<ul>
<li>Methods 19 to 22: Homing on home switch without an index pulse</li>
</ul>
<p>依據所選擇的負/正方向與方式，原點位置在 home switch 上。</p>
<pre><code> ++    ++                                     ++
 ||----||-------------------------------------||
 ||----||-------------------------------------||
 ++    ++                 .                   ++
       |                  .
       |-------------------------+
       |                  .      |
                      &lt;-(19)-----+
                          .            |
                      &lt;-(19)-----------|
       |                  .            |
       |----------------(20)-&gt;
       |                  .            |
                  +--------------------|
                  |       .            |
                  +-----(20)-&gt;
                          .
                          +--------------------
Home Switch               |
--------------------------+

 ++    ++                                     ++
 ||----||-------------------------------------||
 ||----||-------------------------------------||
 ++    ++                 .                   ++
       |                  .
       |----------------(21)-&gt;
       |                  .            |
                  +--------------------|
                  |       .            |
                  +-----(21)-&gt;
       |                  .
       |-------------------------+
       |                  .      |
                      &lt;-(22)-----+     |
                      &lt;-(22)-----------|
                          .            |
Home Switch               .
--------------------------+
                          |
                          +--------------------
</code></pre>
<ul>
<li>Methods 33 and 34: Homing on the index pulse</li>
</ul>
<p>依據所選擇的負/正方向，原點位置在最靠近目前位置的 index pulse。</p>
<pre><code>++                   ++                      ++
||-------------------||----------------------||
||-------------------||----------------------||
++                   ++                      ++
                .     |     .
           &lt;--(33)----|     .
                .     |---(34)---&gt;
                .     |     .
 Index Pulse    .           .
    |           |           |            |
 -------------------------------------------------
</code></pre>
<ul>
<li>Methods 35 and 37: Homing on current position</li>
</ul>
<p>原點位置就在目前位置。</p>
<pre><code>++                   ++                      ++
||-------------------||----------------------||
||-------------------||----------------------||
++                   ++                      ++
                    (35)
                    (37)
</code></pre>
<p><strong>驅動器運行狀態</strong></p>
<pre><code>               +-------+
--------------&gt;| FSA   +--------------&gt;
Control Word   |       |   Status Word
(0x6040)       +-------+   (0x6041)
</code></pre>
<p>FSA (Finite States Automaton) of PDS (Power Drive System)</p>
<pre><code>             Start
               |
               |
               V 0
        +-------------------+
        | Not Ready to      |
        | switch on         |
        | (Not initialized) |
        +-------------------+
               |
               |
               V 1
 +------------------------------+       +-----------+
 |         Switch on            | 15    |   Fault   |
 |         Disabled             |&lt;------|           |
 |  (Initialization completed)  |       |  (Alarm)  |
 +------------------------------+       +-----------+
  ^ 9        |   ^ 7   ^ 10   ^ 12            ^ 14
  |          |   |     |      |               |
  |          v 2 |     |      |               |
  |  +---------------+ |      |               |
  |  |  Ready to     | |      |               |
  |  |  Switch on    | |      |               |
  |  | (Main circuit | |      |               |
  |  |  power off )  | |      |               |
  |  +---------------+ |      |               |
  |    ^ 8   |   ^ 6   |      |               |
  |    |     |   |     |      |               |
  |    |     V 3 |     |      |               |
  |    | +-------------+----+ |        +------+-----------+
  |    | |   Switched on    | |        |  Fault reaction  |
  |    | |                  | |        |     active       |
  |    | |  (Servo ready)   | |        | (Deceleration    |
  |    | +------------------+ |        |  processing)     |
  |    |     |   ^ 5          |        +------------------+
  |    |     |   |            |               ^
  |    |     v 4 |            |               | 13
+-------------------+   11 +---------------+  |
|     Operation     |-----&gt;|Quick stop     |  |
|     Enabled       |&lt;-----|active         |  |
|                   | 16   | (Deceleration |  |
|     (Servo on)    |      |  processing)  |  |
+-------------------+      +---------------+  |
                                              Error Occurs 
</code></pre>
<p>FSA Transition</p>
<table><thead><tr><th>No</th><th>FSA Transition</th></tr></thead><tbody>
<tr><td>0</td><td>Auto skip</td></tr>
<tr><td>1</td><td>Auto skip</td></tr>
<tr><td>2</td><td>[Shutdown]</td></tr>
<tr><td>3</td><td>[Switch On]</td></tr>
<tr><td>4</td><td>[Enable operation]</td></tr>
<tr><td>5</td><td>[Disable operation]</td></tr>
<tr><td>6</td><td>[Shutdown]</td></tr>
<tr><td>7</td><td>[Disable voltage]</td></tr>
<tr><td>8</td><td>[Shutdown]</td></tr>
<tr><td>9</td><td>[Disable voltage]</td></tr>
<tr><td>10</td><td>[Disable voltage]</td></tr>
<tr><td>11</td><td>[Quick stop]</td></tr>
<tr><td>12</td><td>[Disable voltage]</td></tr>
<tr><td>13</td><td>Error Occurs</td></tr>
<tr><td>14</td><td>Auto skip</td></tr>
<tr><td>15</td><td>[Fault reset]</td></tr>
<tr><td>16</td><td>[Enable operation]</td></tr>
</tbody></table>
<p><strong>Control Word (0x6040:0x0)</strong>：</p>
<pre><code>+-----------------------------------------------------------+
+-----------------------------------------------------------+
Bit 15                                                  Bit 0
</code></pre>
<ul>
<li>Bit 0: Switch On</li>
<li>Bit 1: Enable Voltage</li>
<li>Bit 2: Quick Stop</li>
<li>Bit 3: Enable Operation</li>
<li>Bit 4: Operation Mode Specification</li>
<li>Bit 5: Operation Mode Specification</li>
<li>Bit 6: Operation Mode Specification</li>
<li>Bit 7: Fault Reset</li>
<li>Bit 8: Halt</li>
<li>Bit 9: Operation Mode Specification</li>
<li>Bit 10: Reserved</li>
<li>Bit 11: Reserved</li>
<li>Bit 12: Reserved</li>
<li>Bit 13: Reserved</li>
<li>Bit 14: Reserved</li>
<li>Bit 15: Reserved</li>
</ul>
<p>Operation Mode Specification:</p>
<table><thead><tr><th>OP mode</th><th>Bit 9</th><th>Bit 6</th><th>Bit 5</th><th>Bit 4</th></tr></thead><tbody>
<tr><td>PP</td><td>change on set-point</td><td>absolute/relative</td><td>change set immediately</td><td>new set-point</td></tr>
<tr><td>PV</td><td>--</td><td>--</td><td>--</td><td></td></tr>
<tr><td>TQ</td><td>--</td><td>--</td><td>--</td><td></td></tr>
<tr><td>HM</td><td>--</td><td>--</td><td>start homing</td><td></td></tr>
<tr><td>CSP</td><td>--</td><td>--</td><td>--</td><td></td></tr>
<tr><td>CSV</td><td>--</td><td>--</td><td>--</td><td></td></tr>
<tr><td>CST</td><td>--</td><td>--</td><td>--</td><td></td></tr>
</tbody></table>
<table><thead><tr><th>Commnad</th><th>bit 7</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th><th>Transitions</th></tr></thead><tbody>
<tr><td>Shutdown</td><td>0</td><td>-</td><td>1</td><td>1</td><td>0</td><td>2,6,8</td></tr>
<tr><td>Switch on</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>3</td></tr>
<tr><td>Switch on + Enable operation</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3+4</td></tr>
<tr><td>Enable operation</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>4,16</td></tr>
<tr><td>Disable voltage</td><td>0</td><td>-</td><td>-</td><td>0</td><td>-</td><td>7,9,10,12</td></tr>
<tr><td>Quick stop</td><td>0</td><td>-</td><td>0</td><td>1</td><td>-</td><td>7,10,11</td></tr>
<tr><td>Disable operation</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>5</td></tr>
<tr><td>Fault Reset</td><td>0 -&gt; 1</td><td>-</td><td>-</td><td>-</td><td>-</td><td>15</td></tr>
</tbody></table>
<p><strong>Status Word (0x6041:0x0)</strong>：</p>
<pre><code>+-----------------------------------------------------------+
+-----------------------------------------------------------+
Bit 15                                                  Bit 0
</code></pre>
<ul>
<li>Bit 0: Ready to Switch On</li>
<li>Bit 1: Switched On</li>
<li>Bit 2: Operation Enabled</li>
<li>Bit 3: Fault</li>
<li>Bit 4: Voltage Enabled</li>
<li>Bit 5: Quick Stop</li>
<li>Bit 6: Switch On Disabled</li>
<li>Bit 7: Warning</li>
<li>Bit 8: Reserved</li>
<li>Bit 9: Remote</li>
<li>Bit 10: Operation Mode Specification</li>
<li>Bit 11: Internal Limit Active</li>
<li>Bit 12: Operation Mode Specification</li>
<li>Bit 13: Operation Mode Specification</li>
<li>Bit 14: Reserved</li>
<li>Bit 15: Reserved</li>
</ul>
<p>Operation Mode Specification:</p>
<table><thead><tr><th>OP mode</th><th>Bit 13</th><th>Bit 12</th><th>Bit 10</th></tr></thead><tbody>
<tr><td>PP</td><td>following error</td><td>set-point acknowledge</td><td>target reached</td></tr>
<tr><td>PV</td><td>--</td><td>speed</td><td>target reached</td></tr>
<tr><td>TQ</td><td>--</td><td>--</td><td>target reached</td></tr>
<tr><td>HM</td><td>homing error</td><td>homing attained</td><td>target reached</td></tr>
<tr><td>CSP</td><td>following error</td><td></td><td>--</td></tr>
<tr><td>CSV</td><td>--</td><td></td><td>--</td></tr>
<tr><td>CST</td><td>--</td><td></td><td>--</td></tr>
</tbody></table>
<p>FSA State:</p>
<table><thead><tr><th>FSA State</th><th>Bit 6</th><th>Bit 5</th><th>Bit 3</th><th>Bit 2</th><th>Bit 1</th><th>Bit 0</th></tr></thead><tbody>
<tr><td>Not Ready to Switch on</td><td>0</td><td>-</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>Switch on Disabled</td><td>1</td><td>-</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>Ready To Switch On</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>Switch on</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>Operation Enabled</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>Quick Stop Active</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>Faut Reaction Active</td><td>0</td><td>-</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>Fault</td><td>0</td><td>-</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
<hr />
<h4 id="drive-halt--ch-n----"><a class="header" href="#drive-halt--ch-n----"><code>+drive-halt ( ch n -- )</code></a></h4>
<p>命令 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器功能暫停。</p>
<p>此時馬達會依據 0x605D (Halt option code) 設定，暫時性的減速與停止。</p>
<h4 id="drive-homed--ch-n----"><a class="header" href="#drive-homed--ch-n----"><code>+drive-homed ( ch n -- )</code></a></h4>
<p>標記 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器已經完成回歸機械原點。</p>
<p>此狀態為主站所提供的狀態紀錄。</p>
<h4 id="pp-cosp--ch-n----"><a class="header" href="#pp-cosp--ch-n----"><code>+pp-cosp ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器處於 PP 模式時，設定 Control Word 的 Bit 9 （Change on set-point） 為 1。</p>
<p>當 Control Word Bit 9 為 1 （Change on set-point）與 Bit 5 （change set immediately） 為 0 時，同方向運動不減速到 0 通過中繼點。</p>
<p>細部功能請參考選用驅動器的 PP 模式描述。</p>
<h4 id="pp-imt--ch-n----"><a class="header" href="#pp-imt--ch-n----"><code>+pp-imt ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器處於 PP 模式時，設定 Control Word 的 Bit 5 （change set immediately）為 1。</p>
<p>當 Control Word 的 Bit 5 （change set immediately） 為 1 時，表示要馬達驅動器只朝向最後所接受的目標位置運動。</p>
<p>細部功能請參考選用驅動器的 PP 模式描述。</p>
<h4 id="pp-rel--ch-n----"><a class="header" href="#pp-rel--ch-n----"><code>+pp-rel ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器處於 PP 模式時，設定 Control Word 的 Bit 6 （absolute/relative）為 1。</p>
<p>細部功能請參考選用驅動器的 PP 模式描述。當 Control Word 的 Bit 6 （absolute/relative）為 1，馬達驅動器以相對位置來處理目標位置。</p>
<h4 id="-drive-halt--ch-n----"><a class="header" href="#-drive-halt--ch-n----"><code>-drive-halt ( ch n -- )</code></a></h4>
<p>命令 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器功能繼續。</p>
<p>參考命令 <code>+drive-halt</code></p>
<h4 id="-drive-homed--ch-n----"><a class="header" href="#-drive-homed--ch-n----"><code>-drive-homed ( ch n -- )</code></a></h4>
<p>標記 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器未完成回歸機械原點。</p>
<p>此狀態為主站所提供的狀態紀錄。</p>
<h4 id="-pp-cosp--ch-n----"><a class="header" href="#-pp-cosp--ch-n----"><code>-pp-cosp ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器處於 PP 模式時，設定 Control Word 的 Bit 9 （Change on set-point）為 0。</p>
<p>當 Control Word Bit 9 為 0 （Change on set-point）與 Bit 5 （change set immediately） 為 0 時，同方向運動減速到 0 通過中繼點。</p>
<p>細部功能請參考選用驅動器的 PP 模式描述。</p>
<h4 id="-pp-imt--ch-n----"><a class="header" href="#-pp-imt--ch-n----"><code>-pp-imt ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器處於 PP 模式時，設定 Control Word 的 Bit 5 （change set immediately）為 0。</p>
<p>當 Control Word 的 Bit 5 （change set immediately） 為 0 時，表示要通過每一個馬達驅動器所接受的目標位置。</p>
<p>細部功能請參考選用驅動器的 PP 模式描述。</p>
<h4 id="-pp-rel--ch-n----"><a class="header" href="#-pp-rel--ch-n----"><code>-pp-rel ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道的馬達驅動器處於 PP 模式時，設定 Control Word 的 Bit 6 （absolute/relative）為 0。</p>
<p>細部功能請參考選用驅動器的 PP 模式描述。當 Control Word 的 Bit 6 （absolute/relative）為 1，馬達驅動器以絕對位置來處理目標位置。</p>
<h4 id="drive-cw--cw-ch-n----"><a class="header" href="#drive-cw--cw-ch-n----"><code>drive-cw! ( cw ch n -- )</code></a></h4>
<p>直接設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 control word 為 <code>cw</code>。(由 PDO 設定)。</p>
<h4 id="demand-p--ch-n----pos-"><a class="header" href="#demand-p--ch-n----pos-"><code>demand-p@ ( ch n -- pos )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 demand position <code>pos</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將 demand position (object 0x6062) 映射到 PDO Mapping 上。</p>
<h4 id="demand-v--ch-n----vel-"><a class="header" href="#demand-v--ch-n----vel-"><code>demand-v@ ( ch n -- vel )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 demand velocity <code>vel</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將 demand velocity (object 0x606B) 映射到 PDO Mapping 上。</p>
<h4 id="drive-dins--ch-n----dins-"><a class="header" href="#drive-dins--ch-n----dins-"><code>drive-dins@ ( ch n -- dins )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的數位輸入狀態 <code>dins</code>。(由 PDO 取得資料)。</p>
<p>對應到 object 0x60FD。定義如下：</p>
<pre><code>+-----------------------------------------------------------+
+-----------------------------------------------------------+
Bit 31                                                  Bit 0
</code></pre>
<ul>
<li>Bit 0: Negative Limit</li>
<li>Bit 1: Positive Limit</li>
<li>Bit 2: Home Switch</li>
<li>Bit 3 ~ 31: 依馬達驅動器廠商定義。</li>
</ul>
<h4 id="drive-douts--douts-ch-n----"><a class="header" href="#drive-douts--douts-ch-n----"><code>drive-douts! ( douts ch n -- )</code></a></h4>
<p>使用 SDO 命令，設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的數位輸出為 <code>douts</code>。</p>
<p>對應到 object 0x60FE:0x01。定義如下：</p>
<pre><code>+-----------------------------------------------------------+
+-----------------------------------------------------------+
Bit 31                                                  Bit 0
</code></pre>
<ul>
<li>Bit 0: Brake。</li>
<li>Bit 1 ~ 31: 依馬達驅動器廠商定義。</li>
</ul>
<p>一般而言，驅動器的數位輸出是由馬達驅動器直接控制，如果需要由主站直接控制輸出，就要搭配 <code>drive-douts-mask!</code> 一起使用。</p>
<h4 id="drive-douts-mask--mask-ch-n----"><a class="header" href="#drive-douts-mask--mask-ch-n----"><code>drive-douts-mask! ( mask ch n -- )</code></a></h4>
<p>使用 SDO 命令，設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的數位輸出遮罩為 <code>mask</code>。</p>
<p>與 <code>drive-douts!</code> 一起使用。</p>
<h4 id="drive-fault--ch-n----flag-"><a class="header" href="#drive-fault--ch-n----flag-"><code>drive-fault? ( ch n -- flag )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 status word Bit 3 (fault) 的狀態 <code>flag</code>。</p>
<h4 id="drive-homed--ch-n----flag-"><a class="header" href="#drive-homed--ch-n----flag-"><code>drive-homed? ( ch n -- flag )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器是否已經回歸機械原點 <code>flag</code>。</p>
<h4 id="drive-nl--ch-n----nl-"><a class="header" href="#drive-nl--ch-n----nl-"><code>drive-nl? ( ch n -- nl )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的負向極限開關是否被觸發 <code>nl</code>。</p>
<p>其狀態來源與 <code>drive-dins@</code> 相同。</p>
<h4 id="drive-nsl--nsl-ch-n----"><a class="header" href="#drive-nsl--nsl-ch-n----"><code>drive-nsl! ( nsl ch n -- )</code></a></h4>
<p>使用 SDO 命令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的負向軟體極限為 <code>nsl</code>。</p>
<p>對應的 Object 0x607D:0x01。</p>
<h4 id="drive-nsl--ch-n----nsl-"><a class="header" href="#drive-nsl--ch-n----nsl-"><code>drive-nsl@ ( ch n -- nsl )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的負向軟體極限放到堆疊上。</p>
<p>此設定值會在開機時從馬達驅動器讀回到主站。在開機後設定負向軟體極限請使用 <code>drive-nsl!</code>，這樣 SDO 命令回應的記憶體位置才會正確。</p>
<h4 id="drive-off-ch-n----"><a class="header" href="#drive-off-ch-n----"><code>drive-off (ch n -- )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 FSA State 切換到 Switch On Disabled。</p>
<h4 id="drive-on-ch-n----"><a class="header" href="#drive-on-ch-n----"><code>drive-on (ch n -- )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 FSA State 切換到 Operation Enabled。</p>
<h4 id="drive-on--ch-n----flag-"><a class="header" href="#drive-on--ch-n----flag-"><code>drive-on? ( ch n -- flag )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 FSA State 是否在 Operation Enabled <code>flag</code>。</p>
<h4 id="drive-org--ch-n----org-"><a class="header" href="#drive-org--ch-n----org-"><code>drive-org? ( ch n -- org )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 home switch 是否被觸發 <code>org</code>。</p>
<p>其狀態來源與 <code>drive-dins@</code> 相同。</p>
<h4 id="drive-pl--ch-n----pl-"><a class="header" href="#drive-pl--ch-n----pl-"><code>drive-pl? ( ch n -- pl )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的正向極限開關是否被觸發 <code>nl</code>。</p>
<p>其狀態來源與 <code>drive-dins@</code> 相同。</p>
<h4 id="drive-psl--psl-ch-n----"><a class="header" href="#drive-psl--psl-ch-n----"><code>drive-psl! ( psl ch n -- )</code></a></h4>
<p>使用 SDO 命令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的正向軟體極限為 <code>psl</code>。</p>
<p>對應的 Object 0x607D:0x02。</p>
<h3 id="drive-psl--ch-n----psl-"><a class="header" href="#drive-psl--ch-n----psl-"><code>drive-psl@ ( ch n -- psl )</code></a></h3>
<p>將 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的正向軟體極限放到堆疊上。</p>
<p>此設定值會在開機時從馬達驅動器讀回到主站。在開機後設定正向軟體極限請使用 <code>drive-psl!</code>，這樣 SDO 命令回應的記憶體位置才會正確。</p>
<h4 id="drive-polarity--polarity-ch-n----"><a class="header" href="#drive-polarity--polarity-ch-n----"><code>drive-polarity! ( polarity ch n -- )</code></a></h4>
<p>使用 SDO 命令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的方向定義 <code>polarity</code>。</p>
<p>對應的 Object 0x607E。</p>
<h4 id="drive-rpdo1--ch-n----r1-"><a class="header" href="#drive-rpdo1--ch-n----r1-"><code>drive-rpdo1@ ( ch n -- r1 )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器使用者規劃的第一個 Rx PDO 資料 （slave -&gt; master）<code>r1</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將對應的 object 映射到 PDO Mapping 上。</p>
<h4 id="drive-rpdo2--ch-n----r2-"><a class="header" href="#drive-rpdo2--ch-n----r2-"><code>drive-rpdo2@ ( ch n -- r2 )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器使用者規劃的第二個 Rx PDO 資料 （slave -&gt; master）<code>r2</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將對應的 object 映射到 PDO Mapping 上。</p>
<h4 id="drive-stop--ch-n----"><a class="header" href="#drive-stop--ch-n----"><code>drive-stop ( ch n -- )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 FSA State 切換到 Quick stop actived。</p>
<h4 id="drive-sw--ch-n----sw-"><a class="header" href="#drive-sw--ch-n----sw-"><code>drive-sw@ ( ch n -- sw )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 Status Word <code>sw</code>。(由 PDO 取得資料)。</p>
<h4 id="drive-vmax--vmax-ch-n----"><a class="header" href="#drive-vmax--vmax-ch-n----"><code>drive-vmax! ( vmax ch n -- )</code></a></h4>
<p>使用 SDO 命令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的最高速度 <code>vmax</code>。</p>
<p>對應的 Object 0x6080:0x01。</p>
<h4 id="drive-wpdo1--w1-ch-n----"><a class="header" href="#drive-wpdo1--w1-ch-n----"><code>drive-wpdo1! ( w1 ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器使用者規劃的第一個 Tx PDO 資料 （master -&gt; slave）<code>w1</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將對應的 object 映射到 PDO Mapping 上。</p>
<h4 id="drive-wpdo1--ch-n----w1-"><a class="header" href="#drive-wpdo1--ch-n----w1-"><code>drive-wpdo1@ ( ch n -- w1 )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器使用者規劃的第一個 Tx PDO 資料 （master -&gt; slave）<code>w1</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將對應的 object 映射到 PDO Mapping 上。</p>
<h4 id="drive-wpdo2--w2-ch-n----"><a class="header" href="#drive-wpdo2--w2-ch-n----"><code>drive-wpdo2! ( w2 ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器使用者規劃的第二個 Tx PDO 資料 （master -&gt; slave）<code>w2</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將對應的 object 映射到 PDO Mapping 上。</p>
<h4 id="drive-wpdo2--ch-n----w2-"><a class="header" href="#drive-wpdo2--ch-n----w2-"><code>drive-wpdo2@ ( ch n -- w2 )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器使用者規劃的第二個 Tx PDO 資料 （master -&gt; slave）<code>w2</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將對應的 object 映射到 PDO Mapping 上。</p>
<h4 id="go--ch-n----"><a class="header" href="#go--ch-n----"><code>go ( ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器 Control Word 的 Bit 4 為 1。</p>
<p>該管道馬達驅動器在 PP 模式時為 new set-point，在 HM 模式時為 start homing。當主站接受到該管道的回應訊息時，會自動將 Control Word 的 Bit 4 設定為 0。</p>
<h4 id="homing-a--acceleration-ch-n----"><a class="header" href="#homing-a--acceleration-ch-n----"><code>homing-a! ( acceleration ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 homing acceleration <code>acceleration</code>。</p>
<p>對應的 Object 為 0x609A。要留意馬達驅動器的設定單位。</p>
<h4 id="homing-method--method-ch-n----"><a class="header" href="#homing-method--method-ch-n----"><code>homing-method! ( method ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 homing method <code>method</code>。</p>
<p>對應的 Object 為 0x6098。</p>
<h4 id="homing-v1--v1-ch-n----"><a class="header" href="#homing-v1--v1-ch-n----"><code>homing-v1! ( v1 ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 homing speed for switch <code>v1</code>。</p>
<p>對應的 Object 為 0x6099:0x01。要留意馬達驅動器的設定單位。</p>
<h4 id="homing-v2--v2-ch-n----"><a class="header" href="#homing-v2--v2-ch-n----"><code>homing-v2! ( v2 ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 homing speed for zero <code>v2</code>。</p>
<p>對應的 Object 為 0x6099:0x02。要留意馬達驅動器的設定單位。</p>
<h4 id="op-mode--mode-ch-n----"><a class="header" href="#op-mode--mode-ch-n----"><code>op-mode! ( mode ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的操作模式 <code>mode</code>。</p>
<p>對應的 Object 為 0x6060。</p>
<p>目前有支援的 mode 如下：</p>
<pre><code>1: PP
3: PV
4: TQ
6: HM
8: CSP
9: CSV
10: CST
</code></pre>
<p>也有已經定義好的模式代號命令：</p>
<pre><code>: pp ( -- mode ) 1 ;
: pv ( -- mode ) 3 ;
: tq ( -- mode ) 4 ;
: hm ( -- mode ) 6 ;
: csp ( -- mode ) 8 ;
: csv ( -- mode ) 9 ;
: cst ( -- mode ) 10 ;
</code></pre>
<p>命令範例:</p>
<pre><code>1  1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 PP 模式
pp 1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 PP 模式
3  1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 PV 模式
pv 1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 PV 模式
4  1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 TQ 模式
tq 1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 TQ 模式
6  1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 HM 模式
hm 1 1 op-mode!  \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 HM 模式
8   1 1 op-mode! \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 CSP 模式
csp 1 1 op-mode! \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 CSP 模式
9   1 1 op-mode! \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 CSV 模式
csv 1 1 op-mode! \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 CSV 模式
10  1 1 op-mode! \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 CST 模式
cst 1 1 op-mode! \ 將 EtherCAT 從站編號 1 第 1 管道馬達驅動器切換為 CST 模式
</code></pre>
<h4 id="pds-goal--goal-ch-n----"><a class="header" href="#pds-goal--goal-ch-n----"><code>pds-goal! ( goal ch n -- )</code></a></h4>
<p>切換 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 FSA State <code>goal</code>。主站會依據 FSA State 自動設定 Control Word。</p>
<p>可以切換的 FSA state of PDS 如下：</p>
<pre><code>: switch-on-disabled ( -- goal ) 1 ;
: ready-to-switch-on ( -- goal ) 2 ;
: switched-on        ( -- goal ) 3 ;
: operation-enabled  ( -- goal ) 4 ;
: quick-stop-active  ( -- goal ) 5 ;
</code></pre>
<p><code>drive-on</code>, <code>drive-on</code> 與 <code>drive-stop</code> 命令就是以 <code>pds-goal</code> 命令組合而成：</p>
<pre><code>: drive-on ( ch n -- )
    operation-enabled -rot pds-goal! ;

: drive-off ( ch n -- )
    switch-on-disabled -rot pds-goal! ;

: drive-stop ( ch n -- )
    quick-stop-active -rot pds-goal! ;
</code></pre>
<h4 id="profile-a1--a1-ch-n----"><a class="header" href="#profile-a1--a1-ch-n----"><code>profile-a1! ( a1 ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 profile acceleration <code>a1</code>。</p>
<p>對應的 Object 為 0x6083。在 PP 與 PV 模式時會使用到此加速度進行位置或是速度規劃，要留意馬達驅動器的設定單位。</p>
<h4 id="profile-a2--a2-ch-n----"><a class="header" href="#profile-a2--a2-ch-n----"><code>profile-a2! ( a2 ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 profile deceleration <code>a2</code>。</p>
<p>對應的 Object 為 0x6084。在 PP 與 PV 模式時會使用到此減速進行位置或是速度規劃，要留意馬達驅動器的設定單位。</p>
<h4 id="profile-v--vel-ch-n----"><a class="header" href="#profile-v--vel-ch-n----"><code>profile-v! ( vel ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 profile velocity <code>vel</code>。</p>
<p>對應的 Object 為 0x6081。在 PP 模式時會使用速度進行位置與速度規劃，要留意馬達驅動器的設定單位。</p>
<h4 id="real-p--ch-n----pos-"><a class="header" href="#real-p--ch-n----pos-"><code>real-p@ ( ch n -- pos )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的真實位置 <code>pos</code>。(由 PDO 取得資料)。</p>
<p>對應的 Object 為 0x6064。通常單位是脈波數。</p>
<h4 id="real-tq--ch-n----tq-"><a class="header" href="#real-tq--ch-n----tq-"><code>real-tq@ ( ch n -- tq )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的真實扭力輸出 <code>tq</code>。(由 PDO 取得資料)。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將 real torque (object 0x6077) 映射到 PDO Mapping 上。通常單位是 0.1 %。</p>
<h4 id="real-v--ch-n----vel-"><a class="header" href="#real-v--ch-n----vel-"><code>real-v@ ( ch n -- vel )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的真實速度 <code>vel</code>。(由 PDO 取得資料)。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將 real velocity (object 0x606C) 映射到 PDO Mapping 上。單位有可能是 pulse/s 或是 0.1 rpm。</p>
<h4 id="reset-fault--ch-n----"><a class="header" href="#reset-fault--ch-n----"><code>reset-fault ( ch n -- )</code></a></h4>
<p>當 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器處於 Fault of FAS State 時，將該管道馬達驅動器切換到 Switch on Disabled 的狀態。主站會自動設定對應的 Control Word。</p>
<h4 id="target-p--pos-ch-n----"><a class="header" href="#target-p--pos-ch-n----"><code>target-p! ( pos ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的目標位置 <code>pos</code>。(由 PDO 設定位置)。</p>
<p>對應的 Object 為 0x607A。通常單位是脈波數。</p>
<h4 id="target-p--ch-n----pos-"><a class="header" href="#target-p--ch-n----pos-"><code>target-p@ ( ch n -- pos )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的目標位置 <code>pos</code>。</p>
<h4 id="target-reached--ch-n----flag-"><a class="header" href="#target-reached--ch-n----flag-"><code>target-reached? ( ch n -- flag )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 Status Word Bit 10 (target reached) 是否為 1 。</p>
<p>其狀態來源與 <code>drive-sw@</code> 相同。</p>
<h4 id="target-v--vel-ch-n----"><a class="header" href="#target-v--vel-ch-n----"><code>target-v! ( vel ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的目標速度 <code>v</code>。</p>
<p>對應的 Object 為 0x60FF。單位有可能是 pulse/s 或是 0.1 rpm。</p>
<p>此命令只適合在 PV 模式下使用，如果是 CSV 模式要設定目標速度則是要使用 <code>drive-wpdo1!</code> 或是 <code>drive-wpdo2!</code>。</p>
<h4 id="tq-slope--slope-ch-n----"><a class="header" href="#tq-slope--slope-ch-n----"><code>tq-slope! ( slope ch n -- )</code></a></h4>
<p>使用 SDO 指令設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的扭力輸出變化率 <code>slope</code>。</p>
<p>對應的 Object 為 0x6087。通常單位是 0.1%/s。</p>
<p>在 TQ 模式下，使用此設定值進行扭力輸出規劃，通常會搭配 <code>drive-vmax!</code>一起使用，避免馬達扭力輸出未到達目標時，其運動速度過快。</p>
<h4 id="until-drive-on--ch-n----"><a class="header" href="#until-drive-on--ch-n----"><code>until-drive-on ( ch n -- )</code></a></h4>
<p>等待 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 FSA State 到達 Operation Enabled。</p>
<p>因此命令內含有 <code>pause</code>，所以只適合用於 Background Task。</p>
<p>此命令相當於:</p>
<pre><code>: until-drive-on ( ch n -- )
    begin
        over over drive-on? not
    while
        pause
    repeat
    drop drop ;
</code></pre>
<h4 id="until-no-fault--ch-n----"><a class="header" href="#until-no-fault--ch-n----"><code>until-no-fault ( ch n -- )</code></a></h4>
<p>等待 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 Status Word Bit 3 (Fault) 為 0。</p>
<p>因此命令內含有 <code>pause</code>，所以只適合用於 Background Task。</p>
<p>相當於 </p>
<pre><code>: until-no-fault ( channel slave -- )     
    pause pause pause pause pause pause \ 確保收到驅動器最新的 status word
    begin
        over over drive-fault?
    while
        pause
    repeat
    drop drop ; 
</code></pre>
<h4 id="until-target-reached--ch-n----"><a class="header" href="#until-target-reached--ch-n----"><code>until-target-reached ( ch n -- )</code></a></h4>
<p>等待 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 Status Word Bit 10 (target reached) 為 1。</p>
<p>因此命令內含有 <code>pause</code>，所以只適合用於 Background Task。</p>
<p>此命令相當於:</p>
<pre><code>: until-target-reached ( channel slave -- )
    pause pause pause pause pause pause \ 確保收到驅動器最新的 status word
    begin
        over over target-reached? not
    while
        pause
    repeat
    drop drop
;
</code></pre>
<h4 id="v-ofs--ofs-ch-n----"><a class="header" href="#v-ofs--ofs-ch-n----"><code>v-ofs! ( ofs ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 Velocity Offset <code>ofs</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將 Velocity Offset (object 0x60B1) 映射到 PDO Mapping 上。</p>
<p>此一命令通常用於 CSP 或是 CSV 模式下，可以在馬達驅動器內的速度控制迴路額外調整速度目標值。單位通常是 pulse/s 或是 0.1 rpm。</p>
<h4 id="v-ofs---ch-n----ofs-"><a class="header" href="#v-ofs---ch-n----ofs-"><code>v-ofs@  ( ch n -- ofs )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code> 第 <code>ch</code> 管道馬達驅動器的 Velocity Offset <code>ofs</code>。</p>
<p>需要設定主站參數檔，而且該管道的馬達驅動器可以將 Velocity Offset (object 0x60B1) 映射到 PDO Mapping 上。</p>
<h4 id="pp-test-範例"><a class="header" href="#pp-test-範例">PP-TEST 範例</a></h4>
<p>使用 EtherCAT 從站編號 1 第 1 管道的馬達驅動器。</p>
<pre><code>: pp-test
    pp 1 1 op-mode!          \ 切換到 PP Mode
    until-no-requests        \ 等待 op-mode! 命令實際設定到驅動器
    1 1 reset-fault          \ 解除驅動器異警
    1 1 until-no-fault       \ 等待解除驅動器異警完成
    1 1 drive-on             \ Drive On
    1 1 until-drive-on       \ 等待 Drive on 程序完成
    1000 1 1 target-p!       \ Set target position to 1000
    1 1 go                   \ New set-point
    1 1 until-target-reached \ 等待到達目標點
;

deploy pp-test ;deploy       \ 在 Background Task 執行 pp-test
</code></pre>
<h4 id="本節指令集-4"><a class="header" href="#本節指令集-4">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td>+drive-halt</td><td>( ch n -- )</td></tr>
<tr><td>+drive-homed</td><td>( ch n -- )</td></tr>
<tr><td>+pp-cosp</td><td>( ch n -- )</td></tr>
<tr><td>+pp-imt</td><td>( ch n -- )</td></tr>
<tr><td>+pp-rel</td><td>( ch n -- )</td></tr>
<tr><td>-drive-halt</td><td>( ch n -- )</td></tr>
<tr><td>-drive-homed</td><td>( ch n -- )</td></tr>
<tr><td>-pp-cosp</td><td>( ch n -- )</td></tr>
<tr><td>-pp-imt</td><td>( ch n -- )</td></tr>
<tr><td>-pp-rel</td><td>( ch n -- )</td></tr>
<tr><td>csp</td><td>( -- 8 )</td></tr>
<tr><td>cst</td><td>( -- 10 )</td></tr>
<tr><td>csv</td><td>( -- 9 )</td></tr>
<tr><td>drive-cw!</td><td>( cw ch n -- )</td></tr>
<tr><td>demand-p@</td><td>( ch n -- pos )</td></tr>
<tr><td>demand-v@</td><td>( ch n -- vel )</td></tr>
<tr><td>drive-dins@</td><td>( ch n -- dins )</td></tr>
<tr><td>drive-douts!</td><td>( douts ch n -- )</td></tr>
<tr><td>drive-douts-mask!</td><td>( mask ch n -- )</td></tr>
<tr><td>drive-fault?</td><td>( ch n -- flag )</td></tr>
<tr><td>drive-homed?</td><td>( ch n -- flag )</td></tr>
<tr><td>drive-nl?</td><td>( ch n -- nl )</td></tr>
<tr><td>drive-nsl!</td><td>( nsl ch n -- )</td></tr>
<tr><td>drive-nsl@</td><td>( ch n -- nsl )</td></tr>
<tr><td>drive-off</td><td>( ch n -- )</td></tr>
<tr><td>drive-on</td><td>( ch n -- )</td></tr>
<tr><td>drive-on?</td><td>( ch n -- flag )</td></tr>
<tr><td>drive-org?</td><td>( ch n -- org )</td></tr>
<tr><td>drive-pl?</td><td>( ch n -- pl )</td></tr>
<tr><td>drive-psl!</td><td>( psl ch n -- )</td></tr>
<tr><td>drive-psl@</td><td>( ch n -- psl )</td></tr>
<tr><td>drive-polarity!</td><td>( polarity ch n -- )</td></tr>
<tr><td>drive-rpdo1@</td><td>( ch n -- r1 )</td></tr>
<tr><td>drive-rpdo2@</td><td>( ch n -- r2 )</td></tr>
<tr><td>drive-stop</td><td>( ch n -- )</td></tr>
<tr><td>drive-sw@</td><td>( ch n -- sw )</td></tr>
<tr><td>drive-vmax!</td><td>( vmax ch n -- )</td></tr>
<tr><td>drive-wpdo1!</td><td>( w1 ch n -- )</td></tr>
<tr><td>drive-wpdo1@</td><td>( ch n -- w1 )</td></tr>
<tr><td>drive-wpdo2!</td><td>( w2 ch n -- )</td></tr>
<tr><td>drive-wpdo2@</td><td>( ch n -- w2 )</td></tr>
<tr><td>go</td><td>( ch n -- )</td></tr>
<tr><td>hm</td><td>( -- 6 )</td></tr>
<tr><td>homing-a!</td><td>( acc ch n -- )</td></tr>
<tr><td>homing-method!</td><td>( method ch n -- )</td></tr>
<tr><td>homing-v1!</td><td>( v1 ch n -- )</td></tr>
<tr><td>homing-v2!</td><td>( v2 ch n -- )</td></tr>
<tr><td>op-mode!</td><td>( mode ch n -- )</td></tr>
<tr><td>pds-goal!</td><td>( goal ch n -- )</td></tr>
<tr><td>pp</td><td>( -- 1 )</td></tr>
<tr><td>profile-a1!</td><td>( a1 ch n -- )</td></tr>
<tr><td>profile-a2!</td><td>( a2 ch n -- )</td></tr>
<tr><td>profile-v!</td><td>( vel ch n -- )</td></tr>
<tr><td>pv</td><td>( -- 3 )</td></tr>
<tr><td>real-p@</td><td>( ch n -- pos )</td></tr>
<tr><td>real-tq@</td><td>( ch n -- tq )</td></tr>
<tr><td>real-v@</td><td>( ch n -- vel )</td></tr>
<tr><td>reset-fault</td><td>( ch n -- )</td></tr>
<tr><td>target-p!</td><td>( pos ch n -- )</td></tr>
<tr><td>target-p@</td><td>( ch n -- pos )</td></tr>
<tr><td>target-reached?</td><td>( channel n -- flag )</td></tr>
<tr><td>target-v!</td><td>( vel ch n -- )</td></tr>
<tr><td>tq</td><td>( -- 4 )</td></tr>
<tr><td>tq-slope!</td><td>( slope ch n -- )</td></tr>
<tr><td>until-drive-on</td><td>( ch n -- )</td></tr>
<tr><td>until-no-fault</td><td>( ch n -- )</td></tr>
<tr><td>until-target-reached</td><td>( ch n -- )</td></tr>
<tr><td>v-ofs!</td><td>( ofs ch n -- )</td></tr>
<tr><td>v-ofs@</td><td>( ch n -- ofs )</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethercat-io-指令集"><a class="header" href="#ethercat-io-指令集">EtherCAT IO 指令集</a></h3>
<p>EtherCAT IO 包含以下部份：</p>
<ol>
<li>EtherCAT DIN/DOUT/AIN/AOUT 模組。單一種或是綜合的訊號模組。</li>
<li>EtherCAT PWM 模組。目前只有支援 BECKHOFF EL2502 模組。因為該模組可以使用同步命令（PDO）控制 PWM Period 與 Duty Cycle。如果是非同步命令 （SDO）的控制方式，使用 SDO upload/download 命令即可。</li>
</ol>
<hr />
<h4 id="ec-ain--ch-n----"><a class="header" href="#ec-ain--ch-n----"><code>+ec-ain ( ch n -- )</code></a></h4>
<p>開啟 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸入。</p>
<p>如選用的類比輸入從站，需要開啟類比輸入管道才能讀到量測值，就可以使用此以指令。</p>
<p>命令範例:</p>
<pre><code>1 6 +ec-ain  \ 開啟 EtherCAT 從站編號 6，第 1 管道的類比輸入。
</code></pre>
<h4 id="ec-aout--ch-n----"><a class="header" href="#ec-aout--ch-n----"><code>+ec-aout ( ch n -- )</code></a></h4>
<p>開啟 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸出。</p>
<p>如選用的類比輸出從站，需要開啟類比輸出管道才能輸出訊號，就可以使用此以指令。</p>
<p>命令範例:</p>
<pre><code>1 2 +ec-aout  \ 開啟 EtherCAT 從站編號 2，第 1 管道的類比輸出。
</code></pre>
<h4 id="pwm-user-scale--ch-n----"><a class="header" href="#pwm-user-scale--ch-n----"><code>+pwm-user-scale ( ch n -- )</code></a></h4>
<p>開啟 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的 PWM 自定義 Duty Cycle 命令功能。</p>
<h4 id="-ec-ain--ch-n----"><a class="header" href="#-ec-ain--ch-n----"><code>-ec-ain ( ch n -- )</code></a></h4>
<p>關閉 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸入。</p>
<p>命令範例:</p>
<pre><code>1 6 -ec-ain  \ 關閉 EtherCAT 從站編號 6，第 1 管道的類比輸入。
</code></pre>
<h4 id="-ec-aout--ch-n----"><a class="header" href="#-ec-aout--ch-n----"><code>-ec-aout ( ch n -- )</code></a></h4>
<p>關閉 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸出。</p>
<p>命令範例:</p>
<pre><code>1 2 -ec-aout  \ 關閉 EtherCAT 從站編號 2，第 1 管道的類比輸出。
</code></pre>
<h4 id="-pwm-user-scale--ch-n----"><a class="header" href="#-pwm-user-scale--ch-n----"><code>-pwm-user-scale ( ch n -- )</code></a></h4>
<p>關閉 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的 PWM 自定義 Duty Cycle 命令功能。</p>
<h4 id="ec-ain--ch-n----value-"><a class="header" href="#ec-ain--ch-n----value-"><code>ec-ain@ ( ch n -- value )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸入。</p>
<p>命令範例:</p>
<pre><code>1 6 ec-ain@  \ 取得 EtherCAT 從站編號 6，第 1 管道的類比輸入
</code></pre>
<h4 id="ec-ain-error---ch-n----error-"><a class="header" href="#ec-ain-error---ch-n----error-"><code>ec-ain-error  ( ch n -- error )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸入是否有錯誤。</p>
<p>BECKHOFF AI 模組有提供此一狀態，其錯誤的狀況有以下兩種：</p>
<ul>
<li>Over range</li>
<li>Under range</li>
</ul>
<h4 id="ec-ain-validity---ch-n----validity-"><a class="header" href="#ec-ain-validity---ch-n----validity-"><code>ec-ain-validity  ( ch n -- validity )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸入是否有效。</p>
<p>BECKHOFF AI 模組有提供此一狀態，表示該管道資料有正確地被主站使用 EtherCAT PDO 讀取。
原始資料 <code>0 = valid, 1 = invalid</code>，為避免字義上混淆，主站在取得資料時就進行反向的操作。</p>
<h4 id="ec-aout--value-ch-n----"><a class="header" href="#ec-aout--value-ch-n----"><code>ec-aout! ( value ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸出為 <code>value</code>。</p>
<p>命令範例:</p>
<pre><code>100 1 2 ec-aout!  \ 設定 EtherCAT 從站編號 2，第 1 管道的類比輸出為 100
</code></pre>
<h4 id="ec-aout--ch-n----value-"><a class="header" href="#ec-aout--ch-n----value-"><code>ec-aout@ ( ch n -- value )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的類比輸出 <code>value</code>。</p>
<pre><code>1 2 ec-aout@  \ 取得 EtherCAT 從站編號 2，第 1 管道的類比輸出
</code></pre>
<h4 id="ec-din--ch-n----t--1"><a class="header" href="#ec-din--ch-n----t--1"><code>ec-din@ ( ch n -- t )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的數位輸入訊號 <code>t</code>。</p>
<p>命令範例:</p>
<pre><code>3 5 ec-din@  \ 取得 EtherCAT 從站編號 5 的第 3 管道的數位輸入訊號
</code></pre>
<h4 id="ec-dout--t-channel-n----"><a class="header" href="#ec-dout--t-channel-n----"><code>ec-dout! ( t channel n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的數位輸出訊號為 <code>t</code>。</p>
<p>命令範例:</p>
<pre><code>1 2 3 ec-dout!  \ 設定 EtherCAT 從站編號 3，第 2 管道的數位輸出訊號為 1
</code></pre>
<h4 id="ec-dout--ch-n----t--1"><a class="header" href="#ec-dout--ch-n----t--1"><code>ec-dout@ ( ch n -- t )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的數位輸出訊號 <code>t</code>。</p>
<p>命令範例:</p>
<pre><code>2 3 ec-dout@  \ 取得 EtherCAT 從站編號 3 的第 2 管道的數位輸出訊號
</code></pre>
<h4 id="ec-wdout---value-index-n----"><a class="header" href="#ec-wdout---value-index-n----"><code>ec-wdout!  ( value index n -- )</code></a></h4>
<p>以 32 bits 命令資料 <code>value</code> 與編號 <code>index</code> 設定 EtherCAT 從站編號 <code>n</code> 的數位輸出訊號。</p>
<p>命令範例:</p>
<pre><code>$11 1 2 ec-wdout!  \ 設定 EtherCAT 從站編號 2，第 1 與 5 管道的數位輸出。
1   2 2 ec-wdout!  \ 設定 EtherCAT 從站編號 2，第 33 管道的數位輸出。
</code></pre>
<h4 id="max-pwm-period---n----period-"><a class="header" href="#max-pwm-period---n----period-"><code>max-pwm-period@  ( n -- period )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>， PWM 模組支援的最大周期時間 <code>period</code> [us]。</p>
<h4 id="min-pwm-period---n----period-"><a class="header" href="#min-pwm-period---n----period-"><code>min-pwm-period@  ( n -- period )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>， PWM 模組支援的最小周期時間 <code>period</code> [us]。</p>
<h4 id="pwm-def-out---output-ch-n----"><a class="header" href="#pwm-def-out---output-ch-n----"><code>pwm-def-out!  ( output ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號， 在通訊錯誤時的 Duty Cycle 預設值 <code>output</code>。</p>
<h4 id="pwm-def-out-ramp---ramp-ch-n----"><a class="header" href="#pwm-def-out-ramp---ramp-ch-n----"><code>pwm-def-out-ramp!  ( ramp ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號， 在通訊錯誤時的 Duty Cycle 斜降率 <code>ramp</code>。</p>
<h3 id="pwm-duty---duty-ch-n----period-"><a class="header" href="#pwm-duty---duty-ch-n----period-"><code>pwm-duty!  ( duty ch n -- period )</code></a></h3>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號的 Duty Cycle <code>duty</code>。 Duty Cycle 物理值可以參考 <code>pwm-presentation!</code>指令。</p>
<h4 id="pwm-duty---ch-n----duty-"><a class="header" href="#pwm-duty---ch-n----duty-"><code>pwm-duty@  ( ch n -- duty )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號的 Duty Cycle <code>duty</code>。</p>
<h4 id="pwm-period---period-ch-n----period-"><a class="header" href="#pwm-period---period-ch-n----period-"><code>pwm-period!  ( period ch n -- period )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號 Period <code>period</code> [us]。</p>
<h4 id="pwm-period---ch-n----period-"><a class="header" href="#pwm-period---ch-n----period-"><code>pwm-period@  ( ch n -- period )</code></a></h4>
<p>取得 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號 Period <code>period</code> [us]。。</p>
<h4 id="pwm-presentation---presentation-ch-n----"><a class="header" href="#pwm-presentation---presentation-ch-n----"><code>pwm-presentation!  ( presentation ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號 Duty Cycle 解析度 <code>presentation</code>。</p>
<p>BECKHOFF EL2502 可以設定的模式有：</p>
<table><thead><tr><th>Presentation</th><th>Duty 設定說明</th></tr></thead><tbody>
<tr><td>0 (Signed presentation)</td><td>有效值 0 ~ 0x7FFF， 0x3FFF 表示 50 % Duty</td></tr>
<tr><td>1 (Unsigned presentation)</td><td>有效值 0 ~ 0xFFFF，0x7FFF 表示 50% Duty</td></tr>
<tr><td>2 (Absolute value with MSB as sign)</td><td>3276 表示 10 % duty, -3276 表示 90 % duty</td></tr>
<tr><td>3 (Absolute valuen)</td><td>3276 表示 10 % duty, -3276 也表示 10 % duty</td></tr>
</tbody></table>
<h4 id="pwm-wdt---wdt-ch-n----"><a class="header" href="#pwm-wdt---wdt-ch-n----"><code>pwm-wdt!  ( wdt ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號，當通訊錯誤時，訊號輸出模式 <code>wdt</code>。</p>
<p>BECKHOFF EL2502 可以設定的模式有：</p>
<ul>
<li>0: Default watchdog value</li>
<li>1: Watchdog ramp active</li>
<li>2: Last output value active</li>
</ul>
<h4 id="pwm-user-gain---gain-ch-n----"><a class="header" href="#pwm-user-gain---gain-ch-n----"><code>pwm-user-gain!  ( gain ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號自定義 Duty Cycle 命令增益 <code>gain</code>。</p>
<p>參考 BECKHOFF EL2502 文件中針對 Object 0x8000:0x01 的說明。</p>
<h4 id="pwm-user-offset---offset-ch-n----"><a class="header" href="#pwm-user-offset---offset-ch-n----"><code>pwm-user-offset!  ( offset ch n -- )</code></a></h4>
<p>設定 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道 PWM 訊號自定義 Duty Cycle 命令偏移量 <code>offset</code>。</p>
<h4 id="本節指令集-5"><a class="header" href="#本節指令集-5">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>+ec-ain</td><td>( ch n -- )</td><td>啟動 AIN 功能</td></tr>
<tr><td>+ec-aout</td><td>( ch n -- )</td><td>啟動 AOUT 功能</td></tr>
<tr><td>+pwm-user-scale</td><td>( ch n -- )</td><td>啟動 PWM 自定義 Duty Cycle 命令功能</td></tr>
<tr><td>-ec-ain</td><td>( ch n -- )</td><td>關閉 AIN 功能</td></tr>
<tr><td>-ec-aout</td><td>( ch n -- )</td><td>關閉 AOUT 功能</td></tr>
<tr><td>-pwm-user-scale</td><td>( ch n -- )</td><td>關閉 PWM 自定義 Duty Cycle 命令功能</td></tr>
<tr><td>ec-ain@</td><td>( ch n -- value )</td><td>取得 AIN 量測值</td></tr>
<tr><td>ec-ain-error</td><td>( ch n -- error )</td><td>取得 AIN 量測值是否有錯誤</td></tr>
<tr><td>ec-ain-validity</td><td>( ch n -- validity )</td><td>取得 AIN 量測值是否有效</td></tr>
<tr><td>ec-aout!</td><td>( value ch n -- )</td><td>設定 AOUT</td></tr>
<tr><td>ec-aout@</td><td>( ch n -- value )</td><td>取得 AOUT</td></tr>
<tr><td>ec-din@</td><td>( ch n -- t )</td><td>取得 DIN</td></tr>
<tr><td>ec-dout!</td><td>( t ch n -- )</td><td>設定 DOUT</td></tr>
<tr><td>ec-dout@</td><td>( ch n -- t )</td><td>取得 DOUT</td></tr>
<tr><td>ec-wdout!</td><td>( value index n -- )</td><td>設定 DOUTs</td></tr>
<tr><td>max-pwm-period@</td><td>( n -- period )</td><td>取得 PWM 模組支援的最大周期時間</td></tr>
<tr><td>min-pwm-period@</td><td>( n -- period )</td><td>取得 PWM 模組支援的最小周期時間</td></tr>
<tr><td>pwm-def-out!</td><td>( output ch n -- )</td><td>當通訊錯誤時，PWM Duty Cycle 的預設值</td></tr>
<tr><td>pwm-def-out-ramp!</td><td>( ramp ch n -- )</td><td>當通訊錯誤時，PWM Duty Cycle 的斜降率</td></tr>
<tr><td>pwm-duty!</td><td>( duty ch n -- )</td><td>設定 PWM Duty Cycle</td></tr>
<tr><td>pwm-duty@</td><td>( ch n -- duty )</td><td>取得 PWM Duty Cycle</td></tr>
<tr><td>pwm-period!</td><td>( period ch n -- )</td><td>設定 PWM Period</td></tr>
<tr><td>pwm-period@</td><td>( ch n -- period )</td><td>取得 PWM Period</td></tr>
<tr><td>pwm-presentation!</td><td>( presentation ch n -- )</td><td>設定 PWM Duty Cycle 解析度</td></tr>
<tr><td>pwm-wdt!</td><td>( wdt ch n -- )</td><td>當通訊錯誤時，PWM 輸出模式</td></tr>
<tr><td>pwm-user-gain!</td><td>( gain ch n - )</td><td>PWM 自定義 Duty Cycle 命令增益</td></tr>
<tr><td>pwm-user-offset!</td><td>( offset ch n -- )</td><td>PWM 自定義 Duty Cycle 命令偏移量</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethercat-uart-primitives"><a class="header" href="#ethercat-uart-primitives">EtherCAT UART primitives</a></h3>
<h4 id="本節指令集-6"><a class="header" href="#本節指令集-6">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>+uart-p2p</code></td><td>( channel n -- )</td></tr>
<tr><td><code>-uart-p2p</code></td><td>( channel n -- )</td></tr>
<tr><td><code>+uart-hdt</code></td><td>( channel n -- )</td></tr>
<tr><td><code>-uart-hdt</code></td><td>( channel n -- )</td></tr>
<tr><td><code>+uart-tx-opt</code></td><td>( channel n -- )</td></tr>
<tr><td><code>-uart-tx-opt</code></td><td>( channel n -- )</td></tr>
<tr><td><code>uart-baud!</code></td><td>( baud channel n -- )</td></tr>
<tr><td><code>uart-frame!</code></td><td>( frame channel n -- )</td></tr>
<tr><td><code>uart-ready?</code></td><td>( channel n -- flag )</td></tr>
<tr><td><code>uart-error?</code></td><td>( channel n -- flag )</td></tr>
<tr><td><code>uart-error@</code></td><td>( channel n -- error )</td></tr>
<tr><td><code>0uart</code></td><td>( channel n -- )</td></tr>
<tr><td><code>uart-rx-len@</code></td><td>( channel n -- len )</td></tr>
<tr><td><code>uart-tx-space@</code></td><td>( channel n -- space )</td></tr>
<tr><td><code>uart-data!</code></td><td>( d1 d2 .. len channel n -- )</td></tr>
<tr><td><code>uart-data@</code></td><td>( len channel n -- d1 d2 .. )</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethercat-encoder-primitives"><a class="header" href="#ethercat-encoder-primitives">EtherCAT Encoder primitives</a></h3>
<h4 id="本節指令集-7"><a class="header" href="#本節指令集-7">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>ec-enc-validity</code></td><td>( channel n -- validity )</td></tr>
<tr><td><code>ec-enc-warning</code></td><td>( channel n -- warning )</td></tr>
<tr><td><code>ec-enc-err</code></td><td>( channel n -- err )</td></tr>
<tr><td><code>ec-enc-ready</code></td><td>( channel n -- ready )</td></tr>
<tr><td><code>ec-enc-pos</code></td><td>( channel n -- position )</td></tr>
<tr><td><code>+ec-enc-reversed</code></td><td>( channel n -- )</td></tr>
<tr><td><code>-ec-enc-reversed</code></td><td>( channel n -- )</td></tr>
<tr><td><code>ec-enc-ofs!</code></td><td>( ofs channel n -- )</td></tr>
<tr><td><code>ec-enc-ofs@</code></td><td>( channel n -- ofs )</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethercat-gateway-指令集"><a class="header" href="#ethercat-gateway-指令集">EtherCAT Gateway 指令集</a></h3>
<p>閘道器 Gateway 的資料操作是以 Byte 為單位。以類似記憶體存取的方式進行讀取/寫入。</p>
<p>目前支援的硬體是： Anybus X-Gateway</p>
<p><strong>注意事項：</strong></p>
<ol>
<li>讀取/寫入資料長度限制 1 ~ 4 byte</li>
<li>起始位置必須從 0 開始</li>
</ol>
<hr />
<h4 id="0gateway--ch-n----"><a class="header" href="#0gateway--ch-n----"><code>0gateway ( ch n -- )</code></a></h4>
<p>重置 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器。</p>
<h4 id="gateway-in-be--len-start-ch-n----data-"><a class="header" href="#gateway-in-be--len-start-ch-n----data-"><code>gateway-in-be@ ( len start ch n -- data )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸入資料，由起始位置 <code>start</code>，資料長度 <code>len</code> bytes，
以 Big-Endian 的位元組順序讀出，放到整數堆疊上 <code>data</code>。</p>
<h4 id="gateway-in-le--len-start-ch-n----data-"><a class="header" href="#gateway-in-le--len-start-ch-n----data-"><code>gateway-in-le@ ( len start ch n -- data )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸入資料，由起始位置 <code>start</code>，資料長度 <code>len</code> bytes，
以 Little-Endian 的位元組順序讀出，放到整數堆疊上 <code>data</code>。</p>
<h4 id="gateway-in-len--ch-n----len-"><a class="header" href="#gateway-in-len--ch-n----len-"><code>gateway-in-len@ ( ch n -- len )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸入暫存器大小 <code>len</code> bytes 放到整數堆疊上。</p>
<h4 id="gateway-out-be--cmd-len-start-ch-n----"><a class="header" href="#gateway-out-be--cmd-len-start-ch-n----"><code>gateway-out-be! ( cmd len start ch n -- )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸出資料，起始位置 <code>start</code>，資料長度 <code>len</code> bytes，
以 Big-Endian 的位元組順序寫入 <code>cmd</code>。</p>
<h4 id="gateway-out-be--len-start-ch-n----data-"><a class="header" href="#gateway-out-be--len-start-ch-n----data-"><code>gateway-out-be@ ( len start ch n -- data )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸出資料，由起始位置 <code>start</code>，資料長度 <code>len</code> bytes，
以 Big-Endian 的位元組順序讀出，放到整數堆疊上 <code>data</code>。</p>
<h4 id="gateway-out-le--cmd-len-start-ch-n----"><a class="header" href="#gateway-out-le--cmd-len-start-ch-n----"><code>gateway-out-le! ( cmd len start ch n -- )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸出資料，起始位置 <code>start</code>，資料長度 <code>len</code> bytes，
以 Little-Endian 的位元組順序寫入 <code>cmd</code>。</p>
<h4 id="gateway-out-le--len-start-ch-n----data-"><a class="header" href="#gateway-out-le--len-start-ch-n----data-"><code>gateway-out-le@ ( len start ch n -- data )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸出資料，由起始位置 <code>start</code>，資料長度 <code>len</code> bytes，
以 Little-Endian 的位元組順序讀出，放到整數堆疊上 <code>data</code>。</p>
<h4 id="gateway-out-len--ch-n----len-"><a class="header" href="#gateway-out-len--ch-n----len-"><code>gateway-out-len@ ( ch n -- len )</code></a></h4>
<p>將 EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器的輸出暫存器大小 <code>len</code> bytes 放到整數堆疊上。</p>
<h4 id="gateway-ready--ch-n----t-"><a class="header" href="#gateway-ready--ch-n----t-"><code>gateway-ready? ( ch n -- t )</code></a></h4>
<p>EtherCAT 從站編號 <code>n</code>，第 <code>ch</code> 管道的閘道器是否備妥 ？</p>
<h4 id="本節指令集-8"><a class="header" href="#本節指令集-8">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td><code>0gateway</code></td><td>( ch n -- )</td></tr>
<tr><td><code>gateway-in-be@</code></td><td>( len start ch n -- data )</td></tr>
<tr><td><code>gateway-in-le@</code></td><td>( len start ch n -- data )</td></tr>
<tr><td><code>gateway-in-len@</code></td><td>( ch n -- len )</td></tr>
<tr><td><code>gateway-out-be!</code></td><td>( data len start ch n -- )</td></tr>
<tr><td><code>gateway-out-be@</code></td><td>( len start ch n -- data )</td></tr>
<tr><td><code>gateway-out-le!</code></td><td>( data len start ch n -- )</td></tr>
<tr><td><code>gateway-out-le@</code></td><td>( len start ch n -- data )</td></tr>
<tr><td><code>gateway-out-len@</code></td><td>( ch n -- len )</td></tr>
<tr><td><code>gateway-ready?</code></td><td>( ch n -- t )</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="job-operation"><a class="header" href="#job-operation">Job Operation</a></h3>
<p>針對軸組運動使用。Job 指的是所有軸組合作完成的工作。</p>
<p><strong>座標系解釋</strong></p>
<ul>
<li>ACS ：Axes Coordinate System (運動軸座標系)</li>
<li>MCS ：Machine Coordinate System (機械座標系或是大地座標系)</li>
<li>PCS ：Product Coordinate System/Program Coordinate System (工件座標系)</li>
</ul>
<p><strong>軸組概念說明</strong></p>
<pre><code>
        +--------------+
        |  Coordinator |
        |              |
        +-------+------+
                |
    +-------------------------+
    |           |             |
+---+---+    +--+----+    +---+---+
| Group |    | Group |    | Group |
| (1D)  |    |  (2D) |    |  (3D) |
+---+---+    +--+----+    +--+----+
    |           |            |
    |           +----------+ +----------+------------+
    |           |          | |          |            |
+---+---+   +---+---+   +--+-+--+   +---+---+   +----+--+
|  Axis |   |  Axis |   |  Axis |   |  Axis |   |  Axis |
|       |   |       |   |       |   |       |   |       |
+---+---+   +---+---+   +---+---+   +---+---+   +-------+
    |           |           |           |
    |           |           |           |
    |           |           |           |
+---+---+   +---+---+   +---+---+   +---+---+
| Drive |   | Drive |   | Drive |   | Drive |
|       |   |       |   |       |   |       |
+-------+   +-------+   +-------+   +-------+

</code></pre>
<p><strong>Coordinator (同動控制功能)</strong>:</p>
<p>多軸同動控制。EtherCAT 通訊具有時間同步的特性，所以適合用來實現多軸同動的功能。</p>
<p>此多軸同動控制所選用的 EtherCAT 馬達驅動裝置必須支援周期時間同步位置模式 （Cyclic Synchronous Position Mode），一般而言 EtherCAT 馬達驅動裝置都有支援。</p>
<p><strong>Group （軸組）</strong>:</p>
<p>軸組運動功能如下：</p>
<ol>
<li>S 型加減速曲線。</li>
<li>直線與圓弧路徑規劃。</li>
<li>路徑運動速度限制。</li>
<li>路徑預視。</li>
<li>可以多個軸組同時運行（受限於運動軸是否被其他運動功能控制）。</li>
</ol>
<p>目前有提供以下幾種類型：</p>
<ol>
<li>單軸 （1D）。</li>
<li>2軸正交 (2D)。</li>
<li>3 軸正交 (3D)。</li>
<li>單軸弦波運動 （Sine wave）。</li>
</ol>
<p><strong>Axis（運動軸）</strong>:</p>
<p>受控於軸組，運行點對點的運動或是進行追隨運動。如果沒有對應的驅動裝置即為虛擬軸。當運動軸為虛擬軸時，其實際位置是由命令位置推算所得。</p>
<p>執行點對點運動時的注意事項：</p>
<ol>
<li>S 型加減速曲線。</li>
<li>運動速度只能在靜止改變。加速曲線會依據運動軸的最大加速度與最大速度進行規劃。</li>
<li>運動中可以隨時改變目標位置。</li>
</ol>
<p><strong>Drive（驅動裝置）</strong>：</p>
<p>實際的馬達驅動裝置。可以是不同廠牌/型態的馬達驅動器。</p>
<p><strong>運動單位</strong></p>
<p>Botnana Control 的長度單位默認為公尺 [m]，時間單位為秒 [s]。
所以速度單位為 <code>m/s</code>, 加速度單位<code>m/s^2</code>，加加速度單位<code>m/s^3</code>。</p>
<p>假設有一個 1D 的直線運動系統，馬達編碼器的解析度設定為 1000000 pulse = 1 m。</p>
<p>以長度單位為公尺的設定範例：</p>
<ul>
<li>Group vmax = 0.01 [m/s]</li>
<li>Group amax = 5.0  [m/s^2]</li>
<li>Group jmax = 40.0 [m/s^3]</li>
<li>Group ignorable distance = 0.0000005 [m]</li>
<li>Axis encoder_ppu = 1000000</li>
<li>Axis encoder_length_unit = Meter</li>
<li>Axis vmax = 0.01 [m/s]</li>
<li>Axis amax = 5.0  [m/s^2]</li>
<li>Axis ignorable distance = 0.0000005 [m]</li>
</ul>
<p>以長度單位為脈衝數 (Pulse) 的設定範例：</p>
<ul>
<li>Group vmax = 10000.0 [pulse/s]</li>
<li>Group amax = 5000000.0  [pulse/s^2]</li>
<li>Group jmax = 40000000.0 [pulse/s^3]</li>
<li>Group ignorable distance = 0.5 [pulse]</li>
<li>Axis encoder_ppu = 1</li>
<li>Axis encoder_length_unit = Pulse</li>
<li>Axis vmax = 10000.0 [pulse/s]</li>
<li>Axis amax = 5000000.0  [pulse/s^2]</li>
<li>Axis ignorable distance = 0.5 [pulse]</li>
</ul>
<p>假設有一個 1D 的旋轉運動系統，馬達編碼器的解析度設定為 3600000 pulse = 1 rev，以旋轉半徑 100 mm 的切線速度來比擬線性速度。
Botnana Control 是以徑度 (radian) 計算，所以轉換時需要留意。</p>
<p>以長度單位為徑度的設定範例：</p>
<ul>
<li>Group vmax = 0.1 [rad/s]</li>
<li>Group amax = 50.0  [rad/s^2]</li>
<li>Group jmax = 400.0 [rad/s^3]</li>
<li>Group ignorable distance = 0.0000005 [rad]</li>
<li>Axis encoder_ppu = 3600000</li>
<li>Axis encoder_length_unit = Revolution</li>
<li>Axis vmax = 0.1 [rad/s]</li>
<li>Axis amax = 50.0  [rad/s^2]</li>
<li>Axis ignorable distance = 0.0000005 [rad]</li>
</ul>
<p><strong>命令位置</strong>：</p>
<p>當同動控制功能（+coordinator）開啟後，Botnana Control 會依據運動軸的設定，將運動軸的命令轉換到馬達驅動器的命令位置。
所以當同動控制功能 （+coordinator）開啟後，如果該控制器被運動軸所控制，就無法直接設定馬達驅動器的命令位置。</p>
<p>如果軸組啟動中，且依據路徑規劃開始運動，或是運動中暫停，Botnana Control 會依據軸組的設定將運動命令分配給對應的運動軸，
此時運動軸的命令就會受到軸組控制。如果軸組間有共用運動軸，切換時就必須要留意是否會造成運動軸命令位置不連續。</p>
<p><strong>落後誤差過大處置方式</strong></p>
<p>當實體軸運動時，如果命令位置與實際位置相差過大，通常表示有軸控的問題發生，當停止運動且排除故障後，消除落後誤差過大的方法如下：</p>
<ul>
<li>當同動控制功能沒有開啟或是該馬達驅動器不受運動軸控制時，直接以馬達驅動器的實際位置設定命令位置。例如：</li>
</ul>
<pre><code>    1 1 real-p@ 1 1 target-p!
</code></pre>
<ul>
<li>當同動控制功能開啟，且運動軸不受軸組控制，例如：</li>
</ul>
<pre><code>    1 0axis-ferr    \ 清除第 1 個運動軸的落後誤差
</code></pre>
<ul>
<li>當同動控制功能開啟，且運動軸受軸組控制，例如：</li>
</ul>
<pre><code>    1 group! 0path     \ 假設是第 1 個軸組，切換軸組為 1，清除路徑
    1 0axis-ferr       \ 假設第 1 個運動軸受控於第 1 個軸組，清除第 1 個運動軸的落後誤差
    2 0axis-ferr       \ 假設第 2 個運動軸受控於第 1 個軸組，清除第 2 個運動軸的落後誤差
</code></pre>
<hr />
<h3 id="coordinator"><a class="header" href="#coordinator">Coordinator</a></h3>
<h4 id="coordinator-----"><a class="header" href="#coordinator-----"><code>.coordinator ( -- )</code></a></h4>
<p>輸出軸組狀態。</p>
<p>輸出訊息如下：</p>
<pre><code>    coordinator_enabled|0

    coordinator_enabled: 1 表示同動功能開啟，0 表示同動功能關閉。
</code></pre>
<h4 id="coordinator------1"><a class="header" href="#coordinator------1"><code>+coordinator ( -- )</code></a></h4>
<p>啟動同動控制功能。</p>
<p>由 Botnana Control 進行軸運動控制，Botnana Control會依軸組路徑或是運動軸目標位置進行加減速規劃與位置補間。</p>
<p>在此模式之下，驅動器必須要切換到 CSP Mode。</p>
<h4 id="-coordinator-----"><a class="header" href="#-coordinator-----"><code>-coordinator ( -- )</code></a></h4>
<p>關閉同動控制功能。</p>
<h4 id="groups-----len-"><a class="header" href="#groups-----len-"><code>#groups ( -- len )</code></a></h4>
<p>取得軸組數量 <code>len</code>。</p>
<h4 id="axes-----len-"><a class="header" href="#axes-----len-"><code>#axes ( -- len )</code></a></h4>
<p>取得運動軸數量 <code>len</code> 。</p>
<h4 id="coordinator-----t-"><a class="header" href="#coordinator-----t-"><code>coordinator? ( -- t )</code></a></h4>
<p>軸組是否開啟？</p>
<h4 id="empty-----t-"><a class="header" href="#empty-----t-"><code>empty? ( -- t )</code></a></h4>
<p>所有軸組的路徑是否已經清空？</p>
<h4 id="ems-job-----"><a class="header" href="#ems-job-----"><code>ems-job ( -- )</code></a></h4>
<p>執行同動功能緊急停止。所有軸組與運動軸的點對點運動都會立即停止。軸組的路徑資訊都會被清除。</p>
<h4 id="end-----t-"><a class="header" href="#end-----t-"><code>end? ( -- t )</code></a></h4>
<p>所以軸組與運動軸點對點運動是否到達路徑終點？</p>
<h4 id="reset-job-----"><a class="header" href="#reset-job-----"><code>reset-job ( -- )</code></a></h4>
<p>清除所有軸組的路經資訊。</p>
<h4 id="start-job-----"><a class="header" href="#start-job-----"><code>start-job ( -- )</code></a></h4>
<p>命令所有軸組開始運動。</p>
<h4 id="stop-----t-"><a class="header" href="#stop-----t-"><code>stop? ( -- t )</code></a></h4>
<p>所以軸組與運動軸點對點運動是否已經停止？</p>
<h4 id="stop-job-----"><a class="header" href="#stop-job-----"><code>stop-job ( -- )</code></a></h4>
<p>命令所有軸組與運動軸點對點運動減速停止。</p>
<h4 id="本節指令集-9"><a class="header" href="#本節指令集-9">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td><code>.coordinator</code></td><td>( --  )</td><td>輸出軸組狀態</td></tr>
<tr><td><code>+coordinator</code></td><td>( -- )</td><td>啟動軸組功能</td></tr>
<tr><td><code>-coordinator</code></td><td>( -- )</td><td>關閉軸組功能</td></tr>
<tr><td><code>#groups</code></td><td>( -- len )</td><td>取得軸組數量</td></tr>
<tr><td><code>#axes</code></td><td>( -- len )</td><td>取得運動軸數量</td></tr>
<tr><td><code>coordinator?</code></td><td>( -- t )</td><td>軸組是否開啟？</td></tr>
<tr><td><code>empty?</code></td><td>( -- t )</td><td>是否所有軸組路徑已經清空 ？</td></tr>
<tr><td><code>ems-job</code></td><td>( -- )</td><td>命令所以軸組緊急停止</td></tr>
<tr><td><code>end?</code></td><td>( -- t )</td><td>是否所有軸組已經到達路徑終點 ？</td></tr>
<tr><td><code>reset-job</code></td><td>( -- )</td><td>清除所有軸組路徑</td></tr>
<tr><td><code>start-job</code></td><td>( -- )</td><td>命令所有軸組開始運動</td></tr>
<tr><td><code>stop?</code></td><td>( -- t )</td><td>是否所有軸組已經停止運動 ？</td></tr>
<tr><td><code>stop-job</code></td><td>( -- )</td><td>命令所有軸組停止運動</td></tr>
</tbody></table>
<hr />
<h3 id="axis-group"><a class="header" href="#axis-group">Axis Group</a></h3>
<h4 id="group--g----"><a class="header" href="#group--g----"><code>.group ( g -- )</code></a></h4>
<p>輸出 group <code>g</code> 資訊</p>
<p>命令範例:</p>
<pre><code>1 .group  \ 輸出第 1 個軸組的資訊
</code></pre>
<p>回傳訊息 :</p>
<pre><code>group_enabled.1|0
|group_stopping.1|1
|move_count.1|0
|path_event_count.1|0
|path_id.1|0
|path_mode.1|0
|focus.1|0
|source.1|0
|pva.1|0.0000000,0.00000,0.00000
|move_length.1|0.0000000
|total_length.1|0.0000000
|feedrate.1|0.00000
|vcmd.1|0.00000
|max_look_ahead_count.1|0
|ACS.1|0.0000000,0.0000000,0.0000000
|MCS.1|0.0000000,0.0000000,0.0000000
|PCS.1|0.0000000,0.0000000,0.0000000
</code></pre>
<h4 id="grpcfg--g----"><a class="header" href="#grpcfg--g----"><code>.grpcfg ( g -- )</code></a></h4>
<p>輸出 group <code>g</code> 的設定參數</p>
<p>命令範例：</p>
<pre><code>1 .grpcfg  \ 輸出第 1 個軸組的設定參數
</code></pre>
<p>回傳訊息:</p>
<pre><code>group_name.1|Anonymous
|group_type.1|3D
|group_mapping.1|1,2,3
|group_vmax.1|0.10000
|group_amax.1|5.00000
|group_jmax.1|80.00000
|group_ignorable_distance.1|0.0000005
</code></pre>
<h4 id="group"><a class="header" href="#group"><code>+group</code></a></h4>
<p>啟動目前選用的軸組。</p>
<p>命令範例:</p>
<pre><code>1 group!   \ 切換到第 1 個軸組
+group     \ 啟動目前選用的軸組
</code></pre>
<h4 id="-group"><a class="header" href="#-group"><code>-group</code></a></h4>
<p>關閉目前選用的軸組。</p>
<h4 id="0path"><a class="header" href="#0path"><code>0path</code></a></h4>
<p>清除目前軸組的路經資訊。</p>
<p>命令範例:</p>
<pre><code>1 group!  \ 切換到第 1 個軸組
0ptah     \ 清除目前軸組的路經資訊
</code></pre>
<h4 id="acs-p--n------f----pos-"><a class="header" href="#acs-p--n------f----pos-"><code>acs-p@ ( n -- ) ( F: -- pos )</code></a></h4>
<p>取得目前軸組，ACS 座標系第 <code>n</code> 軸的座標位置。</p>
<p>命令範例:</p>
<pre><code>1 acs-p@ f. \ 取得第 1 軸得座標位置，然後輸出位置資訊
</code></pre>
<p>回傳訊息:</p>
<pre><code>0.0000000
</code></pre>
<h4 id="feedrate--f-v----"><a class="header" href="#feedrate--f-v----"><code>feedrate! ( F: v -- )</code></a></h4>
<p>設定後續安插路徑的最大運動速度 <code>v</code>。<code>v</code> 必須大於 0。</p>
<p>命令範例:</p>
<pre><code>100.0e mm/min feedrate!  \ 設定當下 group feedrate 為 100.0 mm/min
</code></pre>
<h4 id="feedrate--f----v-"><a class="header" href="#feedrate--f----v-"><code>feedrate@ ( F: -- v )</code></a></h4>
<p>取得後續安插路徑的最大運動速度 <code>v</code>。</p>
<p>命令範例:</p>
<pre><code>feedrate@ f. \ 取得 group feedrate，並輸出訊息
</code></pre>
<p>回傳訊息:</p>
<pre><code>0.1000000
</code></pre>
<h4 id="gamax--g------f-a----"><a class="header" href="#gamax--g------f-a----"><code>gamax! ( g -- ) ( F: a -- )</code></a></h4>
<p>設定 group <code>g</code> 的最大加速度為 <code>a</code>。</p>
<p>命令範例：</p>
<pre><code>2.0e 1 gamax! \ 設定 Group 1 的最大加速度為 2.0
</code></pre>
<h4 id="gend-----flag-"><a class="header" href="#gend-----flag-"><code>gend? ( -- flag )</code></a></h4>
<p>所選定的軸組是否到達路徑終點？</p>
<h4 id="gignore-dist--g------f-dist---"><a class="header" href="#gignore-dist--g------f-dist---"><code>gignore-dist! ( g -- ) ( F: dist --)</code></a></h4>
<p>設定指定軸組 <code>g</code> 可忽略的長度計算誤差 <code>dist</code>。</p>
<p>通常在 pulse 的系統下，設定為 0.5 或是 0.1 [pulse]。其它設定為 0.5e-6 或是 0.1e-6 [m] or [rad]</p>
<h4 id="gjmax--g------f-j----"><a class="header" href="#gjmax--g------f-j----"><code>gjmax! ( g -- ) ( F: j -- )</code></a></h4>
<p>設定 group <code>g</code> 的最大加加速度為 <code>j</code>。</p>
<p>命令範例：</p>
<pre><code>40.0e 1 gjmax! \ 設定 Group 1 的最大加加速度為 40.0
</code></pre>
<h4 id="gmap--j1-j2-j3--g----"><a class="header" href="#gmap--j1-j2-j3--g----"><code>gmap! ( j1 j2 j3 ... g -- )</code></a></h4>
<p>設定軸組 <code>g</code> 所控制的運動軸 <code>j1 j2 j3 ...</code>。需要注意軸組型態與運動軸數量。</p>
<p>注意事項：</p>
<ol>
<li>軸組 <code>g</code> 不可以處在啟動狀態。</li>
<li>運動軸 <code>j</code> 不可受控於其他啟動中的軸組或是在點對點運動模式。</li>
<li>軸組型態與運動軸數量要匹配正確。</li>
</ol>
<p>命令範例：</p>
<pre><code>              \ 假設軸組 1 是 3D 軸組
2 3 4 1 gmap! \ 設定 Group 1 對應的運動軸編號分別是 2, 3, 4
2 1 gmap!     \ 設定 Group 1 對應的運動軸編號分別是 2，則是會回報錯誤 （Stack underflow）
</code></pre>
<h4 id="gmap--g----j1-j2-j3--"><a class="header" href="#gmap--g----j1-j2-j3--"><code>gmap@ ( g -- j1 j2 j3 ... )</code></a></h4>
<p>取得軸組所控制的運動軸，需要注意軸組型態與運動軸數量。</p>
<h4 id="group--g-----1"><a class="header" href="#group--g-----1"><code>group! ( g -- )</code></a></h4>
<p>設定目前選用的軸組 <code>g</code>, <code>g</code>  編號從 1 開始。</p>
<h4 id="group-----g-"><a class="header" href="#group-----g-"><code>group@ ( -- g )</code></a></h4>
<p>取得目前所選定的軸組 <code>g</code>命令範例:</p>
<pre><code>group@                  \ 取出目前軸組編號
1 group! 0.1e feedrate! \ 選用軸組 1，設定 feedrate
group!                  \ 切換回原來的軸組
</code></pre>
<h4 id="group-----t-"><a class="header" href="#group-----t-"><code>group? ( -- t )</code></a></h4>
<p>目前所選定的軸組是否啟動 ?</p>
<h4 id="grp1d--g----flag-"><a class="header" href="#grp1d--g----flag-"><code>grp1d? ( g -- flag )</code></a></h4>
<p>指定軸組 <code>g</code> 是否為 1D 軸組 ?</p>
<h4 id="grp2d--g----flag-"><a class="header" href="#grp2d--g----flag-"><code>grp2d? ( g -- flag )</code></a></h4>
<p>指定軸組 <code>g</code> 是否為 2D 軸組 ?</p>
<h4 id="grp3d--g----flag-"><a class="header" href="#grp3d--g----flag-"><code>grp3d? ( g -- flag )</code></a></h4>
<p>指定軸組 <code>g</code> 是否為 3D 軸組 ?</p>
<h4 id="grp-sine--g----flag-"><a class="header" href="#grp-sine--g----flag-"><code>grp-sine? ( g -- flag )</code></a></h4>
<p>指定軸組 <code>g</code> 是否為 Sine Wave 軸組 ?</p>
<h4 id="gstart-----"><a class="header" href="#gstart-----"><code>gstart ( -- )</code></a></h4>
<p>命令所選定的軸組開始運動。</p>
<p>命令範例:</p>
<pre><code>1 group! gstart  \ 切換到軸組 1, 命令軸組 1 開始運動。
</code></pre>
<h4 id="gstop-----"><a class="header" href="#gstop-----"><code>gstop ( -- )</code></a></h4>
<p>命令所選定的軸組停止運動。</p>
<p>命令範例:</p>
<pre><code>1 group! gstop  \ 切換到軸組 1, 命令軸組 1 停止運動。
</code></pre>
<h4 id="gstop-----flag-"><a class="header" href="#gstop-----flag-"><code>gstop? ( -- flag )</code></a></h4>
<p>所選定的軸組是否已經停止運動 ？</p>
<h4 id="gvmax--g------f-v----"><a class="header" href="#gvmax--g------f-v----"><code>gvmax! ( g -- ) ( F: v -- )</code></a></h4>
<p>設定 group <code>g</code> 的最大速度為 <code>v</code>。</p>
<p>命令範例：</p>
<pre><code>1000.0e mm/min 2 gvmax! \ 設定 Group 1 的最高速度為 1000.0 mm/min
</code></pre>
<h4 id="map-len--g----len-"><a class="header" href="#map-len--g----len-"><code>map-len@ ( g -- len )</code></a></h4>
<p>取得軸組 <code>g</code> 的運動軸數量 <code>len</code>。</p>
<h4 id="map-sine--j1-g----"><a class="header" href="#map-sine--j1-g----"><code>map-sine ( j1 g -- )</code></a></h4>
<p>設定軸組 <code>g</code> 的對應運動軸為 <code>j1</code>。</p>
<p>注意事項：</p>
<ol>
<li>軸組 <code>g</code> 必須為 Sine Wave 軸組。</li>
<li>軸組 <code>g</code> 不可以處在啟動狀態。</li>
<li>運動軸 <code>j1</code> 不可受控於其他啟動中的軸組或是在點對點運動模式。</li>
</ol>
<p>命令範例： </p>
<pre><code>3 1 map-sine  \ 設定 Group 1 的運動軸為 Axis 3
</code></pre>
<h4 id="map1d--j1-g----"><a class="header" href="#map1d--j1-g----"><code>map1d ( j1 g -- )</code></a></h4>
<p>設定軸組 <code>g</code> 的對應運動軸為 <code>j1</code>。</p>
<p>注意事項：</p>
<ol>
<li>軸組 <code>g</code> 必須為 1D 軸組。</li>
<li>軸組 <code>g</code> 不可以處在啟動狀態。</li>
<li>運動軸 <code>j1</code> 不可受控於其他啟動中的軸組或是在點對點運動模式。</li>
</ol>
<p>命令範例：</p>
<pre><code>3 1 map1d  \ 設定 Group 1 的運動軸為 Axis 3
</code></pre>
<h4 id="map2d--j1-j2-g----"><a class="header" href="#map2d--j1-j2-g----"><code>map2d ( j1 j2 g -- )</code></a></h4>
<p>設定軸組 <code>g</code> 的對應運動軸為 <code>j1, j2</code>。</p>
<p>注意事項：</p>
<ol>
<li>軸組 <code>g</code> 必須為 2D 軸組。</li>
<li>軸組 <code>g</code> 不可以處在啟動狀態。</li>
<li>運動軸 <code>j1 j2</code> 不可受控於其他啟動中的軸組或是在點對點運動模式。</li>
</ol>
<p>命令範例：</p>
<pre><code>3 5 2 map2d \ 設定 Group 2 的運動軸為 Axis 3, 5
</code></pre>
<h4 id="map3d--j1-j2-j3-g----"><a class="header" href="#map3d--j1-j2-j3-g----"><code>map3d ( j1 j2 j3 g -- )</code></a></h4>
<p>設定軸組 <code>g</code> 的對應運動軸為 <code>j1, j2, j3</code>。</p>
<p>注意事項：</p>
<ol>
<li>軸組 <code>g</code> 必須為 3D 軸組。</li>
<li>軸組 <code>g</code> 不可以處在啟動狀態。</li>
<li>運動軸 <code>j1 j2 j3</code> 不可受控於其他啟動中的軸組或是在點對點運動模式。</li>
</ol>
<p>命令範例：</p>
<pre><code>3 5 6 2 map3d 設定 Group 2 的運動軸為 Axis 3, 5, 6
</code></pre>
<h4 id="mcs-----"><a class="header" href="#mcs-----"><code>mcs ( -- )</code></a></h4>
<p>宣告所選定軸組以目前 MCS 座標位置為路徑起始點（將 PCS 與 MCS 座標系重疊）。</p>
<h4 id="mcs-p---n------f----pos-"><a class="header" href="#mcs-p---n------f----pos-"><code>mcs-p@  ( n -- ) ( F: -- pos )</code></a></h4>
<p>取得所選定軸組 MCS 座標系中指定軸 <code>n</code> 的座標位置 <code>pos</code>。</p>
<p>命令範例：</p>
<pre><code>1 mcs-p@  \ 取得第 1 軸的 MCS 座標系位置。
</code></pre>
<h4 id="move-source------n-"><a class="header" href="#move-source------n-"><code>move-source#  ( -- n )</code></a></h4>
<p>取得所選定軸組目前是處在哪個路徑事件 <code>n</code>。</p>
<h4 id="next-a---f----a-"><a class="header" href="#next-a---f----a-"><code>next-a@  ( F: -- a )</code></a></h4>
<p>取得所選定軸組路徑切線方向加速度 <code>a</code>。</p>
<h4 id="next-path-id-----id-"><a class="header" href="#next-path-id-----id-"><code>next-path-id@ ( -- id )</code></a></h4>
<p>取得所選定軸組，目前路徑的編號 <code>id</code>。</p>
<h4 id="next-path-mode-----mode-"><a class="header" href="#next-path-mode-----mode-"><code>next-path-mode@ ( -- mode )</code></a></h4>
<p>取得所選定軸組，目前路徑的模式 <code>mode</code>。</p>
<h4 id="next-path-p--------f----pos-"><a class="header" href="#next-path-p--------f----pos-"><code>next-path-p@  ( -- ) ( F: -- pos )</code></a></h4>
<p>取得所選定軸組，從運動起始點算起，沿路路徑方向的位置 <code>pos</code>。</p>
<h4 id="next-v--f----v-"><a class="header" href="#next-v--f----v-"><code>next-v@ ( F: -- v )</code></a></h4>
<p>取得所選定軸組路徑切線方向速度 <code>v</code>。</p>
<h4 id="path-events-capacity-----n-"><a class="header" href="#path-events-capacity-----n-"><code>path-events-capacity@ ( -- n )</code></a></h4>
<p>取得所選定軸組可容納的路徑數量 <code>n</code>。</p>
<h4 id="path-events-len-----n-"><a class="header" href="#path-events-len-----n-"><code>path-events-len@ ( -- n )</code></a></h4>
<p>取得所選定軸組目前的路徑數量 <code>n</code>。</p>
<h4 id="path-id--id----"><a class="header" href="#path-id--id----"><code>path-id! ( id -- )</code></a></h4>
<p>設定後續安插路徑的編號 <code>id</code>。</p>
<p>應用範例：</p>
<ol>
<li>儲存對應 NC 程式的行號，當執行軸組運動時可以得知目前位置是由哪一行 NC 程式解譯而來。</li>
</ol>
<h4 id="path-id-----id-"><a class="header" href="#path-id-----id-"><code>path-id@ ( -- id )</code></a></h4>
<p>取得後續安插路徑的編號 <code>id</code>。</p>
<h4 id="path-mode--mode----"><a class="header" href="#path-mode--mode----"><code>path-mode! ( mode -- )</code></a></h4>
<p>設定後續安插路徑的模式 <code>mode</code>。</p>
<h4 id="path-mode-----mode-"><a class="header" href="#path-mode-----mode-"><code>path-mode@ ( -- mode )</code></a></h4>
<p>取得後續安插路徑的模式 <code>mode</code>。</p>
<p>應用範例：</p>
<ol>
<li>用來區分該路徑是加工或是非加工路徑。可以增加 SFC 依據當下的模式控制對應的 IO 點。</li>
</ol>
<h4 id="pcs-p---n------f----pos-"><a class="header" href="#pcs-p---n------f----pos-"><code>pcs-p@  ( n -- ) ( F: -- pos )</code></a></h4>
<p>取得所選定軸組 PCS 座標系的指定軸 <code>n</code> 的座標位置 <code>pos</code>。</p>
<h4 id="vcmd--f-v----"><a class="header" href="#vcmd--f-v----"><code>vcmd! ( F: v -- )</code></a></h4>
<p>設定路徑上運行的速度 <code>v</code>。</p>
<ul>
<li>當 <code>v</code> &gt; 0 時，會沿著路徑前進，直到路徑終點。</li>
<li>當 <code>v</code> = 0 時，速度會減速到 0。</li>
<li>當 <code>v</code> &lt; 0 時，會沿著路徑後退，直到路徑起始點。</li>
</ul>
<p>運動速度限制如下：</p>
<ol>
<li>vcmd! 所指定的速度。</li>
<li>該軸組所限制的最大運動速度 (gvmax!)。</li>
<li>當下路徑的進給速度 （feedrate!）。</li>
<li>預視路徑總長與當下位置。</li>
</ol>
<p>命令範例:</p>
<pre><code>100.0e mm/min vcmd! \ 設定運動速度為 100.0 mm/min
</code></pre>
<h4 id="本節指令集-10"><a class="header" href="#本節指令集-10">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>.group</td><td>( g -- )</td><td>顯示軸組狀態</td></tr>
<tr><td>.grpcfg</td><td>( g -- )</td><td>顯示軸組設定參數</td></tr>
<tr><td>+group</td><td>( -- )</td><td>啟動所選定的軸組</td></tr>
<tr><td>-group</td><td>( -- )</td><td>關閉所選定的軸組</td></tr>
<tr><td>0path</td><td>( -- )</td><td>清除所選定的軸組路徑資訊</td></tr>
<tr><td>acs-p@</td><td>( n -- ) ( F: -- pos )</td><td>取得所選定軸組 ACS 座標系的指定軸的座標位置</td></tr>
<tr><td>feedrate!</td><td>( F: v -- )</td><td>設定後續安插路徑的最大運動速度</td></tr>
<tr><td>feedrate@</td><td>( F: -- v )</td><td>取得後續安插路徑的最大運動速度</td></tr>
<tr><td>gamax!</td><td>( g -- ) ( F: a --)</td><td>設定指定軸組的最大加速度</td></tr>
<tr><td>gend?</td><td>( -- flag )</td><td>所選定的軸組是否到達路徑終點 ?</td></tr>
<tr><td>gignore-dist!</td><td>( g -- ) ( F: dist --)</td><td>設定指定軸組可忽略的長度計算誤差</td></tr>
<tr><td>gjmax!</td><td>( g -- ) ( F: j --)</td><td>設定指定軸組的最大加加速度</td></tr>
<tr><td>gmap!</td><td>( j1 j2 j3 ... g -- )</td><td>設定軸組所控制的運動軸，需要注意軸組型態與運動軸數量</td></tr>
<tr><td>gmap@</td><td>( g -- j1 j2 j3 ... )</td><td>取得軸組所控制的運動軸，需要注意軸組型態與運動軸數量</td></tr>
<tr><td>group!</td><td>( g -- )</td><td>選定軸組</td></tr>
<tr><td>group@</td><td>( -- g )</td><td>取得目前所選定的軸組</td></tr>
<tr><td>group?</td><td>( -- t )</td><td>目前所選定的軸組是否啟動 ?</td></tr>
<tr><td>grp1d?</td><td>( g -- flag )</td><td>指定軸組是否為 1D 軸組</td></tr>
<tr><td>grp2d?</td><td>( g -- flag )</td><td>指定軸組是否為 2D 軸組</td></tr>
<tr><td>grp3d?</td><td>( g -- flag )</td><td>指定軸組是否為 3D 軸組</td></tr>
<tr><td>grp-sine?</td><td>( g -- flag )</td><td>指定軸組是否為 Sine Wave 軸組</td></tr>
<tr><td>gstart</td><td>( -- )</td><td>命令所選定的軸組開始運動</td></tr>
<tr><td>gstop</td><td>( -- )</td><td>命令所選定的軸組停止運動</td></tr>
<tr><td>gstop?</td><td>( -- flag )</td><td>所選定的軸組是否已經停止運動 ?</td></tr>
<tr><td>gvmax!</td><td>( g -- ) ( F: v --)</td><td>設定指定軸組的最大運動速度</td></tr>
<tr><td>map-len@</td><td>( g -- len )</td><td>取得指定軸組的運動軸數量</td></tr>
<tr><td>map-sine</td><td>( j1 g -- )</td><td>設定 Sine Wave 軸組所控制的運動軸</td></tr>
<tr><td>map1d</td><td>( j2 g -- )</td><td>設定 1D 軸組所控制的運動軸</td></tr>
<tr><td>map2d</td><td>( j1 j2 g -- )</td><td>設定 2D 軸組所控制的運動軸</td></tr>
<tr><td>map3d</td><td>( j1 j2 j3 g -- )</td><td>設定 3D 軸組所控制的運動軸</td></tr>
<tr><td>mcs</td><td>( -- )</td><td>宣告所選定軸組以目前 MCS 座標位置為路徑起始點</td></tr>
<tr><td>mcs-p@</td><td>( n -- ) ( F: -- pos )</td><td>取得所選定軸組 MCS 座標系的指定軸的座標位置</td></tr>
<tr><td>move-source#</td><td>( -- n )</td><td>取得所選定軸組目前是處在哪個路徑事件</td></tr>
<tr><td>next-a@</td><td>( F: -- a )</td><td>取得所選定軸組路徑切線方向加速度</td></tr>
<tr><td>next-path-id@</td><td>( -- id )</td><td>取得所選定軸組，目前路徑的編號</td></tr>
<tr><td>next-path-mode@</td><td>( -- mode )</td><td>取得所選定軸組，目前路徑的模式</td></tr>
<tr><td>next-path-p@</td><td>( -- ) ( F: -- pos )</td><td>取得所選定軸組，從運動起始點算起，沿路路徑方向的位置</td></tr>
<tr><td>next-v@</td><td>( F: -- v )</td><td>取得所選定軸組路徑切線方向速度</td></tr>
<tr><td>path-events-capacity@</td><td>( -- n )</td><td>取得所選定軸組可容納的路徑數量</td></tr>
<tr><td>path-events-len@</td><td>( -- n )</td><td>取得所選定軸組目前的路徑數量</td></tr>
<tr><td>path-id!</td><td>( id -- )</td><td>設定後續安插路徑的編號</td></tr>
<tr><td>path-id@</td><td>( -- id )</td><td>取得後續安插路徑的編號</td></tr>
<tr><td>path-mode!</td><td>( mode -- )</td><td>設定後續安插路徑的模式</td></tr>
<tr><td>path-mode@</td><td>( -- mode )</td><td>取得後續安插路徑的模式</td></tr>
<tr><td>pcs-p@</td><td>( n -- ) ( F: -- pos )</td><td>取得所選定軸組 PCS 座標系的指定軸的座標位置</td></tr>
<tr><td>vcmd!</td><td>( F: v -- )</td><td>設定所選定的軸組的速度命令</td></tr>
</tbody></table>
<hr />
<h3 id="1d-路徑規劃"><a class="header" href="#1d-路徑規劃">1D 路徑規劃</a></h3>
<p>注意事項：</p>
<ol>
<li>目前選用的軸組必須為 1D 型態。</li>
<li>路徑的起始點為前一個路徑的目標點。</li>
<li>必須要宣告路徑起始點（ move1d, mcs, psc1d）</li>
</ol>
<h4 id="line1d--f-x----"><a class="header" href="#line1d--f-x----"><code>line1d ( F: x -- )</code></a></h4>
<p>增加目標點為 (<code>x</code>) 的直線路徑。</p>
<h4 id="move1d--f-x----"><a class="header" href="#move1d--f-x----"><code>move1d ( F: x -- )</code></a></h4>
<p>宣告目前位置為 PCS 座標 (<code>x</code>)，並且為路徑起始點。類似工件程式 GM 碼的 G92。</p>
<h4 id="pcs1d--f-x0----"><a class="header" href="#pcs1d--f-x0----"><code>pcs1d ( F: x0 -- )</code></a></h4>
<p>宣告 PCS 座標零點(<code>x0</code>)，並以當下位置做為路徑起始點。類似工件程式 GM 碼的 G54。</p>
<h4 id="範例-test-1d"><a class="header" href="#範例-test-1d">範例 test-1d</a></h4>
<p>假設 Group 1 為 1D group, 以 100.0 mm.min 速度運動通過相對起點為 -0.5, 1.0，終點為 0.0 的座標位置。</p>
<pre><code>: test-1d                      \ 定義 test-1d 指令
    +coordinator               \ 啟動軸運動控制模式
    start-job                  \ 啟動加減速機制
    1 group! +group            \ 切換選用軸組，啟動 Group 1
    0path                      \ 清除 Group 1 路徑
    0.0e move1d                \ 宣告目前位置為起始運動位置，座標為 0.0
    -0.5e line1d               \ 插入目標點為 -0.5 的 1D 直線路徑
    1.0e line1d                \ 插入目標點為 1.0 的 1D 直線路徑
    0.0e line1d                \ 插入目標點為 0.0 的 1D 直線路徑
    100.0e mm/min vcmd!        \ 設定運動速度為 100.0 mm/min
    begin                      \ 等待到達終點位置
        1 group! gend? not     \ 檢查是否到終點, 此處 1 group! 避免在等待過程中被其他指令修改了
    while
        pause                  \ 若是未到終點就等待下一個周期再進行檢查
    repeat 
    1 group! -group            \ 關閉 Group 1
;

deploy test-1d ;deploy         \ 在背景執行 test-1d
</code></pre>
<h4 id="本節指令集-11"><a class="header" href="#本節指令集-11">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>line1d</td><td>( F: x -- )</td><td>插入 1D 直線路徑</td></tr>
<tr><td>move1d</td><td>( F: x -- )</td><td>宣告目前 PCS 座標為 (x)，並做為路徑起始點</td></tr>
<tr><td>pcs1d</td><td>( F: x0 -- )</td><td>宣告 PCS 座標零點，並以當下位置做為路徑起始點</td></tr>
</tbody></table>
<hr />
<h3 id="2d-路徑規劃"><a class="header" href="#2d-路徑規劃">2D 路徑規劃</a></h3>
<p>注意事項：</p>
<ol>
<li>目前選用的軸組必須為 2D 型態。</li>
<li>路徑的起始點為前一個路徑的目標點。</li>
<li>必須要宣告路徑起始點（ move2d, mcs, psc2d）</li>
</ol>
<h4 id="arc2d--n-----f-cx-cy-x-y----"><a class="header" href="#arc2d--n-----f-cx-cy-x-y----"><code>arc2d ( n -- )( F: cx cy x y -- )</code></a></h4>
<p>增加 2D 圓弧路徑，其圓心為 (<code>cx</code>,<code>cy</code>)，目標位置是 (<code>x</code>, <code>y</code>)。 <code>n</code> 表示從起始點運動第 <code>n</code> 圈到達目標點。</p>
<ul>
<li><code>n</code> &gt; 0 表示逆時針運動，</li>
<li><code>n</code> &lt; 0 表示順時針運動，</li>
<li><code>n</code> 不可以為 0。</li>
</ul>
<h4 id="line2d--f-x-y----"><a class="header" href="#line2d--f-x-y----"><code>line2d ( F: x y -- )</code></a></h4>
<p>增加目標點為 (<code>x</code>,<code>y</code>) 的直線路徑。</p>
<h4 id="move2d--f-x-y----"><a class="header" href="#move2d--f-x-y----"><code>move2d ( F: x y -- )</code></a></h4>
<p>宣告目前位置為 PCS 座標 (<code>x</code>, <code>y</code>)，並且為路徑起始點。類似工件程式 GM 碼的 G92。</p>
<h4 id="pcs2d--f-x0-y0----"><a class="header" href="#pcs2d--f-x0-y0----"><code>pcs2d ( F: x0 y0 -- )</code></a></h4>
<p>宣告 PCS 座標零點(<code>x0</code>, <code>y0</code>)，並以當下位置做為路徑起始點。類似工件程式 GM 碼的 G54。</p>
<h4 id="範例-test-2d"><a class="header" href="#範例-test-2d">範例 test-2d</a></h4>
<p>假設 Group 1 為  2D group</p>
<pre><code>: test-2d                          \ 定義 test-2d 指令
    +coordinator                   \ 啟動軸運動控制模式
    start-job                      \ 啟動加減速機制
    1 group! +group                \ 啟動 Group 1
    0path                          \ 清除路徑
    0.0e  0.0e  move2d             \ 宣告目前位置為起始運動位置，座標為 (0.0, 0.0)
    0.1e  0.0e  line2d             \ 插入目標點為 (0.1, 0.0) 的 2D 直線路徑
    0.1e  0.1e  line2d             \ 插入目標點為 (0.1, 0.1) 的 2D 直線路徑
    0.0e  0.1e  line2d             \ 插入目標點為 (0.0, 0.1) 的 2D 直線路徑
    0.0e  0.05e 0.0e 0.0e 1 arc2d  \ 以圓心位置 （0.0, 0.05）逆時針走到目標點 （0.0, 0.0）
    100.0e mm/min vcmd!            \ 設定運動速度為 100.0 mm/min
    begin                          \ 等待到達終點位置
        1 group! gend? not         \ 檢查是否到終點, 此處 1 group! 避免在等待過程中被其他指令修改了
    while
        pause                      \ 若是未到終點就等待下一個周期再進行檢查
    repeat
    1 group! -group                \ 關閉 Group 1
;

deploy test-2d ;deploy         \ 在背景執行 test-2d
</code></pre>
<h4 id="本節指令集-12"><a class="header" href="#本節指令集-12">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>arc2d</td><td>( n -- )( F: cx cy x y -- )</td><td>插入 2D 圓弧路徑</td></tr>
<tr><td>line2d</td><td>( F: x y -- )</td><td>插入 2D 直線路徑</td></tr>
<tr><td>move2d</td><td>( F: x y -- )</td><td>宣告目前 PCS 座標為 (x, y)，並做為路徑起始點</td></tr>
<tr><td>pcs2d</td><td>( F: x0 y0 -- )</td><td>宣告 PCS 座標零點，並以當下位置做為路徑起始點</td></tr>
</tbody></table>
<hr />
<h3 id="3d-路徑規劃"><a class="header" href="#3d-路徑規劃">3D 路徑規劃</a></h3>
<p>注意事項：</p>
<ol>
<li>目前選用的軸組必須為 3D 型態。</li>
<li>路徑的起始點為前一個路徑的目標點。</li>
<li>必須要宣告路徑起始點（ move3d, mcs, psc3d）。</li>
</ol>
<h4 id="helix3d--n-----f-cx-cy-x-y-z----"><a class="header" href="#helix3d--n-----f-cx-cy-x-y-z----"><code>helix3d ( n -- )( F: cx cy x y z -- )</code></a></h4>
<p>增加 3D 螺旋路徑，其圓心為 (<code>cx</code>,<code>cy</code>)，目標位置是 (<code>x</code>, <code>y</code>, <code>z</code>)。 <code>n</code> 表示從起啟點運動第 <code>n</code> 圈到達目標點。</p>
<ul>
<li><code>n</code> &gt; 0 表示逆時針運動，</li>
<li><code>n</code> &lt; 0 表示順時針運動，</li>
<li><code>n</code> 不可以為 0。</li>
</ul>
<p>如果 <code>z</code> 與起始點相同，此螺旋路徑即為 XY 平面上的圓弧路徑。</p>
<h4 id="line3d--f-x-y-z---"><a class="header" href="#line3d--f-x-y-z---"><code>line3d ( F: x y z-- )</code></a></h4>
<p>增加目標點為 (<code>x</code>,<code>y</code>, <code>z</code>) 的直線路徑。</p>
<h4 id="move3d--f-x-y-z----"><a class="header" href="#move3d--f-x-y-z----"><code>move3d ( F: x y z -- )</code></a></h4>
<p>宣告目前位置為 PCS 座標 (<code>x</code>, <code>y</code>, <code>z</code>)，並且為路徑起始點。類似工件程式 GM 碼的 G92。</p>
<h4 id="pcs3d--f-x0-y0-z0----"><a class="header" href="#pcs3d--f-x0-y0-z0----"><code>pcs3d ( F: x0 y0 z0 -- )</code></a></h4>
<p>宣告 PCS 座標零點(<code>x0</code>, <code>y0</code>, <code>z0</code>)，並以當下位置做為路徑起始點。類似工件程式 GM 碼的 G54。</p>
<h4 id="範例-test-3d"><a class="header" href="#範例-test-3d">範例 test-3d</a></h4>
<p>假設 Group 1 為 3D group</p>
<pre><code>: test-3d                          \ 定義 test-3d 指令
    +coordinator                   \ 啟動軸運動控制模式
    start-job                      \ 啟動加減速機制
    1 group! +group                \ 啟動 Group 1
    0path                          \ 清除 Group 1 路徑
    0.0e  0.0e  0.0e   move3d      \ 宣告目前位置為起始運動位置，座標為 (0.0, 0.0, 0.0)
    0.0e  0.1e  0.0e  line3d       \ 插入目標點為 (0.0, 0.1, 0.0) 的 3D 直線路徑
    -0.1e  0.1e -0.2e 0.1e 0.1e  1 helix3d
                                   \ 以圓心位置 （-0.1, 0.1）逆時針走到目標點 （-0.2, 0.1, 0.1 ）的螺旋路徑
    100.0e mm/min vcmd!            \ 設定運動速度為 100.0 mm/min
    begin                          \ 等待到達終點位置
        1 group! gend? not         \ 檢查是否到終點, 此處 1 group! 避免在等待過程中被其他指令修改
    while
        pause                      \ 若是未到終點就等待下一個周期再進行檢查
    repeat
    1 group! -group                \ 關閉 Group 1
;

deploy test-3d ;deploy         \ 在背景執行 test-3d
</code></pre>
<h4 id="本節指令集-13"><a class="header" href="#本節指令集-13">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>helix3d</td><td>( n -- )( F: cx cy x y z -- )</td><td>插入 3D 螺旋路徑</td></tr>
<tr><td>line3d</td><td>( F: x y z -- )</td><td>插入 3D 直線路徑</td></tr>
<tr><td>move3d</td><td>( F: x y z -- )</td><td>宣告目前 PCS 座標為 (x, y, z)，並做為路徑起始點</td></tr>
<tr><td>pcs3d</td><td>( F: x0 y0 z0 -- )</td><td>宣告 PCS 座標零點，並以當下位置做為路徑起始點</td></tr>
</tbody></table>
<hr />
<h3 id="sine-wave-planner"><a class="header" href="#sine-wave-planner">Sine Wave Planner</a></h3>
<p>注意事項：</p>
<ol>
<li>目前選用的軸組必須為 Sine Wave 型態。</li>
<li>必須要宣告路徑起始點（ move3d, mcs, psc3d），此起始點就是相位 0 的位置。</li>
</ol>
<h4 id="move-sine--f-x----"><a class="header" href="#move-sine--f-x----"><code>move-sine ( F: x -- )</code></a></h4>
<p>宣告目前位置為 PCS 座標 (<code>x</code>)，並且為路徑起始點。</p>
<h4 id="sine-amp-f-amp----"><a class="header" href="#sine-amp-f-amp----"><code>sine-amp! (F: amp -- )</code></a></h4>
<p>設定弦波振幅。可以運動中修改，經過起始點後才開始改變振幅。</p>
<h4 id="sine-f--f-f----"><a class="header" href="#sine-f--f-f----"><code>sine-f! ( F: f -- )</code></a></h4>
<p>設定弦波頻率。可以運動中修改，在相位 270 deg 的地方改變頻率。</p>
<h4 id="pcs-sine--f-x0----"><a class="header" href="#pcs-sine--f-x0----"><code>pcs-sine ( F: x0 -- )</code></a></h4>
<p>宣告 PCS 座標零點(<code>x0</code>） ，並以當下位置做為路徑起始點。</p>
<h4 id="範例-test-sine"><a class="header" href="#範例-test-sine">範例 test-sine</a></h4>
<p>假設 Group 1 為 SINE Wave Group</p>
<pre><code>+coordinator          \ 啟動軸運動控制模式
start-job             \ 啟動加減速機制
1 group! +group       \ 啟動 Group 1
0path                 \ 清除 Group 1 路徑
0.0e   move-sine      \ 宣告目前位置為起始運動位置，座標為 (0.0)
1.0e   sine-f!        \ 設定sine wave 頻率為 1.0 Hz
0.01e  sine-amp!      \ 設定sine wave 振幅為 0.01
...
stop-job              \ 停止加減速機制
</code></pre>
<h4 id="本節指令集-14"><a class="header" href="#本節指令集-14">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>move-sine</td><td>( F: x -- )</td><td>宣告目前 PCS 座標為 (x)，並做為路徑起始點</td></tr>
<tr><td>sine-amp!</td><td>( F: amp -- )</td><td>設定弦波運動的振幅</td></tr>
<tr><td>sine-f!</td><td>( F: f -- )</td><td>設定弦波運動的頻率</td></tr>
<tr><td>pcs-sine</td><td>( F: x0 -- )</td><td>宣告 PCS 座標零點，並以當下位置做為路徑起始點</td></tr>
</tbody></table>
<hr />
<h3 id="axis"><a class="header" href="#axis">Axis</a></h3>
<p>名詞說明：</p>
<ul>
<li>
<p>command_position: 運動軸的目標位置。</p>
</li>
<li>
<p>demand_position: 運動過程中的命令位置。如果受到軸組控制時， demand_position 會與 command_position 相等。如果是運動軸的點對點運動，在過程中 demand_position 會朝著目標位置運動，只有在到達目標點時 demand_position 會與 command_position 相等。</p>
</li>
<li>
<p>feedback_position: 由馬達編碼器或是雙位置回授所得到的實際位置。</p>
</li>
<li>
<p>position_correction: 位置修正量。可以是 Pitch Corrector 所算出來的補正量，或是其他策略所推算出來的補正值。</p>
</li>
<li>
<p>corrected_position: 修正後的實際位置。</p>
<p>corrected_position = feedback_position - position_correction + home_offset</p>
</li>
<li>
<p>following_error: 落後誤差。</p>
<p>following_error = demand_position - corrected_position</p>
</li>
</ul>
<hr />
<h4 id="axis--j----"><a class="header" href="#axis--j----"><code>.axis ( j -- )</code></a></h4>
<p>顯示運動軸 <code>j</code> 狀態。</p>
<p>命令範例:</p>
<pre><code>1 .axis
</code></pre>
<p>回傳訊息 :</p>
<pre><code>axis_command_position.1|0.0000000
|axis_demand_position.1|0.0000000
|axis_corrected_position.1|0.0000000
|encoder_position.1|0.0000000
|external_encoder_position.1|0.0000000
|feedback_position.1|0.0000000
|position_correction.1|0.0000000
|following_error.1|0.0000000
|axis_interpolator_enabled.1|0
|axis_homed.1|0
</code></pre>
<h4 id="axiscfg--j----"><a class="header" href="#axiscfg--j----"><code>.axiscfg ( j -- )</code></a></h4>
<p>顯示運動軸 <code>j</code> 設定</p>
<p>命令範例：</p>
<pre><code>1 .axiscfg
</code></pre>
<p>回傳訊息：</p>
<pre><code>axis_name.1|A2
|axis_home_offset.1|0.0000000
|encoder_length_unit.1|Meter
|encoder_ppu.1|1000000.00000
|encoder_direction.1|1
|ext_encoder_ppu.1|60000.00000
|ext_encoder_direction.1|-1
|closed_loop_filter.1|15.0
|max_position_deviation.1|0.001000
|drive_alias.1|0
|drive_slave_position.1|1
|drive_channel.1|1
|ext_encoder_alias.1|0
|ext_encoder_slave_position.1|0
|ext_encoder_channel.1|0
|axis_amax.1|5.00000
|axis_vmax.1|0.10000
|axis_ignorable_distance.1|0.0000005
</code></pre>
<h4 id="homed--j----"><a class="header" href="#homed--j----"><code>+homed ( j -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 已回歸機械原點。</p>
<h4 id="-homed--j----"><a class="header" href="#-homed--j----"><code>-homed ( j -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 未回歸機械原點。</p>
<h4 id="0axis-ferr--j----"><a class="header" href="#0axis-ferr--j----"><code>0axis-ferr ( j -- )</code></a></h4>
<p>清除運動軸 <code>j</code> 落後誤差。使用運動軸實際位置修正命令位置，如果是虛擬軸則不受影響。</p>
<h4 id="axis-amax--j------f-amax----"><a class="header" href="#axis-amax--j------f-amax----"><code>axis-amax! ( j -- ) ( F: amax -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 的最大加速度 <code>amax</code>。</p>
<p>命令範例：</p>
<pre><code>2.0e 1 axis-amax!  \ 設定 Axis 1 amax 為 2.0
</code></pre>
<h4 id="axis-amax--j------f----amax-"><a class="header" href="#axis-amax--j------f----amax-"><code>axis-amax@ ( j -- ) ( F: -- amax )</code></a></h4>
<p>取得運動軸 <code>j</code> 的最大加速度 <code>amax</code>。</p>
<p>命令範例：</p>
<pre><code>1 axis-amax@  \ 取得 Axis 1 amax
</code></pre>
<h4 id="axis-clerr---j------f-clerr----"><a class="header" href="#axis-clerr---j------f-clerr----"><code>axis-clerr  ( j -- ) ( F: clerr -- )</code></a></h4>
<p>取得運動軸 <code>j</code> 雙位置回授誤差 <code>clerr</code>。</p>
<p>通常外部編碼器安裝在靠近軌道或是工作台的位置，如果和馬達編碼器的位置相差過大代表機械傳動系的運作出現問題，此時可以優先檢查皮帶輪或是聯軸器。</p>
<h4 id="axis-cmd-p--j-----f-pos----"><a class="header" href="#axis-cmd-p--j-----f-pos----"><code>axis-cmd-p! ( j -- )( F: pos -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 的目標位置 <code>pos</code>。</p>
<h4 id="axis-cmd-p--j-----f----pos-"><a class="header" href="#axis-cmd-p--j-----f----pos-"><code>axis-cmd-p@ ( j -- )( F: -- pos )</code></a></h4>
<p>取得運動軸 <code>j</code> 的目標位置 <code>pos</code>。</p>
<h4 id="axis-demand-p--j-----f----pos-"><a class="header" href="#axis-demand-p--j-----f----pos-"><code>axis-demand-p@ ( j -- )( F: -- pos )</code></a></h4>
<p>取得運動軸 <code>j</code> 的命令位置 <code>pos</code>。</p>
<h4 id="axis-drive--j-----channel-slave-"><a class="header" href="#axis-drive--j-----channel-slave-"><code>axis-drive@ ( j --  channel slave )</code></a></h4>
<p>取得運動軸 <code>j</code> 配置的馬達驅動器的 EtherCAT 站號 <code>slave</code> 與驅動軸編號 <code>channel</code>。</p>
<p><code>slave</code> 指的是 slave position，最靠近主站的從站編號為 1，依序遞增。</p>
<p>如果是以 slave alias 指定馬達驅動器的方式，則是主站在初始化或是設定時就依指定 slave alias 取得 slave position。</p>
<p>當是虛擬軸時，<code>axis-drive@</code> 回傳的 <code>channel = 0</code>, <code>slave = 0</code>。</p>
<h4 id="axis-ext-enc--j-----channel-slave-"><a class="header" href="#axis-ext-enc--j-----channel-slave-"><code>axis-ext-enc@ ( j --  channel slave )</code></a></h4>
<p>取得運動軸 <code>j</code> 配置的外部編碼器的 EtherCAT 站號 <code>slave</code> 與輸入編號 <code>channel</code>。</p>
<p>當沒有配置外部編碼器時會使得 <code>axis-ext-enc@</code> 回傳 <code>channel = 0</code>, <code>slave = 0</code>。</p>
<h4 id="axis-ferr--j------f-ferr----"><a class="header" href="#axis-ferr--j------f-ferr----"><code>axis-ferr@ ( j -- ) ( F: ferr -- )</code></a></h4>
<p>取得運動軸 <code>j</code> 取得落後誤差 <code>ferr</code>。</p>
<h4 id="axis-ignore-dist--j-------f-dist----"><a class="header" href="#axis-ignore-dist--j-------f-dist----"><code>axis-ignore-dist! ( j --  ) ( F: dist -- )</code></a></h4>
<p>設定指定運動軸 <code>j</code> 可忽略的長度計算誤差 <code>dist</code>。</p>
<p>通常在 pulse 的系統下，設定為 0.5 或是 0.1 [pulse]。其它設定為 0.5e-6 或是 0.1e-6 [m] or [rad]</p>
<h4 id="axis-len-----len-"><a class="header" href="#axis-len-----len-"><code>axis-len ( -- len )</code></a></h4>
<p>取得 Botnana Control 所規劃的運動軸總數 <code>len</code>。</p>
<h4 id="axis-real-p--j----f----pos-"><a class="header" href="#axis-real-p--j----f----pos-"><code>axis-real-p@ ( j -- )(F: -- pos )</code></a></h4>
<p>取得運動軸 <code>j</code>的實際位置 <code>pos</code> 。</p>
<h4 id="axis-rest---j----flag-"><a class="header" href="#axis-rest---j----flag-"><code>axis-rest?  ( j -- flag )</code></a></h4>
<p>運動軸 <code>j</code> 命令是否靜止？</p>
<p>可以利用此狀態作為不同落後誤差或是雙位置回授誤差的監控條件切換。</p>
<h4 id="axis-ts--j------f-ts----"><a class="header" href="#axis-ts--j------f-ts----"><code>axis-ts! ( j -- ) ( F: ts -- )</code></a></h4>
<p>設定用來判定運動軸 <code>j</code> 命令是否靜止的安定時間 <code>ts</code> sec。</p>
<h4 id="axis-vmax--j------f-vmax----"><a class="header" href="#axis-vmax--j------f-vmax----"><code>axis-vmax! ( j -- ) ( F: vmax -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 的最大速度 <code>vmax</code>。</p>
<p>命令範例：</p>
<pre><code>0.5e 1 axis-vmax!  \ 設定 Axis 1 vmax 為 0.5
</code></pre>
<h4 id="axis-vmax--j------f----vmax-"><a class="header" href="#axis-vmax--j------f----vmax-"><code>axis-vmax@ ( j -- ) ( F: -- vmax )</code></a></h4>
<p>取得運動軸 <code>j</code> 的最大速度 <code>vmax</code>。</p>
<h4 id="axispulse--j----pulse---f-pos----"><a class="header" href="#axispulse--j----pulse---f-pos----"><code>axis&gt;pulse ( j -- pulse ) ( F: pos -- )</code></a></h4>
<p>轉換運動軸 <code>j</code> 的命令位置 <code>pos</code> 為編碼器脈波位置 <code>pulse</code>。</p>
<h4 id="cl-cutoff--j------f-freq----"><a class="header" href="#cl-cutoff--j------f-freq----"><code>cl-cutoff! ( j -- ) ( F: freq -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 雙位置回授誤差濾波器的截止頻率 <code>freq</code>。</p>
<p>此截止頻率影響雙位置回授誤差的計算，如果調高，運動響應會比較貼近外部編碼器的回授位置，但是系統會比較不穩定。</p>
<h4 id="drv-alias---drive-alias-j----"><a class="header" href="#drv-alias---drive-alias-j----"><code>drv-alias!  ( drive-alias j -- )</code></a></h4>
<p>使用 EtherCAT Station Alias <code>drive-alias</code> 指定運動軸 <code>j</code> 馬達驅動器。</p>
<p>當 <code>drive-alias</code> = 0 表示使用 slave position 指定馬達驅動器。 當 <code>drive-alias</code> 不存在時，此運動軸就會以虛擬軸處理。</p>
<h4 id="drv-channel---drive-channel-j----"><a class="header" href="#drv-channel---drive-channel-j----"><code>drv-channel!  ( drive-channel j -- )</code></a></h4>
<p>使用 <code>drive-channel</code> 指定運動軸 <code>j</code> 馬達驅動器的控制軸。</p>
<p>因應單一 EtherCAT 從站多軸驅動器的模組型態，所以必須要使用此一參數。一般驅動器則是固定設定為 1。</p>
<p>命令範例：</p>
<pre><code>1 3 drv-channel! \ 設定 Axis 3 對應的馬達驅動器的控制軸為 1
</code></pre>
<h4 id="drv-slave---drive-slave-j----"><a class="header" href="#drv-slave---drive-slave-j----"><code>drv-slave!  ( drive-slave j -- )</code></a></h4>
<p>使用 EtherCAT Slave Position <code>drive-slave</code> 指定運動軸 <code>j</code> 馬達驅動器站號。</p>
<p>命令範例：</p>
<pre><code>2 1 drv-slave!  \ 設定 Axis 1 對應的馬達驅動器站號為 2
</code></pre>
<h4 id="enc-dir--dir-j----"><a class="header" href="#enc-dir--dir-j----"><code>enc-dir! ( dir j -- ) </code></a></h4>
<p>設定運動軸 <code>j</code> 馬達運動/編碼器方向 <code>dir</code>。</p>
<p>當機器的軸向與馬達的運轉方向定義相反時可以藉由此參數來轉換。</p>
<p>dir 可以設定的值為：</p>
<ul>
<li>1: 同方向</li>
<li>-1: 反方向</li>
</ul>
<p>命令範例：</p>
<pre><code>1 3 enc-dir!  \ 設定 Axis 3 編碼器方向
</code></pre>
<h4 id="enc-ppu--j-----f-ppu----"><a class="header" href="#enc-ppu--j-----f-ppu----"><code>enc-ppu! ( j --) ( F: ppu -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 距離單位對應馬達編碼器的脈波數 <code>ppu</code></p>
<p>命令範例可以參考 <code>enc-u!</code></p>
<h4 id="enc-u--u-j----"><a class="header" href="#enc-u--u-j----"><code>enc-u! ( u j -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 馬達編碼器的脈波數對應的距離單位 <code>u</code>。</p>
<p>可以設定的單位有：</p>
<ul>
<li>u = 0 as Meter,</li>
<li>u = 1 as Revolution</li>
<li>u = 2 as Pulse</li>
</ul>
<p>命令範例：</p>
<pre><code>1000000.0e 3 enc-ppu! \ 設定 Axis 3 的編碼器單位距離的脈波數為 1000000.0
0 3 enc-u!            \ 設定 Axis 3 的編碼器單位距離為 1 m
                      \ 表示 1 m 有 1000000 個 pulse (編碼器脈波數), 1 pulse 為 1 um
</code></pre>
<h4 id="ext-enc-alias--enc-alias-j----"><a class="header" href="#ext-enc-alias--enc-alias-j----"><code>ext-enc-alias! ( enc-alias j -- )</code></a></h4>
<p>使用 EtherCAT Station Alias 指定外部編碼器。參考 <code>drive-alias!</code>。</p>
<h4 id="ext-enc-channel--enc-channel-j----"><a class="header" href="#ext-enc-channel--enc-channel-j----"><code>ext-enc-channel! ( enc-channel j -- )</code></a></h4>
<p>指定外部編碼器的量測管道。參考 <code>drive-channel!</code>。</p>
<h4 id="ext-enc-dir--dir-j----"><a class="header" href="#ext-enc-dir--dir-j----"><code>ext-enc-dir! ( dir j -- )</code></a></h4>
<p>指定外部編碼器的方向。參考 <code>enc-dir!</code>。</p>
<h4 id="ext-enc-ofs---j-----f-ofs----"><a class="header" href="#ext-enc-ofs---j-----f-ofs----"><code>ext-enc-ofs!  ( j -- )( F: ofs -- )</code></a></h4>
<p>指定運動軸 <code>j</code> 外部編碼器的位置偏移量 <code>ofs</code>。</p>
<p>如果外部編碼器是絕對式型態，可以使用此命令調整外部編碼器由脈波數換算到物理位置的區間。</p>
<p>以海德漢長度 80 mm 絕對式光學尺為例，可以使用的區間範圍是 20 ~ 100 mm。
如果安裝方向與運動方向相反就會變成 -100 mm ~ -20 mm。
為了將換算出來的調整為 20 ~ 100 mm，就可以使用此命令來進行調整。</p>
<h5 id="ext-enc-ppu---j-----f-ppu----"><a class="header" href="#ext-enc-ppu---j-----f-ppu----"><code>ext-enc-ppu!  ( j -- )( F: ppu -- )</code></a></h5>
<p>設定運動單位距離對應外部編碼器的脈波數。參考 <code>enc-ppu!</code>。單位距離則是依 <code>enc-u!</code>設定。</p>
<h4 id="ext-enc-slave---enc-slave-j----"><a class="header" href="#ext-enc-slave---enc-slave-j----"><code>ext-enc-slave!  ( enc-slave j -- )</code></a></h4>
<p>使用 EtherCAT Slave Position 指定外部編碼器。參考 <code>drive-slave!</code>。</p>
<h4 id="hmofs--j------f-ofs----"><a class="header" href="#hmofs--j------f-ofs----"><code>hmofs! ( j -- ) ( F: ofs -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 機械零點的座標偏移量。</p>
<p>命令範例：</p>
<pre><code>0.5e 3 hmofs! \ 設定 Axis 3 home offset
</code></pre>
<h4 id="homed---j----flag-"><a class="header" href="#homed---j----flag-"><code>homed?  ( j -- flag )</code></a></h4>
<p>取得運動軸 <code>j</code> 是否回歸機械原點的狀態?</p>
<h4 id="max-pos-dev--j------f-max-dev----"><a class="header" href="#max-pos-dev--j------f-max-dev----"><code>max-pos-dev! ( j -- ) ( F: max-dev -- )</code></a></h4>
<p>設定運動軸 <code>j</code> 雙位置回授的最大命令修正量 <code>max-dev</code>。避免當傳動系出現問題或是參數配置錯誤時，修正量無法收斂到固定值的狀況發生。</p>
<h4 id="virtual-axis---j----flag-"><a class="header" href="#virtual-axis---j----flag-"><code>virtual-axis?  ( j -- flag )</code></a></h4>
<p>運動軸 <code>j</code> 是否為虛擬軸？</p>
<h4 id="運動軸追隨範例"><a class="header" href="#運動軸追隨範例">運動軸追隨範例</a></h4>
<p>以 Axis 2 追隨 Axis 1 的命令位置運動</p>
<pre><code>...
begin
    ... \某個條件成立執行
while
    ........
    2 axis-demand-p@ 1 axis-cmd-p!
    pause
repeat
...
</code></pre>
<h4 id="本節指令集-15"><a class="header" href="#本節指令集-15">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>.axis</td><td>( j -- )</td><td>顯示運動軸狀態</td></tr>
<tr><td>.axiscfg</td><td>( j -- )</td><td>顯示運動軸設定</td></tr>
<tr><td>+homed</td><td>( j -- )</td><td>設定運動軸已回歸機械原點</td></tr>
<tr><td>-homed</td><td>( j -- )</td><td>設定運動軸未回歸機械原點</td></tr>
<tr><td>0axis-ferr</td><td>( j -- )</td><td>清除落後誤差</td></tr>
<tr><td>axis-aff!</td><td>( j -- ) ( F: aff -- )</td><td>設定加速度前饋增益 （功能未實現）</td></tr>
<tr><td>axis-afactor!</td><td>( j -- ) ( F: afactor -- )</td><td>設定加速度前饋命令轉換常數 （功能未實現）</td></tr>
<tr><td>axis-amax!</td><td>( j -- ) ( F: amax -- )</td><td>設定運動軸最大加速度</td></tr>
<tr><td>axis-amax@</td><td>( j -- ) ( F: -- amax )</td><td>取得運動軸最大加速度</td></tr>
<tr><td>axis-clerr</td><td>( j --  ) ( F: clerr -- )</td><td>取得雙位置回授誤差</td></tr>
<tr><td>axis-cmd-p!</td><td>( j -- ) ( F: pos -- )</td><td>設定運動軸的目標位置</td></tr>
<tr><td>axis-cmd-p@</td><td>( j -- ) ( F: -- pos )</td><td>取得運動軸的目標位置</td></tr>
<tr><td>axis-demand-p@</td><td>( j -- ) (F: -- pos )</td><td>取得運動軸現在的命令位置</td></tr>
<tr><td>axis-drive@</td><td>( j --  channel slave )</td><td>取得馬達驅動器的 EtherCAT 站號</td></tr>
<tr><td>axis-ext-enc@</td><td>( j --  channel slave )</td><td>取得外部編碼器的 EtherCAT 站號</td></tr>
<tr><td>axis-ferr@</td><td>( j --  ) ( F: ferr -- )</td><td>取得落後誤差</td></tr>
<tr><td>axis-ignore-dist!</td><td>( j --  ) ( F: dist -- )</td><td>設定可以忽略的長度計算誤差</td></tr>
<tr><td>axis-len</td><td>( -- len )</td><td>取得運動軸總數</td></tr>
<tr><td>axis-real-p@</td><td>( j -- ) (F: -- pos )</td><td>取得運動軸實際位置</td></tr>
<tr><td>axis-rest?</td><td>( j -- flag )</td><td>運動軸命令是否靜止？</td></tr>
<tr><td>axis-ts!</td><td>( j -- ) ( F: ts -- )</td><td>設定用來判定運動軸命令是否靜止的安定時間</td></tr>
<tr><td>axis-vff!</td><td>( j -- ) ( F: vff -- )</td><td>設定速度前饋增益 （功能未實現）</td></tr>
<tr><td>axis-vfactor!</td><td>( j -- ) ( F: vfactor -- )</td><td>設定速度前饋命令轉換常數 （功能未實現）</td></tr>
<tr><td>axis-vmax!</td><td>( j -- ) ( F: vmax -- )</td><td>設定運動軸的最大速度</td></tr>
<tr><td>axis-vmax@</td><td>( j -- ) ( F: -- vmax )</td><td>取得運動軸的最大速度</td></tr>
<tr><td>axis&gt;pulse</td><td>( j -- pulse ) ( F: pos -- )</td><td>轉換運動軸的位置為編碼器脈波位置</td></tr>
<tr><td>cl-cutoff!</td><td>( j -- ) ( F: freq -- )</td><td>設定雙位置回授誤差濾波器的截止頻率</td></tr>
<tr><td>drv-alias!</td><td>( drive-alias j -- )</td><td>使用 EtherCAT Station Alias 指定馬達驅動器</td></tr>
<tr><td>drv-channel!</td><td>( drive-channel j -- )</td><td>指定馬達驅動器的控制軸</td></tr>
<tr><td>drv-slave!</td><td>( drive-slave j -- )</td><td>使用 EtherCAT Slave Position 指定馬達驅動器</td></tr>
<tr><td>enc-dir!</td><td>( dir j -- )</td><td>設定馬達運動/編碼器方向</td></tr>
<tr><td>enc-ppu!</td><td>( j -- )( F: ppu -- )</td><td>設定運動距離單位對應馬達編碼器的脈波數</td></tr>
<tr><td>enc-u!</td><td>( u j -- )</td><td>設定馬達編碼器的脈波數對應的距離單位</td></tr>
<tr><td>ext-enc-alias!</td><td>( enc-alias j -- )</td><td>使用 EtherCAT Station Alias 指定外部編碼器</td></tr>
<tr><td>ext-enc-channel!</td><td>( enc-channel j -- )</td><td>指定外部編碼器的量測管道</td></tr>
<tr><td>ext-enc-dir!</td><td>( dir j -- )</td><td>指定外部編碼器的方向</td></tr>
<tr><td>ext-enc-ofs!</td><td>( j -- )( F: ofs -- )</td><td>指定外部編碼器的位置偏移量</td></tr>
<tr><td>ext-enc-ppu!</td><td>( j -- )( F: ppu -- )</td><td>設定運動距離單位對應外部編碼器的脈波數</td></tr>
<tr><td>ext-enc-slave!</td><td>( enc-slave j -- )</td><td>使用 EtherCAT Slave Position 指定外部編碼器</td></tr>
<tr><td>hmofs!</td><td>( j -- ) ( F: ofs -- )</td><td>設定機械零點的座標偏移量</td></tr>
<tr><td>homed?</td><td>( j -- flag )</td><td>取得運動軸是否回歸機械原點的狀態</td></tr>
<tr><td>max-pos-dev!</td><td>( j -- ) ( F: max-dev -- )</td><td>設定雙位置回授的最大命令修正量</td></tr>
<tr><td>virtual-axis?</td><td>( j --  flag )</td><td>運動軸是否為虛擬軸？</td></tr>
</tbody></table>
<hr />
<h3 id="單軸運動"><a class="header" href="#單軸運動">單軸運動</a></h3>
<p>命令針對單一運動軸，可以同時讓多個運動軸同時運行。如果該運動軸受到軸組控制則不可執行單軸運動。</p>
<h4 id="interpolator--j----"><a class="header" href="#interpolator--j----"><code>+interpolator ( j -- )</code></a></h4>
<p>啟動 Axis <code>j</code> 單軸運動。</p>
<h4 id="-interpolator--j----"><a class="header" href="#-interpolator--j----"><code>-interpolator ( j -- )</code></a></h4>
<p>關閉 Axis <code>j</code> 單軸運動。如果單軸運動中，會以當下的速度開始減速到 0。</p>
<h4 id="interpolator-v--j-----f-v----"><a class="header" href="#interpolator-v--j-----f-v----"><code>interpolator-v! ( j -- )（ F: v -- ）</code></a></h4>
<p>設定 Axis  <code>j</code> 單軸運動的最大速度。</p>
<h4 id="單軸運動範例"><a class="header" href="#單軸運動範例">單軸運動範例</a></h4>
<p>以 Axis 1 為例：</p>
<pre><code>+coordinator                       \ 啟動軸組功能
1  +interpolator                   \ 啟動 Axis 1 單軸運動
100.0e  mm/min  1  interpolator-v! \ 設定 Axis 1 單軸運動速度為 100.0 mm/min
0.3e  1  axis-cmd-p!               \ 設定 Axis 1 的目標位置為座標位置 0.3 m 
1 axis-demand-p@                   \ 取得 Axis 1 目前的命令位置
1 axis-real-p@                     \ 取得 Axis 1 目前的實際位置
</code></pre>
<h4 id="本節指令集-16"><a class="header" href="#本節指令集-16">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>+interpolator</td><td>( j -- )</td><td>啟動單軸運動</td></tr>
<tr><td>-interpolator</td><td>( j -- )</td><td>關閉單軸運動</td></tr>
<tr><td>interpolator?</td><td>( j -- flag )</td><td>單軸運動是否開啟？</td></tr>
<tr><td>interpolator-reached?</td><td>( j -- flag )</td><td>單軸運動是否到達目標點？</td></tr>
<tr><td>interpolator-v!</td><td>( j -- ) (F: v -- )</td><td>設定單軸運動速度</td></tr>
</tbody></table>
<hr />
<h3 id="pitch-corrector"><a class="header" href="#pitch-corrector">Pitch Corrector</a></h3>
<h4 id="pcorr--channel-slave----"><a class="header" href="#pcorr--channel-slave----"><code>+pcorr ( channel slave -- )</code></a></h4>
<p>開啟指定驅動器的 Pitch Corrector</p>
<h4 id="-pcorr--channel-slave----"><a class="header" href="#-pcorr--channel-slave----"><code>-pcorr ( channel slave -- )</code></a></h4>
<p>關閉指定驅動器的 Pitch Corrector</p>
<h4 id="pcorr--channel-slave-----1"><a class="header" href="#pcorr--channel-slave-----1"><code>&gt;pcorr ( channel slave -- )</code></a></h4>
<p>讀取指定驅動器的 Pitch Corrector，此命令會造成 real time cycle overrun, 要在安全的情況下使用，例如 Servo off 的情況下。</p>
<h4 id="pcorr--channel-slave-----2"><a class="header" href="#pcorr--channel-slave-----2"><code>.pcorr ( channel slave -- )</code></a></h4>
<p>輸出目前 Pitch Corrector 的查表結果</p>
<p>命令範例:</p>
<pre><code>1 1 .pcorr
</code></pre>
<p>回傳訊息 :</p>
<pre><code>pcorr_name.1.1|P0001-01.sdx
|pcorr_len.1.1|10
|pcorr_position.1.1|0.0000000
|pcorr_forward.1.1|0.0000000
|pcorr_backward.1.1|0.0000000
|pcorr_corrected_position.1.1|0.0000000
|pcorr_backlash.1.1|0.0000000
|pcorr_direction.1.1|1
|pcorr_factor.1.1|0.0020000
|pcorr_enabled.1.1|0
</code></pre>
<h4 id="本節指令集-17"><a class="header" href="#本節指令集-17">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th><th>說明</th></tr></thead><tbody>
<tr><td>.pcorr</td><td>( channel n -- )</td><td>輸出目前 Pitch Corrector 的查表結果</td></tr>
<tr><td>.pcorr-entry</td><td>( index channel n -- )</td><td>輸出指定補正表欄位內容</td></tr>
<tr><td>+pcorr</td><td>( channel n -- )</td><td>啟動補正功能</td></tr>
<tr><td>-pcorr</td><td>( channel n -- )</td><td>關閉補正功能</td></tr>
<tr><td>&gt;pcorr</td><td>( channel n -- )</td><td>讀取檔案內容到控制器內</td></tr>
<tr><td>pcorr&gt;</td><td>( channel n -- )</td><td>輸出補正表到檔案</td></tr>
<tr><td>pcorr-entry!</td><td>( index channel n -- ) ( F: position forward backward -- )</td><td>設定補正表欄位</td></tr>
<tr><td>pcorr-factor!</td><td>( channel n -- ) ( F: factor -- )</td><td>設定補正表欄位的轉換係數</td></tr>
<tr><td>pcorr-resize</td><td>( len channel n -- )</td><td>調整補正表的欄位大小</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h3 id="順序功能流程指令"><a class="header" href="#順序功能流程指令">順序功能流程指令</a></h3>
<p>順序功能流程圖 Sequential Function Chart (SFC) 是 PLC 五種語言中的一種，是一種圖形程式語言。它的主要成份有：</p>
<ul>
<li>步驟 (Step) 及其相關的動作。</li>
<li>轉態 (Transition) 及其相關的邏輯條件。</li>
<li>步驟及轉換之間的連結。</li>
</ul>
<p>Botnana Control 提供了支援順序功能流程圖的指令集，可以把 Forth 指令轉變成順序功能流程圖中的「步驟」及「轉態」，並建立步驟及轉態之間的連結。</p>
<p>此外，Botnana Control 內建了一個執行順序功能流程圖的引擎，並且指派了多工系統中的一個 Task 負責執行這個引擎。這個 Task 會在每個控制週期執行以下運算：</p>
<pre><code>SFC Engine:

    +-----------+
    |           |
    |           v
    |   +---------------------+
    |   | pause               | CPU 控制權轉給下一 Task。
    |   +---------------------+
    |           |
    |           v 下一個週期時，控制權會再回到這個 Task。
    |   +----------------------+
    |   | execute_active_steps | 執行所有 active 的步驟。
    |   +----------------------+
    |           |
    |           v
    |   +----------------------------+
    |   | execute_active_transitions | 執行所有 active 的轉態。
    |   +----------------------------+
    |           |
    |           v
    |   +---------------+
    |   | update_states | 依轉態的結果，更新步驟的 active 狀態。
    |   +---------------+
    |           |
    +-----------+
</code></pre>
<p>以下以紅綠燈為例：</p>
<pre><code>     r2g        g2y         y2r
red -+-&gt; green -+-&gt; yellow -+-
 ^                           |
 |                           |
 -----------------------------
</code></pre>
<h4 id="步驟-step"><a class="header" href="#步驟-step">步驟 (Step)</a></h4>
<p>red、green、yellow 分別是紅、綠、黃三個步驟。以下定義了紅黃綠三種步驟的相關動作。在此動作只是印出 r、g、y 三個字母。</p>
<pre><code>: red ( - )  .&quot; r&quot; ;
: green ( - )  .&quot; g&quot; ;
: yellow ( - )  .&quot; y&quot; ;
</code></pre>
<p>以 step 指令宣告 red、green、yellow 是順序流程圖中的步驟。</p>
<pre><code>step red
step green
step yellow
</code></pre>
<p>執行步驟動作的指令不需要堆疊上的參數，也不應產生資料到堆疊上。指令 <code>step</code> 會在 Botnana Control 內建的 SFC 引擎中建立一個和其後指令同名的步驟。並使得當這個步驟為 active 時，會不斷執行此一指令。</p>
<h4 id="啟用-activate"><a class="header" href="#啟用-activate">啟用 (Activate)：</a></h4>
<p>一個順序狀態流程圖要能運作，至少有一個 active 的步驟。指令 <code>+step</code> 會啟用堆疊上的「令牌」對應的步驟，使其 active。以下敘述啟用了步驟 red。</p>
<pre><code>' red  +step
</code></pre>
<h4 id="轉態-transition"><a class="header" href="#轉態-transition">轉態 (Transition)</a></h4>
<p>r2g、g2y、y2r 分別是紅轉綠、綠轉黃、黃轉紅三種轉態。以下定義了三個轉態的相關邏輯條件。在此條件都是假，也就是不會轉態。</p>
<pre><code>: r2g ( - t )  false ;
: g2y ( - t )  false ;
: y2r ( - t )  false ;
</code></pre>
<p>以 transition 指令宣告 r2g、g2y、y2r 是順序流程圖中的轉態。</p>
<pre><code>transition r2g
transition g2y
transition y2r
</code></pre>
<p>執行轉態邏輯條件的指令不需要堆疊上的參數，但會在堆疊上產生一對應轉態條件的布林值。指令 <code>transition</code> 會在 Botnana Control 內建的 SFC 引擎中建立一個和其後指令同名的轉態。並在引擎運轉，當這個轉態前<strong>所有</strong>的步驟都為 active 時，執行此一條件指令，並檢查這指令留在堆疊上的數值。如果數值為真，就會使得轉態之前的步驟不再 active，並使得轉態後的步驟變成 active。</p>
<h4 id="連結"><a class="header" href="#連結">連結</a></h4>
<p>步驟 red 連結到轉態 r2g，轉態 r2g 又連結到步驟 green。指令 <code>--&gt;</code> 會從堆疊上取得步驟或轉態的「令牌 (execution token)，一個代表指令的數字，建立令牌所代表的步驟及轉態之間的連結。在 Forth 使用 <code>'</code> 可以取得其後指令的令牌。 以下程式建立了上圖中的連結。</p>
<pre><code>' red  ' r2g  --&gt;
' r2g  ' green  --&gt;
' green  ' g2y  --&gt;
' g2y  ' yellow  --&gt;
' yellow  ' y2r  --&gt;
' y2r  ' red  --&gt;
</code></pre>
<h4 id="平行-and-結構"><a class="header" href="#平行-and-結構">平行 AND 結構</a></h4>
<p>順序狀態流程有所有的平行處理的結構，或稱 AND 結構，如下圖，當轉態 t1 發生時，步驟 B 和步驟 C 都會 active。</p>
<pre><code>      ||-&gt; B --&gt;||
   t1 ||        || t2     t3
A -+--||-&gt; C --&gt;||-+-&gt; D -+-
^                          |
|                          |
----------------------------
</code></pre>
<p>以下程式建立上圖中的流程圖。</p>
<pre><code>step A
step B
step C
step D

' A  +step

transition t1
transition t2
transition t3

' A  ' t1  --&gt;
' t1  ' B  --&gt;
' t1  ' C  --&gt;
' B  ' t2  --&gt;
' C  ' t2  --&gt;
' t2  ' D  --&gt;
' D  ' t3  --&gt;
' t3  ' A  --&gt;
</code></pre>
<h4 id="選擇-or-結構"><a class="header" href="#選擇-or-結構">選擇 OR 結構</a></h4>
<p>順序狀態流程有多選一的結構，或稱 OR 結構，如下圖，當步驟 A 為 active 時，若轉態 t1 為真，B 會在下一週期變為 active。若 t2 為真，則 C 在下一個週期變為 active。通常會設計使得 t1 和 t2 不會同時會真，達到二選一的目的。要注意如果 t1 和 t2 有可能同時為真，則 B 和 C 同時會 active，行為會類似之前的 AND 平行結構，但如果 t3 和 t4 不同時為真，則 D 可能由 t3 啟用一次，之後又被 t4 啟用一次，這樣的行為會變得難以分析。因此應避免 t1 和 t2 同時為真的設計。</p>
<pre><code>      t1     t3
    |-+-&gt; B -+-&gt;|
    | t2     t4 |       t5
A --|-+-&gt; C -+-&gt;|--&gt; D -+-
^                        |
|                        |
--------------------------
</code></pre>
<p>以下程式建立上圖中的流程圖。</p>
<pre><code>step A
step B
step C
step D

' A +step

transition t1
transition t2
transition t3
transition t4
transition t5

' A  ' t1  --&gt;
' A  ' t2  --&gt;
' t1  ' B  --&gt;
' t2  ' C  --&gt;
' B  ' t3  --&gt;
' C  ' t4  --&gt;
' t3  ' D  --&gt;
' t4  ' D  --&gt;
' D  ' t5  --&gt;
' t5  ' A  --&gt;
</code></pre>
<h4 id="本節指令集-18"><a class="header" href="#本節指令集-18">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果及指令說明</th><th>口語唸法</th></tr></thead><tbody>
<tr><td><code>step &lt;name&gt;</code></td><td>( -- )   在順序狀態流程引擎中定義一個名為 <code>&lt;name&gt;</code> 的步驟，並指派它的動作為指令 <code>&lt;name&gt;</code>。當步驟 <code>&lt;name&gt;</code> active 時，指令 <code>&lt;name&gt;</code> 每個週期都會被執行一次</td><td>step</td></tr>
<tr><td><code>+step</code></td><td>( xt -- )   設令牌 xt 對應的步驟為 active 。</td><td>plus-step</td></tr>
<tr><td><code>transition &lt;name&gt;</code></td><td>( -- )   在順序狀態流程引擎中定義一個名為 <code>&lt;name&gt;</code> 的轉態，並指派它的邏輯條件為指令 <code>&lt;name&gt;</code>。當轉態 <code>&lt;name&gt;</code> 之前的<strong>所有</strong>的步驟都為 active 時，指令 <code>&lt;name&gt;</code> 會被執行。順序狀態流程引擎會檢查執行後留在堆疊上的布林值，如果為真，就會轉態至其後的步驟</td><td>transition</td></tr>
<tr><td><code>--&gt;</code></td><td>( xt1 xt2 -- )   連結對應令牌 <code>xt1</code> 和 <code>xt2</code> 的步驟或轉態。步驟只能連結到轉態，而轉態只能連結到步驟，其他情況會產生錯誤訊息。</td><td>link-to</td></tr>
</tbody></table>
<hr />
<h3 id="其他常用的命令"><a class="header" href="#其他常用的命令">其他常用的命令</a></h3>
<h4 id="0sfc-----"><a class="header" href="#0sfc-----"><code>0sfc ( -- )</code></a></h4>
<p>停止所有執行中的 sfc，清除所有的 sfc 定義。</p>
<h4 id="elapsed---xt----time-"><a class="header" href="#elapsed---xt----time-"><code>elapsed  ( xt -- time ）</code></a></h4>
<p>取得 SFC 步驟（此步驟用令牌 <code>xt</code> 來指定）的執行時間　<code>time</code> ms。如果滿足轉態條件，重新進入指定步驟，此時間會重新計數。</p>
<h4 id="本節指令集-19"><a class="header" href="#本節指令集-19">本節指令集</a></h4>
<table><thead><tr><th>指令</th><th>堆疊效果</th></tr></thead><tbody>
<tr><td>0sfc</td><td>( -- )</td></tr>
<tr><td>elapsed</td><td>（ xt -- time）</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="servo-onoff-sfc-範例"><a class="header" href="#servo-onoff-sfc-範例">Servo On/OFF SFC 範例</a></h2>
<pre><code>
          +-------------------+
          |       Init        |
          +--------+----------+
                   |
             Devices exist ?        檢查是否有對應的裝置。
                   |
          +--------v----------+
+-------&gt; |       Idle        | 
|         +--------+----------+
|                  |
|          servo-on accepted ?      檢查 servo-on request。 
|                  |
|         +--------v-------------+   
|         |    Wait 1000 ms      |  可以在此 setp 才輸送動力電源， 1000 ms 是讓動力電源穩定的時間。
|         +--------+-------------+  
|                  |                      
|                True
|                  | 
|         +--------v-------------------+
|         |    Reset All Drives Fault  |
|         |    Change to CSP Mode      |
|         +--------+-------------------+
|                  |
|           No Drive Fault ?      驅動器異警有可能無法清除，所以需要有 2000 ms 的 timeout 時間。
|                  or
|           Elapsed 2000 ms ?          
|                  |
|        +---------v-----------+
|        |   All drives on     |  每個驅動器必須分時切換到 drive on 狀態，避免動力電源不穩定。 
|        +---------+-----------+
|                  |
|            All-drives-on?       等待所有驅動器是否都已經切換到 drive on 狀態，
|                 or              需要有 2000 ms 的 timeout 時間避免有驅動器無法到達 
|           Elapsed 2000 ms?      drive on 狀態。
|                  |
|        +---------v-----------+
|        |                     |  檢查驅動器狀態
|        |  Servo Loop Process |  檢查 following error
|        |                     |  有異常發出 servo-off 要求。
|        +---------+-----------+
|                  |                               
|          servo-off accepted ?   檢查 servo-off 要求。
|                  |              
|        +---------v-----------+
|        |   All Drives Off    | 
|        +---------+-----------+
|                  |
|            Elapsed 1000 ms ?
|                  |
|        +---------v---------------+
|        |   servo-post-operation  | 可以在此切斷動力電源 
|        +---------+---------------+
|                  |
|                 True
|                  |
+------------------+
                  

</code></pre>
<h2 id="sfc-實作"><a class="header" href="#sfc-實作">SFC 實作：</a></h2>
<pre><code>
\ Axes Description
\ 此範例為 3 軸的 Servo On/OFF SFC 範例
\ 分別為第 1, 2 , 3 運動軸 
\ 不使用 index 0 的運動軸
3 constant axes-len
create axes 0 , 1 , 2 , 3 ,

\ 使用 axes-enabled 可以暫時將指定軸排除在此 SFC 的運作邏輯之外
create axes-enabled false , true , true , true ,

\ 各軸 Servo lag 的檢查範圍， 當運動軸靜止時採用 min-ferr-limit
create min-ferr-limit falign 0e f, 0.05e mm f, 0.05e mm f, 0.05e mm f,
create max-ferr-limit falign 0e f, 1.00e mm f, 1.00e mm f, 1.00e mm f,


\ Debug flag
\ 顯示除錯訊息
variable servo-debug
: +servo-debug
    true servo-debug !
    ;
: -servo-debug
    false servo-debug !
    ;

\ 取得受控運動軸清單中的軸編號
: axis@ ( index -- axis-no )
    cells axes + @
    ; 

\ 取得受控運動軸清單中的致能狀態 (enabled/disabled)
: axis-enabled? ( index -- flag )
    cells axes-enabled + @
    ;

\ 將運動軸清單中的運動軸致能    
: +axis  ( index -- )
    cells axes-enabled + true swap ! 
    ;

\ 將運動軸清單中的運動軸禁能     
: -axis  ( index -- )
    cells axes-enabled + false swap ! 
    ;    

\ 設定 min-ferr-limit
: min-ferr-limit! ( index -- )( F: limit -- )
    floats min-ferr-limit faligned + f!
    ;

\ 設定 max-ferr-limit
: max-ferr-limit! ( index -- )( F: limit -- )
    floats max-ferr-limit faligned + f!
    ;


\ Is servo on
\ 使用此參數來紀錄目前是否處在 servo-on 的狀態
variable is-servo-on

\ Is servo idle
\ 用來紀錄是否處於 Servo Idle Step，在此 step 才會接受 servo on request
variable is-servo-idle

\ Servo On Accepted
\ 用來紀錄 servo on request 是否被接受
variable servo-on-accepted

\ Servo Off Accepted
\ 用來紀錄 servo off request 是否被接受
variable servo-off-accepted


\ Is servo on ?
\ 是否在 Servo On 的狀態
: servo-on?  ( -- flag )
    is-servo-on @
    ;

\ 取得目前適用的 following error limit
\ Servo Off 或是運動軸靜止的時候採用 min-ferr-limit
: ferr-limit@ ( index -- )( F: -- limit )
    dup axis@ axis-rest? servo-on? not or if
        min-ferr-limit  
    else
        max-ferr-limit
    then
    faligned swap floats + f@
    ;

\ 落後誤差檢查
\ servo-lag-err 是用來紀錄 servo-lag-check 檢查之後是否有異常的旗標
\ 所以要使用 servo-lag-err 前要先執行 servo-lag-check
variable servo-lag-err
: servo-lag-check ( -- )
    false servo-lag-err !
    1
    begin
        dup axes-len &lt;=   
    while
        dup axis-enabled? if
            dup ferr-limit@ dup axis@ axis-ferr@ fabs f&lt; if
                .&quot; error|Axis (&quot; dup axis@ 0 .r  .&quot; ) Following error too large&quot; cr
                servo-on? not if
                    dup axis@ 0axis-ferr
                then    
                true servo-lag-err !
            then
        then    
        1+    
    repeat
    drop
    ;


\ 發出 Servo On Request
\ 如果目前狀態可以允許 Servo On，會將 servo-on-accepted 變數設定為真。
: +servo-on ( -- )
    .&quot; log|Servo On Request!&quot; cr
    true servo-on-accepted !
    is-servo-idle @ not if false servo-on-accepted ! .&quot; log|Not Servo Idle&quot; cr then
    servo-lag-check servo-lag-err @ if false servo-on-accepted ! then  
    ;

\ 發出 Servo Off Request
\ 如果目前狀態可以允許 Servo Off，會將 servo-off-accepted 變數設定為真。
: -servo-on ( -- )
    .&quot; log|Servo Off Request!&quot; cr
    true servo-off-accepted !
    servo-on? not if false servo-off-accepted ! .&quot; log|Not Servo On&quot; cr then
    
    1
    begin
        dup axes-len &lt;=   
    while
        dup axis-enabled? if
            dup axis@ axis-rest? not if
                .&quot; error|Axis (&quot; dup axis@ 0 .r  .&quot; ) is not stopped&quot; cr
                false servo-off-accepted !
            then
        then    
        1+    
    repeat
    drop
    
    ;
    
\ 發出 Servo Emergency Off Request
\ 不管目前狀態會將 servo-off-accepted 變數設定為真。
: ems-servo-off ( -- )
    .&quot; log|Emergency Servo Off Request!&quot; cr
    true servo-off-accepted !
    ;    
    

\ Servo Init Step
\ 檢查對應的硬體裝置是否存在，只在一開始的時候做一次，如果檢查沒有通過，SFC 會停留在這個 step。
variable servo-init-once
variable servo-devices-ok
: servo-init ( -- )
    servo-init-once @ not if        
        true servo-devices-ok !
        1
        begin
          dup axes-len &lt;=   
        while
            dup axis-enabled? over axis@ virtual-axis? and if
                .&quot; error|Axis (&quot; dup axis@ 0 .r  .&quot; ) is virtual axis&quot; cr
                false servo-devices-ok ! 
            then
            1+    
        repeat
        drop
    
        true servo-init-once !    
        
        servo-debug @ if .&quot; log|Servo Init Step&quot; cr then
  
    then
    ;

\ Servo Idle Step
\ 在此狀態等待 servo-on-accetped 為真
: servo-idle ( -- )
    true is-servo-idle !
    ;

\ Servo Waiting Power Stable Step  
\ 可以在此送出動力電源的控制訊號
\ 在此狀態等待 1000 ms 動力電源穩定
variable servo-pre-operation-once
variable servo-disable-operation-once
: servo-waiting-power-stable ( -- )
    false is-servo-idle !
    false servo-on-accepted !
    false servo-pre-operation-once !
    false servo-disable-operation-once !
    ;

\ Servo pre operation 
\ 清除驅動器異警與切換到 CSP 模式.
\ 啟動軸組(axis group)運動控制
variable servo-current-axis
variable servo-old-axis
: servo-pre-operation ( -- )
    servo-pre-operation-once @ not if
        +coordinator
        1
        begin
          dup axes-len &lt;=   
        while
            dup axis-enabled? if
                dup csp swap axis@ axis-drive@ op-mode!
                dup axis@ axis-drive@ reset-fault
            then    
            1+    
        repeat
        drop
               
        true servo-pre-operation-once !
        1 servo-current-axis !
        0 servo-old-axis !
    
        servo-debug @ if .&quot; log|Servo pre. operation&quot; cr then
    then
    ;

\ Servo Enable Operation
\ 分時將所有驅動器切換到 drive on 狀態 
variable servo-on-time
: servo-enable-operation ( -- )
    servo-current-axis @ servo-old-axis @ &lt;&gt; if
        servo-current-axis @ dup servo-old-axis !
        dup axis-enabled? if
            dup axis@ axis-drive@ drive-on
        then
        drop    
        mtime servo-on-time !
        servo-debug @ if .&quot; log|Servo enable operation&quot; cr then
    then
    
    mtime servo-on-time @ - 100 &gt; if
        servo-current-axis @ dup axes-len &lt; if
            1+ servo-current-axis !
        else
            drop
        then
    then
    ;

\ Servo Loop
\ 檢查以下條件：
\ 1. drive-on?
\ 2. drive-fault?
\ 3. following error 
\ 如果有問題就發出 ems-servo-off
: servo-loop ( -- )
    
    true is-servo-on !
    1
    begin
        dup axes-len &lt;=   
    while
        dup axis-enabled? if
            dup axis@ axis-drive@ drive-on? not if
                .&quot; error|Not expected drive off&quot; cr
                ems-servo-off
            then
            
            dup axis@ axis-drive@ drive-fault? if
                .&quot; error|drive fault&quot; cr
                ems-servo-off
            then
        then    
        
        1+    
    repeat
    drop
    
    servo-lag-check servo-lag-err @ if ems-servo-off then
    
    ;

\ Servo Disable Operation
\ 接收到 servo-off-accepted 為真時，就執行 drive-off
\ 關閉軸組運動控制
: servo-disable-operation ( -- )
    
    false is-servo-on !
    false servo-off-accepted !
    servo-disable-operation-once @ not if
        true servo-disable-operation-once !
        -coordinator
        1
        begin
            dup axes-len &lt;=   
        while
            dup axis-enabled? if
                dup axis@ axis-drive@ drive-off
            then    
            1+    
        repeat
        drop
        
        servo-debug @ if .&quot; log|Servo disable operation&quot; cr then
    then
    ;


\ Servo Post Operation 
\ Drive Off 後可以在此將動力電源關閉
: servo-post-operation ( -- )
    ;


\ 對應的裝置檢查是否通過 ？
: servo-devices-ok? ( -- flag )
    servo-devices-ok @ 
    ;

\ Servo On Request 是否被接受？
: servo-on-accepted? ( -- flag )
    servo-on-accepted @
    ;

\ Servo power stable 
\ 計數等待 power stable 的時間是否到達？ 
: servo-power-stable? ( -- flag )
    ['] servo-waiting-power-stable elapsed 1000 &gt;
    ;

\ 所有的驅動器異警是否都已經清除
\ 或是經過 2000 ms 也無法清除異警 ?
variable all-drive-no-fault
: servo-wait-no-fault? ( -- flag )
    true all-drive-no-fault ! 
    1
    begin
        dup axes-len &lt;=   
        all-drive-no-fault @ and
    while
        dup axis-enabled? if
            dup axis-drive@ drive-fault? not all-drive-no-fault ! 
        then
        1+    
    repeat
    drop
    
    all-drive-no-fault @
    ['] servo-pre-operation elapsed 2000 &gt;
    or
    ;

\ 所有的驅動器是否都已經 drive on
\ 或是經過 2000 ms 也無法 drive on ?
variable all-drive-on
: servo-operation-enabled?  ( -- flag )
    true all-drive-on !
    1
    begin
        dup axes-len &lt;=
        all-drive-on @ and   
    while
        dup axis-enabled? if
            dup axis@ axis-drive@ drive-on? all-drive-on !    
        then
        1+   
    repeat
    drop
    
    all-drive-on @
    ['] servo-enable-operation elapsed 2000 &gt;
    or
    ;

\ Servo Off Request 是否被接受？
: servo-off-accepted?  ( -- flag )
    servo-off-accepted @
    ;


\ Is servo operation disabled ? 
\ 計數等待 servo disable operation 的時間是否到達？ 
: servo-operation-disabled? ( -- flag )
    ['] servo-disable-operation elapsed 1000 &gt;
    ;


\ servo-default-true 
\ 預設要自動切換到 Servo Idle
: servo-default-true? ( -- flag )
    true
    ;

step servo-init
step servo-idle
step servo-waiting-power-stable
step servo-pre-operation
step servo-enable-operation
step servo-loop
step servo-disable-operation
step servo-post-operation 

transition servo-devices-ok?
transition servo-on-accepted?
transition servo-power-stable?
transition servo-wait-no-fault?
transition servo-operation-enabled?
transition servo-off-accepted?
transition servo-operation-disabled? 
transition servo-default-true?

' servo-init                 ' servo-devices-ok?  --&gt;
' servo-devices-ok?          ' servo-idle        --&gt;
' servo-idle                 ' servo-on-accepted? --&gt;
' servo-on-accepted?         ' servo-waiting-power-stable --&gt;  
' servo-waiting-power-stable ' servo-power-stable?  --&gt;
' servo-power-stable?        ' servo-pre-operation --&gt;
' servo-pre-operation        ' servo-wait-no-fault? --&gt;
' servo-wait-no-fault?       ' servo-enable-operation --&gt;
' servo-enable-operation     ' servo-operation-enabled? --&gt;
' servo-operation-enabled?   ' servo-loop --&gt;
' servo-loop                 ' servo-off-accepted? --&gt;
' servo-off-accepted?        ' servo-disable-operation --&gt;
' servo-disable-operation    ' servo-operation-disabled? --&gt;
' servo-operation-disabled?  ' servo-post-operation --&gt;
' servo-post-operation       ' servo-default-true? --&gt;
' servo-default-true?        ' servo-idle          --&gt;

' servo-init +step

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="motion-state-sfc-範例"><a class="header" href="#motion-state-sfc-範例">Motion State SFC 範例</a></h2>
<p>此範例將主站的運動模式規劃為 3 種，這 3 種模式不會同時運行。</p>
<ol>
<li>Homing: 回歸機械原點模式。</li>
<li>Jogging: 軸運動模式。</li>
<li>Machining: 加工模式。</li>
</ol>
<pre><code>
                            +--------+
+---------------------------+  Idle  |
|                           |        |
|                           +---+----+
|                               |
|            +------------------+-------------------+
|            |                  |                   |
|    homing-accepted?  jogging-accepted?  machining accepted?
|            |                  |                   |
|       +----v----+       +-----v----+        +-----v-----+
|       | Homing  |       |  Jogging |        | Machining |
|       |         |       |          |        |           |
|       +----+----+       +-----+----+        +-----+-----+
|            |                  |                   |
|     homing-stopped?    jogging stopped?   machining-stopped?
|            |                  |                   |
|            +------------------+-------------------+
|                               |
|                         +-----v-------+
|                         | post action |
|                         |             |
|                         +-----+-------+
|                               |
|                             True
|                               |
+------------------------&lt;------+

</code></pre>
<h2 id="sfc-實作-1"><a class="header" href="#sfc-實作-1">SFC 實作：</a></h2>
<pre><code>
\ 定義是否接受運動模式要求的變數
variable homing-accepted
variable jogging-accepted
variable machining-accepted

\ 定義運動模式是否結束的變數
variable homing-stopped
variable jogging-stopped
variable machining-stopped

\ 要求運動停止
variable motion-stopping

\ 紀錄目前的運動模式
variable motion-state

\ 是否處於 Motion Idle 狀態
: is-motion-idle?  ( -- flag )
    motion-state @ 0=
    ;

\ 是否要求運動停止?
: is-motion-stopping? ( -- flag )
    motion-stopping @
    ;

\ 開始進行回歸機械原點
\ 可以規劃不同的判斷邏輯，發出回歸原點的指令或是啟動回歸機械原點的 SFC。
: start-homing ( -- )
    is-motion-idle? if
        true homing-accepted !
        1 motion-state !
        .&quot; log|Start homing&quot; cr
    else
        .&quot; log|Not Motion Idle&quot; cr
    then
    ;

\ 開始進行軸移動
\ 可以規劃不同的判斷邏輯，發出軸運動指令或是啟動軸運動的 SFC。
: start-jogging ( -- )
    is-motion-idle? if
        true jogging-accepted !
        2 motion-state !
        .&quot; log|Start jogging&quot; cr
    else
        .&quot; log|Not Motion Idle&quot; cr
    then
    ;

\ 開始進行加工
\ 可以規劃不同的判斷邏輯，發出加工指令或是啟動軸運動的 SFC。
: start-machining  ( -- )
    is-motion-idle? if
        true machining-accepted !
        3 motion-state !
        .&quot; log|Start machining&quot; cr
    else
        .&quot; log|Not Motion Idle&quot; cr
    then
    ;

\ 要求運動停止
\ 可以依運動模式發出不同的停止命令
: stop-motion  ( -- )
    is-motion-idle? not if
        motion-state @ case
            1 of  .&quot; log|Stop Homing&quot; cr endof
            2 of  .&quot; log|Stop Jogging&quot; cr endof
            3 of  .&quot; log|Stop machining&quot; cr endof
        endcase
        true motion-stopping !
    else
        .&quot; log|motion idle&quot; cr
    then
    ;

\ 要求運動緊急停止
: ems-motion  ( -- )
    true homing-stopped !
    true jogging-stopped !
    true machining-stopped !
    .&quot; log|EMS motion&quot; cr
    ;


\ Motion Idle Step
: motion-idle ( -- )
    ;

\ Motion Homing Step
\ 可以在此規劃 Homing 時的活動，與收到停止命令時的處置
: motion-homing ( -- )
    is-motion-stopping? if
        true homing-stopped !
    then
    ;


\ Motion Jogging Step
\ 可以在此規劃 Jogging 時的活動，與收到停止命令時的處置
: motion-jogging ( -- )
    is-motion-stopping? if
        true jogging-stopped !
    then
    ;

\ Motion Machining Step
\ 可以在此規劃 Machining 時的活動，與收到停止命令時的處置
: motion-machining ( -- )
    is-motion-stopping? if
        true machining-stopped !
    then
    ;

\ Motion Post Action
\ 運動停止後的處置
: motion-post-action ( -- )
    false homing-accepted !
    false jogging-accepted !
    false machining-accepted !
    false homing-stopped !
    false jogging-stopped !
    false machining-stopped !
    false motion-stopping !
    0 motion-state !
    .&quot; log|motion-post-action&quot; cr
    ;

\ Is homing accepted ?
\ 是否接受 Start homing 命令 ？
: homing-accepted?  ( -- flag )
    homing-accepted @
    ;

\ Is homing stopped ?
\ Homing 模式是否已經停止 ?
: homing-stopped? ( -- flag )
    homing-stopped @
    ;


\ Is jogging accepted ?
\ 是否接受 Start jogging 命令 ？
: jogging-accepted? ( -- flag )
    jogging-accepted @
    ;

\ Is jogging stopped ?
\ Jogging 模式是否已經停止 ?
: jogging-stopped? ( -- flag )
    jogging-stopped @
    ;

\ Is machining accepted ?
\ 是否接受 Start Machining 命令 ？
: machining-accepted? ( -- flag )
    machining-accepted @
    ;

\ Is Machining stopped ?
\ Machining 模式是否已經停止 ?
: machining-stopped? ( -- flag )
    machining-stopped @
    ;

\ Motion Post Action 自動切換到 Motion Idle
: motion-auto-passed? ( -- flag )
    true
    ;


\ 宣告 SFC Step
step motion-idle
step motion-homing
step motion-jogging
step motion-machining
step motion-post-action

\ 宣告 SFC Transition
transition  homing-accepted?
transition  homing-stopped?
transition  jogging-accepted?
transition  jogging-stopped?
transition  machining-accepted?
transition  machining-stopped?
transition  motion-auto-passed?


\ SFC Link
' motion-idle           ' homing-accepted?    --&gt;
' homing-accepted?      ' motion-homing       --&gt;
' motion-homing         ' homing-stopped?     --&gt;
' homing-stopped?       ' motion-post-action  --&gt;
' motion-post-action    ' motion-auto-passed? --&gt;
' motion-auto-passed?   ' motion-idle         --&gt;

' motion-idle           ' jogging-accepted?   --&gt;
' jogging-accepted?     ' motion-jogging      --&gt;
' motion-jogging        ' jogging-stopped?    --&gt;
' jogging-stopped?      ' motion-post-action  --&gt;

' motion-idle           ' machining-accepted? --&gt;
' machining-accepted?   ' motion-machining    --&gt;
' motion-machining      ' machining-stopped?  --&gt;
' machining-stopped?    ' motion-post-action  --&gt;

\ Activate motion-idle step
' motion-idle +step

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="homing-sfc-範例"><a class="header" href="#homing-sfc-範例">Homing SFC 範例</a></h2>
<p>此範例為 3 軸回歸機械原點的SFC 。可以與 Servo On/OFF SFC 配合將所有對應的馬達驅動器切換到 Operation Enabled 的狀態，
也可以手動將驅動器切換到 Operation Enabled 以進行此 SFC 的運作。</p>
<p>此範例設計為兩個優先順序的運動軸回歸機械原點，可以完成以下兩種應用：</p>
<ol>
<li>將運動軸分配為兩個優先順序回歸機械原點。例如先完成 Z 軸後再進行 X，Y軸。</li>
<li>結合兩種回歸機械原點的方法，快速找到準確的機械原點。譬如先使用速度較高的 homing method 1 或是 2 找到 encoder index 大致的地方，再使用 homing method 33 或是 34 搭配較低的速度找到精確的 encoder index 。</li>
</ol>
<p>以下是節錄 SANMOTION EtherCAT 驅動器 Instruction Manual 中對於 homing method 1, 2, 33 與 34 的說明：</p>
<hr />
<p><img src="sfc-example/homing_method_1_and_2.png" alt="" /></p>
<p><img src="sfc-example/homing_method_33_and_34.png" alt="" /></p>
<hr />
<p>SFC 設計流程如下：</p>
<pre><code>         +-------------+
         |    Init     |  檢查是否對應的驅動器裝置，
         |             |  設定 device-ok? 旗標。
         +-----+-------+
               |
           device-ok?
               |
         +-----v-------+
         |    Idle     |  等待 homing-accepted? 為真。
+--------+             |
|        +-----+-------+
|              |
|        homing-accepted?
|              |
|        +-----v-------+
|        |   Config    |  切換對應驅動器為 HM 模式
|        |             |  設定 homing speed, homing method
|        +-----+-------+
|              |
|         config-ok?      等待 config 設定指令（EtherCAT SDO）完成。
|              |
|        +-----v-------+
|        |   Trigger   |  啟動驅動器開始進行回歸原點動作。（EtherCAT PDO）
|        |             |
|        +-----+-------+
|              |          等待 50 ms 後，才開始檢查回歸原點的結果。
|         trigger-ok?     避免驅動器還未開始回歸原點，檢查到錯誤時機的狀態。
|              |
|        +-----v-------+  檢查驅動器狀態，判斷回歸原點是否完成。
|        |    Loop     |  如果所設定的運動軸都完成回歸原點就設定 loop-stopped? 旗標。
|        |             |
|        +-----+-------+
|              |
|         loop-stopped?
|              |
|        +-----v-------+  將目前佇列中的運動軸切換到 CSP mode
|        | Post Action |  切換到下一個回歸機械原點佇列，
|        |             |  如果所有佇列都已經完成，就將 homing-accepted? 設定為 false。
|        +-----+-------+
|              |
|        post-action-ok?
|              |
+------&lt;-------+


</code></pre>
<h2 id="sfc-實作-2"><a class="header" href="#sfc-實作-2">SFC 實作：</a></h2>
<pre><code>
\ Axes Description
\ 分別為第 1, 2 , 3 運動軸
\ 不使用 index 0 的運動軸
3 constant axes-len
create axes 0 , 1 , 2 , 3 ,

\ 使用 axes-enabled 可以暫時將指定軸排除在此 SFC 的運作邏輯之外
create axes-enabled false , true , true , true ,

\ 取得受控運動軸清單中的軸編號
: axis@ ( index -- axis-no )
    cells axes + @
    ;

\ 取得受控運動軸清單中的致能狀態 (enabled/disabled)
: axis-enabled? ( index -- flag )
    cells axes-enabled + @
    ;

\ 將運動軸清單中的運動軸致能
: +axis  ( index -- )
    cells axes-enabled + true swap !
    ;

\ 將運動軸清單中的運動軸禁能
: -axis  ( index -- )
    cells axes-enabled + false swap !
    ;

\ 定義回歸機械原點的運動軸 （enabled/disbaled)
\ 分為兩個優先順序，first-homing-axes 執行完後，才執行 second-homing-axes
create first-homing-axes false , false , false , false ,
create second-homing-axes false , false , false , false ,

\ 回歸機械原點的速度與方法
\ 速度單位參考驅動器 0x6099 定義的單位，通常是 pulses/sec
create axes-homing-v1     0 , 1000 , 1000 , 1000 ,
create axes-homing-v2     0 , 10 , 10 , 10 ,
\ 要參照驅動器有支援的方法，通常同一個代號會是相同的方法，但不是每一種驅動器都有支援。
create axes-homing-method 0 , 33 , 33 , 33 ,

\ 取得 homing-v1 參數
: axis-homing-v1@ ( index -- v1 )
    cells axes-homing-v1 + @
    ;

\ 取得 homing-v2 參數
: axis-homing-v2@ ( index -- v2 )
    cells axes-homing-v2 + @
    ;

\ 取得 homing-method 參數
: axis-homing-method@ ( index -- method )
    cells axes-homing-method + @
    ;

\ 設定 homing-v1 參數
: axis-homing-v1! ( v1 index -- )
    cells axes-homing-v1 + !
    ;

\ 設定 homing-v2 參數
: axis-homing-v2! ( v2 index -- )
    cells axes-homing-v2 + !
    ;

\ 設定 homing-method 參數
: axis-homing-method! ( method index -- )
    cells axes-homing-method + !
    ;

\ 目前處理的 homing-priority
\ 1 表示處理 first-homing-axes 中啟動的運動軸
\ 2 表示處理 second-homing-axes 中啟動的運動軸
variable homing-priority


\ 在對應的優先佇列內啟動要回歸機械原點的運動軸
: +homing-axis ( index priority -- )
    case
        1 of cells first-homing-axes + true swap ! endof
        2 of cells second-homing-axes + true swap ! endof
        .&quot; log|Invalid homing priority&quot; cr
        swap drop
    endcase
    ;

\ 在對應的優先佇列內取消要回歸機械原點的運動軸
: -homing-axis ( index priority -- )
    case
        1 of cells first-homing-axes + false swap ! endof
        2 of cells second-homing-axes + false swap ! endof
        .&quot; log|Invalid homing priority&quot; cr
        swap drop
    endcase
    ;

\ 在對應的優先佇列內，取得該運動軸是否要回歸機械原點?
: homing-axis? ( index priority -- flag )
    case
        1 of cells first-homing-axes + @ endof
        2 of cells second-homing-axes + @ endof
        .&quot; log|Invalid homing priority&quot; cr
        swap drop false swap
    endcase
    ;

\ 定義 Axes Homing 流程中所需要的變數
variable homing-devices-ok
variable axes-homing-accetped
variable homing-config-once
variable homing-trigger-once
variable homing-loop-stopped
variable homing-post-action-once
variable axes-homing-stopping

\ 啟動 axes homing
\ 使用此指令，決定是否要開始進行回歸機械原點的活動
\ 依據不同的應用調整啟動的條件
: start-axes-homing ( -- )
    homing-priority @ 0= if
        true axes-homing-accetped !
        1 homing-priority !
    else
        .&quot; log|Axes homing not accetped&quot; cr
    then
;

\ 停止 axes homing
\ Homing 執行中要停止的命令，會將對應的驅動器切換到 Quick Stop Activate 的狀態
: stop-axes-homing ( -- )
    homing-priority @ 0&lt;&gt; if
        1
        begin
            dup axes-len &lt;=
        while
            dup axis-enabled? over homing-priority @ homing-axis? and if
                dup axis@ axis-drive@ drive-stop
            then
            1+
        repeat
        drop
        true axes-homing-stopping !
    then
;

\ Homing Init Step
\ 檢查對應的硬體裝置是否存在，只在一開始的時候做一次，如果檢查沒有通過，SFC 會停留在這個 step。
variable homing-init-once
: homing-init ( -- )
    homing-init-once @ not if
        true homing-devices-ok !
        1
        begin
          dup axes-len &lt;=
        while
            dup axis-enabled? over axis@ virtual-axis? and if
                .&quot; error|Axis (&quot; dup axis@ 0 .r  .&quot; ) is virtual axis&quot; cr
                false homing-devices-ok !
            then
            1+
        repeat
        drop

        true homing-init-once !
    then
    ;

\ Homing Idle Step
\ 在此狀態等待 axes-homing-accetped 為真
: homing-idle ( -- )
    ;

\ Homing Config Step
\ 依據優先佇列設定回歸機械原點的參數給驅動器
: homing-config
    homing-config-once @ not if
        1
        begin
          dup axes-len &lt;=
        while
            dup axis-enabled? over homing-priority @ homing-axis? and if
                dup axis@
                over axis-homing-v1@ over axis-drive@ homing-v1!
                over axis-homing-v2@ over axis-drive@ homing-v2!
                over axis-homing-method@ over axis-drive@ homing-method!
                hm swap axis-drive@ op-mode!
            then
            1+
        repeat
        drop
        false homing-trigger-once !
        false homing-post-action-once !
        true homing-config-once !
    then
;

\ Homing Trigger Step
\ 依據優先佇列設定，命令驅動器開始回歸機械原點
: homing-trigger
    homing-trigger-once @ not if
        1
        begin
            dup axes-len &lt;=
        while
            dup axis-enabled? over homing-priority @ homing-axis? and if
                dup axis@ dup axis-drive@ drive-on? if
                    axis-drive@ go
                else
                    drop
                then
            then
            1+
        repeat
        drop
        false homing-config-once !
        true homing-trigger-once !
    then
    ;

\ Homing Loop Step
\ 依據驅動器狀態判定回歸機械原點結果
\ 依據結果設定運動軸狀態
: homing-loop
    true homing-loop-stopped !
    1
    begin
        dup axes-len &lt;=
    while
        dup axis-enabled? over homing-priority @ homing-axis? and if
            dup axis@ dup axis-drive@ target-reached? if
                dup axis-drive@ drive-sw@ $1000 and 0&lt;&gt; if
                    dup .&quot; log|Axis (&quot;  0 .r  .&quot; ) homing attained&quot; cr
                    dup +homed
                else
                    dup .&quot; log|Axis (&quot;  0 .r  .&quot; ) homing error&quot; cr
                    \ 如果回歸機械原點失敗，停止所有運動軸回歸機械原點
                    stop-axes-homing
                    dup -homed
                then
            else
                false homing-loop-stopped !
            then

            \ 如果驅動器不是在 Operation Enabled 狀態，停止所有運動軸回歸機械原點
            dup axis-drive@ drive-on? not if
                stop-axes-homing
                true homing-loop-stopped !
            then

            \ 清除運動軸落後誤差，依實際位置修正命令
            0axis-ferr

        then
        1+
    repeat
    drop

    ;

\ Homing Post Action
\ 將目前佇列中的驅動器換到 CSP 模式
\ 清除目前佇列中的運動軸
\ 判斷是否要切換到下一個佇列或是停止回歸機械原點
: homing-post-action
    homing-post-action-once @ not if
        1
        begin
          dup axes-len &lt;=
        while
            dup axis-enabled? over homing-priority @ homing-axis? and if
                dup axis@ csp swap axis-drive@ op-mode!
            then
            dup homing-priority @ -homing-axis
            1+
        repeat
        drop
        homing-priority @ 2 &gt;= axes-homing-stopping @ or if
            0 homing-priority !
            false axes-homing-accetped !
            false axes-homing-stopping !
            .&quot; log|homing stopped or finished&quot; cr
        else
            homing-priority @ 1 + homing-priority !
        then

        true homing-post-action-once !
    then
    ;

\ 對應的裝置檢查是否通過 ？
: homing-devices-ok? ( -- flag )
    homing-devices-ok @
    ;

\ 是否接受 homing 的指令 ？
: axes-homing-accetped?
    axes-homing-accetped @
    ;

\ Homing 指令是否設定完成 ？
\ 檢查 EtherCAT SDO 只否都已經執行完畢。
: homing-config-ok?
    waiting-requests? not
    ;

\ 在 Homing trigger 後等待 50 ms
: homing-trigger-ok?
    ['] homing-trigger elapsed 50 &gt;
    ;

\ 是否要脫離 Homing Loop ？
: homing-loop-stopped?
    homing-loop-stopped @
    ;

\ Homing Post Action 是否完成？
\ 檢查 EtherCAT SDO 只否都已經執行完畢。
: homing-post-action-ok?
    waiting-requests? not
    ;

\ 宣告 SFC Step
step homing-init
step homing-idle
step homing-config
step homing-trigger
step homing-loop
step homing-post-action

\ 宣告 SFC Transition
transition homing-devices-ok?
transition axes-homing-accetped?
transition homing-config-ok?
transition homing-trigger-ok?
transition homing-loop-stopped?
transition homing-post-action-ok?


\ Link SFC
' homing-init               ' homing-devices-ok?        --&gt;
' homing-devices-ok?        ' homing-idle               --&gt;
' homing-idle               ' axes-homing-accetped?     --&gt;
' axes-homing-accetped?     ' homing-config             --&gt;
' homing-config             ' homing-config-ok?         --&gt;
' homing-config-ok?         ' homing-trigger            --&gt;
' homing-trigger            ' homing-trigger-ok?        --&gt;
' homing-trigger-ok?        ' homing-loop               --&gt;
' homing-loop               ' homing-loop-stopped?      --&gt;
' homing-loop-stopped?      ' homing-post-action        --&gt;
' homing-post-action        ' homing-post-action-ok?    --&gt;
' homing-post-action-ok?    ' homing-idle               --&gt;

\ Activate homing-init step
' homing-init +step

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="已知可支援的硬體清單"><a class="header" href="#已知可支援的硬體清單">已知可支援的硬體清單</a></h1>
<h2 id="wifi-adapters"><a class="header" href="#wifi-adapters">WiFi Adapters</a></h2>
<ul>
<li>D-Link DWA-171</li>
<li>D-Link DWA-172</li>
</ul>
<h2 id="ethercat-slave-清單"><a class="header" href="#ethercat-slave-清單">EtherCAT Slave 清單</a></h2>
<p>目前 Botnana Control 支援以下 EtherCAT Slaves：</p>
<h3 id="cia-dsp-401-compatible"><a class="header" href="#cia-dsp-401-compatible">CiA DSP 401 Compatible</a></h3>
<ul>
<li>Digital Input Module </li>
<li>Digital Output Module </li>
<li>Analogue Input Module </li>
<li>Analogue Output Module </li>
</ul>
<h3 id="cia-dsp-402-compatible"><a class="header" href="#cia-dsp-402-compatible">CiA DSP 402 Compatible</a></h3>
<ul>
<li>Servo drive </li>
<li>Stepper motor</li>
<li>Multiple drive module </li>
</ul>
<h3 id="研華-advantech"><a class="header" href="#研華-advantech">(研華) Advantech</a></h3>
<ul>
<li>AMAX_4830, DIO</li>
</ul>
<h3 id="beckhoff"><a class="header" href="#beckhoff">Beckhoff</a></h3>
<ul>
<li>EK1100, EtherCAT Bus Coupler</li>
<li>EL1088, 8-channel digital input terminal 24 V DC, negative switching</li>
<li>EL1809, 16-channel digital input 24 V DC</li>
<li>EL2088, 8-channel digital output terminal 24 V DC, negative switching</li>
<li>EL2502, 2-channel pulse width output terminal</li>
<li>EL2088, 8-channel digital output terminal </li>
<li>EL2809, 16-channel digital output 24 V DC</li>
<li>EL3058, 8-channel analog input terminal 4...20 mA, single-ended, 12 bit</li>
<li>EL3062, analog input</li>
<li>EL4002, analog output</li>
<li>EL5032, 2-channel EnDat 2.2 interface</li>
<li>EL6021, Serial terminal</li>
<li>EL6022, Serial terminal</li>
</ul>
<h3 id="copley-controls"><a class="header" href="#copley-controls">Copley Controls</a></h3>
<ul>
<li>Xenus XEL-230-36, EtherCAT Servo Drive</li>
</ul>
<h3 id="台達電-delta"><a class="header" href="#台達電-delta">台達電 (Delta)</a></h3>
<ul>
<li>ASDA-A2-E, EtherCAT(CoE) Drive</li>
<li>R1-EC5500, EtherCAT to E-BUS power module</li>
<li>R1-EC6022, 16 digital inputs, sink/source type</li>
<li>R1-EC7062, 16 digital outputs, sink type</li>
<li>R1-EC9144, 4 channels 16-bit D/A control module</li>
<li>R1-EC8124, 4 channels 16-bit single-ended A/D control module</li>
<li>R1-EC5621, Single-axis pulse output motion control module</li>
</ul>
<h3 id="elmo"><a class="header" href="#elmo">ELMO</a></h3>
<ul>
<li>GOLD_BASSOON Servo Drive</li>
</ul>
<h3 id="fastech"><a class="header" href="#fastech">FASTECH</a></h3>
<ul>
<li>Ezi-SERVOⅡ EtherCAT Series</li>
</ul>
<h3 id="icpdas"><a class="header" href="#icpdas">ICPDAS</a></h3>
<ul>
<li>ECAT-2512, EtherCAT junction </li>
</ul>
<h3 id="mitsubishi"><a class="header" href="#mitsubishi">MITSUBISHI</a></h3>
<ul>
<li>MR-J4-10TM Servo Drive</li>
</ul>
<h3 id="omron"><a class="header" href="#omron">OMRON</a></h3>
<ul>
<li>R88D_1SN04H_ECT Servo Drive (only BN-J2A, BN-J4A)</li>
<li>GX-MD1611 REMOTE TERMINAL (8 Ch. Digital Input， 8 Ch. Digital Output)</li>
<li>NX-ECC203, ID5342, OD5121 (IO 模組，測試中)</li>
</ul>
<h3 id="oriental-motor"><a class="header" href="#oriental-motor">Oriental Motor</a></h3>
<ul>
<li>AZ Series DC power input Multi-Axis Driver</li>
</ul>
<h3 id="panasonic"><a class="header" href="#panasonic">Panasonic</a></h3>
<ul>
<li>EtherCAT communication driver MINAS A5B Series</li>
<li>MCDLT35BF (A6B)</li>
</ul>
<h3 id="sanyo-denki"><a class="header" href="#sanyo-denki">SANYO DENKI</a></h3>
<ul>
<li>SANMOTION R ADVANCED MODEL</li>
</ul>
<h3 id="士林電機-shihlin"><a class="header" href="#士林電機-shihlin">士林電機 （Shihlin）</a></h3>
<ul>
<li>SDP, EtherCAT Servo Driver </li>
</ul>
<h3 id="tpm"><a class="header" href="#tpm">TPM</a></h3>
<ul>
<li>TPM_207_D240_NX, 32 Ch. Digital Input</li>
<li>TPM_207_D204_XN, 32 Ch. Digital Output</li>
<li>TPM_207_A220FD, 8 Ch. Analog Input, 8 Ch. Digital Output</li>
<li>TPM_207_A204F，8 Ch. Anaglo Output</li>
</ul>
<h3 id="yaskawa"><a class="header" href="#yaskawa">Yaskawa</a></h3>
<ul>
<li>SGDV-2R8AE1A</li>
<li>SGD7S-7R6AA0A (測試中)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="軟體更新"><a class="header" href="#軟體更新">軟體更新</a></h1>
<p>當主站軟體因新增功能或是修正錯誤，需要進行軟體更新，就必須依循以下步驟。</p>
<h2 id="取得軟體更新檔"><a class="header" href="#取得軟體更新檔">取得軟體更新檔</a></h2>
<p>可以由動程公司取得更新檔。依據不同的平台其更新檔名稱如下：</p>
<table><thead><tr><th>搭載平台</th><th>更新檔名稱</th></tr></thead><tbody>
<tr><td>BN-A2A</td><td>botnana-control_*_armhf.deb</td></tr>
<tr><td>BN-B2A</td><td>botnana-control_*_armhf.deb</td></tr>
<tr><td>BN-J2A</td><td>botnana-control_*_x86.deb</td></tr>
<tr><td>BN-J4A</td><td>botnana-control_*_x86.deb</td></tr>
</tbody></table>
<h2 id="更新步驟"><a class="header" href="#更新步驟">更新步驟</a></h2>
<p>以更新 BN-B2A 的主控軟體從版號 1.10.14 更新到 1.10.15 為例。</p>
<p>更新檔的檔名為  botnana-control_1.10.15-117_armhf.deb</p>
<ol>
<li>首先要先準備一部設置好與 Botnana Control 網路連線的電腦。此電腦建議有安裝 Google Chrome 的瀏覽器。 </li>
<li>開啟 Google Chrome 瀏覽器，並連線到 <a href="http://192.168.7.2:3000">http://192.168.7.2:3000</a>，一般來說  Botnana Control 的控制盒的IP 位置設置都是 192.168.7.2，如果是其它設定就要連線到指定的 IP 位置。</li>
<li>進入 Botnana Control 首頁，點選右上方的 [ABOUT]。
<br>
<img src="./botnana-control-homepage.png" alt="" /></li>
<li>進入到 [ABOUT] 畫面，此畫面會有目前的版本資訊，此時版號是 1.10.14。點選 [UPLOAD MANUALLY]，會出現檔案瀏覽器，切換到 botnana-control_1.10.15-117_armhf.deb 所在的目錄，選擇該檔案即可。
<br>
<img src="./botnana-control-about.png" alt="" /></li>
<li>此時 [ABOUT] 畫面會出現 &quot;Uploading, Please wait&quot; 的提示訊息。
<br>
<img src="./botnana-control-uploading.png" alt="" /></li>
<li>等待 &quot;Upload successful, please reboot Botnana&quot; 的提示訊息出現，該提示訊息出現後，就可以點選 [REBOOT]。 
<br>
<img src="./botnana-control-reboot.png" alt="" /></li>
<li>等待重新開機到安裝完成的過程中，提示訊息會顯示 &quot;Rebooting&quot;。安裝完成後，版號就會變成 1.10.15。搭載的平台是 BN-A2A/BN-B2A 大約是 3 分鐘左右，BN-J2A/BN-J4A 大約是 1 分鐘左右。
<br>
<img src="./botnana-control-updated.png" alt="" /></li>
<li><strong>更新完成</strong>。因為瀏覽器上的部份資料是在一開始連線時取得，所以建議重新載入畫面。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常見問題"><a class="header" href="#常見問題">常見問題</a></h1>
<ul>
<li><a href="./faq/network.html">網路設定</a></li>
<li><a href="./faq/gadget.html">USB連線IP設定</a></li>
<li><a href="./faq/windows7_rndis.html">Windows 7 RNDIS 驅動程式安裝</a></li>
<li><a href="./faq/windows10_rndis.html">Windows 10 RNDIS 驅動程式安裝</a></li>
<li><a href="./faq/win10_permission.html">Windows 10 檔案權限修改</a></li>
<li><a href="./faq/mount.html">磁碟掛載 Mount</a></li>
<li><a href="./faq/manual_install_deb/manual_install_deb.html">手動安裝 Botnana Control 更新檔</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="網路設定"><a class="header" href="#網路設定">網路設定</a></h2>
<p>使用 <code>connmanctl</code> 指令進行設定。以下是幾個常用的設定需求，若是需要詳細說明可參考 <a href="http://manpages.ubuntu.com/manpages/artful/man1/connmanctl.1.html">connmanctl - Connman CLI</a></p>
<h3 id="wifi-設定"><a class="header" href="#wifi-設定">WIFI 設定</a></h3>
<p><strong>查詢無線網卡的狀態</strong></p>
<p>安裝無線網卡後，使用 <code>sudo connmanctl technologies</code> 查詢無線網卡的狀態，
命令輸出後，狀態如下：</p>
<pre><code>debian@arm:~$ sudo connmanctl technologies 
[sudo] password for debian: // 輸入 temppwd
/net/connman/technology/wifi
  Name = WiFi
  Type = wifi
  Powered = False
  Connected = False
  Tethering = False
/net/connman/technology/gadget
  Name = Gadget
  Type = gadget
  Powered = False
  Connected = False
  Tethering = False
</code></pre>
<p>如果無線網卡安裝妥當，應可看到 <code>/net/connman/technology/wifi</code> 的資訊，
請注意其中 <code>Powered = False</code>， 表示必須先啟動 WiFi，啟動方式如下：</p>
<pre><code>debian@arm:~$ sudo connmanctl enable wifi 
Enabled wifi
</code></pre>
<p>成功後會出現 <code>Enable wifi</code> 的訊息。也可再使用 <code>sudo connmanctl technologies</code> 確認狀態。</p>
<p>此連線是屬於 DHCP， 如要使用指定IP，請看以下章節。</p>
<p><strong>開始進行連線設定</strong></p>
<p>首先進到設定畫面，輸入 <code>sudo connmanctl</code>，會出現 <code>connmanctl&gt;</code> 等待命令的提示訊息。</p>
<pre><code>debian@arm:~$ sudo connmanctl
connmanctl&gt;
</code></pre>
<p>列出可使用的網路節點，以動程公司為例：</p>
<pre><code>connmanctl&gt; services
    Mapacode_5G          wifi_1c5f2bc586d1_4d617061636f64655f3547_managed_psk
    Mapacode             wifi_1c5f2bc586d1_4d617061636f6465_managed_psk
</code></pre>
<p>開啟連線代理:</p>
<pre><code>connmanctl&gt; agent on
Agent registered
</code></pre>
<p>連線， 以連線到SSID是 Mapacode 為例，</p>
<pre><code>connmanctl&gt; connect wifi_1c5f2bc586d1_ //可嘗試按 tab 鍵補全
connmanctl&gt; connect wifi_1c5f2bc586d1_4d617061636f6465_managed_psk 
Agent RequestInput wifi_1c5f2bc586d1_4d617061636f6465_managed_psk
  Passphrase = [ Type=psk, Requirement=mandatory, Alternates=[ WPS ] ]
  WPS = [ Type=wpspin, Requirement=alternate ]
Passphrase? 
</code></pre>
<p>輸入密碼，等待出現 <code>Connected wifi_1c5f2bc586d1_4d617061636f6465_managed_psk</code> 就大功告成。</p>
<pre><code>Passphrase? 062970665 // 輸入密碼
Connected wifi_1c5f2bc586d1_4d617061636f6465_managed_psk
connmanctl&gt;  
</code></pre>
<p>輸入 exit 離開設定畫面</p>
<pre><code>connmanctl&gt; exit
debian@arm:~$ 
</code></pre>
<h3 id="有線網路設定"><a class="header" href="#有線網路設定">有線網路設定</a></h3>
<p>先將網路線連上， 使用 <code>sudo connmanctl technologies</code> 查詢連線狀態。應會出現 <code>/net/connman/technology/ethernet</code> 項目</p>
<pre><code>debian@Q190G4:~$ sudo connmanctl technologies 
[sudo] password for debian: // 輸入 temppwd
/net/connman/technology/ethernet
  Name = Wired
  Type = ethernet
  Powered = True
  Connected = False
  Tethering = False
</code></pre>
<p><strong>開始進行連線設定</strong></p>
<p>首先進到設定畫面，輸入 <code>sudo connmanctl</code>，會出現 <code>connmanctl&gt;</code> 等待命令的提示訊息。</p>
<pre><code>debian@arm:~$ sudo connmanctl
connmanctl&gt;
</code></pre>
<p>列出可使用的網路節點：</p>
<pre><code>connmanctl&gt; services
*A  Wired                ethernet_00ecacce3a79_cable
connmanctl&gt;  
</code></pre>
<p>開啟連線代理:</p>
<pre><code>connmanctl&gt; agent on
Agent registered
</code></pre>
<p>連線:</p>
<pre><code>connmanctl&gt; connect ethernet_00ecacce3a79_cable
Connected ethernet_00ecacce3a79_cable
</code></pre>
<p>大功告成。</p>
<p>此連線是屬於 DHCP 。如要使用指定IP，請看以下章節。</p>
<h3 id="指定ip"><a class="header" href="#指定ip">指定IP</a></h3>
<p>設定案例：</p>
<ul>
<li>service : <code>ethernet_00ecacce3a79_cable</code></li>
<li>ip      : 192.168.7.2</li>
<li>netmask : 255.255.255.0</li>
<li>gateway : 192.168.7.1</li>
</ul>
<pre><code>指令格式：
connmanctl config &lt;service&gt; --ipv4 manual &lt;ip address&gt; &lt;netmask&gt; &lt;gateway&gt;

案例設定：
sudo connmanctl config  ethernet_00ecacce3a79_cable --ipv4 manual 192.168.7.2 255.255.255.0 192.168.7.1
</code></pre>
<h3 id="自動指派ip"><a class="header" href="#自動指派ip">自動指派IP</a></h3>
<p>設定案例：</p>
<p>service: <code>ethernet_00ecacce3a79_cable</code></p>
<pre><code>指令格式：
connmanctl config &lt;service&gt; --ipv4 dhcp

案例設定：
sudo connmanctl config  ethernet_00ecacce3a79_cable --ipv4 dhcp
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usb連線ip設定"><a class="header" href="#usb連線ip設定">USB連線IP設定</a></h2>
<h3 id="同一電腦連接單一塊-botnana"><a class="header" href="#同一電腦連接單一塊-botnana">同一電腦連接單一塊 Botnana</a></h3>
<ul>
<li>
<p>編輯 Botnana 系統的 /etc/network/interfaces 檔案，改成您所希望的 IP，例如︰</p>
<p>iface usb0 inet static</p>
<pre><code>  address 192.168.6.2  

  netmask 255.255.255.0  

  network 192.168.6.0  

  gateway 192.168.6.1  
</code></pre>
<p>表示 Botnana 本身的 IP 是 <strong>192.168.6.2</strong>，分配給電腦的 IP 是 <strong>192.168.6.1</strong></p>
</li>
<li>
<p>編輯 Botnana 的組態檔 /etc/botnana-control/motion.toml，做如下的修改︰</p>
<p>[server]</p>
<p>address = &quot;0.0.0.0:3012&quot;</p>
<p>改成</p>
<p>[server]</p>
<p>address = &quot;192.168.6.2:3012&quot;</p>
<p>表示 Botnana 本身的伺服器的位址為 <strong>192.168.6.2</strong> </p>
</li>
</ul>
<h3 id="同一電腦連接多塊-botnana"><a class="header" href="#同一電腦連接多塊-botnana">同一電腦連接多塊 Botnana</a></h3>
<p>修改方式如 <strong>同一電腦連接單一塊 Botnana</strong> ，最大的差異是︰<strong>每塊Botnana要設為不同的區段</strong>。</p>
<p>例如︰
第一塊設為 address 192.168.<strong>6</strong>.2，第二塊設為 address 192.168.<strong>7</strong>.2。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="windows-7-透過-microusb-與-botnana-a2-連線時需先安裝-rndis-驅動程式"><a class="header" href="#windows-7-透過-microusb-與-botnana-a2-連線時需先安裝-rndis-驅動程式">WINDOWS 7 透過 MicroUSB 與 Botnana A2 連線時需先安裝 RNDIS 驅動程式</a></h2>
<h4 id="1-32-位元與-64-位元"><a class="header" href="#1-32-位元與-64-位元">1. 32 位元與 64 位元</a></h4>
<p>都是用同一個安裝流程。</p>
<h4 id="2-首先先下載-mapacode_botnana_a2inf"><a class="header" href="#2-首先先下載-mapacode_botnana_a2inf">2. 首先，先下載 <code>mapacode_botnana_a2.inf</code></a></h4>
<p><a href="faq/./mapacode_botnana_a2.inf">按此連結下載 mapacode_botnana_a2.inf</a></p>
<p>此設定檔是由 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/network/remote-ndis-inf-template">MicroSoft Remote NDIS INF Template</a>
修改而成。</p>
<h4 id="3-將電腦-botnana-a2-的-microusb-埠與電腦的-usb-埠使用-usb-線材連結"><a class="header" href="#3-將電腦-botnana-a2-的-microusb-埠與電腦的-usb-埠使用-usb-線材連結">3. 將電腦 Botnana A2 的 MicroUSB 埠與電腦的 USB 埠使用 USB 線材連結。</a></h4>
<p>到 Windows 裝置管理員 （Device Manager）畫面，應可以看到 Botnana-A2 裝置出現。</p>
<p><img src="faq/./win7_rndis_device_manager_init.png" alt="" /></p>
<h4 id="4-選擇-botnana-a2-裝置更新驅動程式"><a class="header" href="#4-選擇-botnana-a2-裝置更新驅動程式">4. 選擇 Botnana-A2 裝置更新驅動程式</a></h4>
<p>點選 Botnana-A2 裝置，按下滑鼠右鍵，進行驅動程式更新。</p>
<h4 id="5-瀏覽電腦上的驅動程式軟體"><a class="header" href="#5-瀏覽電腦上的驅動程式軟體">5. 瀏覽電腦上的驅動程式軟體</a></h4>
<p><img src="faq/./win7_rndis_search_driver.png" alt="" /> </p>
<h4 id="6-讓我從電腦上的裝置驅動程式清單中挑選"><a class="header" href="#6-讓我從電腦上的裝置驅動程式清單中挑選">6. 讓我從電腦上的裝置驅動程式清單中挑選</a></h4>
<p><img src="faq/./win7_rndis_browse_driver.png" alt="" /></p>
<h4 id="7-請從下列清單中選取你裝置的類型選擇網路介面卡"><a class="header" href="#7-請從下列清單中選取你裝置的類型選擇網路介面卡">7. 請從下列清單中選取你裝置的類型，選擇[網路介面卡]</a></h4>
<p><img src="faq/./win7_rndis_select_driver.png" alt="" /></p>
<h4 id="8-選擇從磁片安裝"><a class="header" href="#8-選擇從磁片安裝">8. 選擇從磁片安裝</a></h4>
<p><img src="faq/./win7_rndis_select_network_adapter.png" alt="" /></p>
<h4 id="9-選擇-mapacode_botnana_a2inf-所在的目錄位置"><a class="header" href="#9-選擇-mapacode_botnana_a2inf-所在的目錄位置">9. 選擇 <code>mapacode_botnana_a2.inf</code> 所在的目錄位置</a></h4>
<p>此範例的 <code>mapacode_botnana_a2.inf</code> 的目錄位置是 D:\rndis</p>
<p><img src="faq/./win7_rndis_install_from_disk.png" alt="" /></p>
<h4 id="10-此時相容的網路介面卡會出現-botnana-a2"><a class="header" href="#10-此時相容的網路介面卡會出現-botnana-a2">10. 此時相容的網路介面卡會出現 [Botnana-A2]</a></h4>
<p>按下 [Next]，繼續安裝。</p>
<p><img src="faq/./win7_rndis_select_botnana_a2.png" alt="" /></p>
<h4 id="11-選擇-仍然安裝此驅動程式軟體"><a class="header" href="#11-選擇-仍然安裝此驅動程式軟體">11. 選擇 [仍然安裝此驅動程式軟體]</a></h4>
<p><img src="faq/./win7_rndis_security.png" alt="" /></p>
<h4 id="12-等候安裝完成"><a class="header" href="#12-等候安裝完成">12. 等候安裝完成</a></h4>
<p><img src="faq/./win7_rndis_installing_driver.png" alt="" /></p>
<h4 id="13-安裝完成"><a class="header" href="#13-安裝完成">13. 安裝完成</a></h4>
<p><img src="faq/./win7_rndis_finished_installing.png" alt="" /></p>
<h4 id="14-可以由以下步驟確認-botnana-a2-的裝置狀態"><a class="header" href="#14-可以由以下步驟確認-botnana-a2-的裝置狀態">14. 可以由以下步驟確認 Botnana-A2 的裝置狀態</a></h4>
<h5 id="141-網路介面卡裝置出現-botnana-a2"><a class="header" href="#141-網路介面卡裝置出現-botnana-a2">14.1. 網路介面卡裝置出現 [Botnana-a2]</a></h5>
<p><img src="faq/./win7_rndis_finished_device_manager.png" alt="" /></p>
<h5 id="142-在控制台-網路與網際網路-網路和共用中心會出現-botnana-a2-的網路裝置"><a class="header" href="#142-在控制台-網路與網際網路-網路和共用中心會出現-botnana-a2-的網路裝置">14.2 在[控制台]-&gt;[網路與網際網路]-&gt;[網路和共用中心]會出現 Botnana-A2 的網路裝置</a></h5>
<p><img src="faq/./win7_rndis_network_connections.png" alt="" /></p>
<h5 id="143-查看-botnana-a2-的裝置狀態"><a class="header" href="#143-查看-botnana-a2-的裝置狀態">14.3. 查看 Botnana-A2 的裝置狀態</a></h5>
<p>使用滑鼠游標移至 Botnana-A2 網路裝置，按下滑鼠右鍵，選擇[狀態]，就會出現以下視窗。</p>
<p><img src="faq/./win7_rndis_connection_status.png" alt="" /></p>
<h5 id="144-查看-botnana-a2-的詳細資料"><a class="header" href="#144-查看-botnana-a2-的詳細資料">14.4. 查看 Botnana-A2 的詳細資料</a></h5>
<p>以此範例可以看到本機的IP 是 192.168.7.1。而 DHCP Server IP 是 192.168.7.2，此 DHCP Server IP 就是 Botnana-A2 的 IP。</p>
<p><img src="faq/./win7_rndis_connection_details.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="windows-10-透過-microusb-與-botnana-a2-連線時需先安裝-rndis-驅動程式"><a class="header" href="#windows-10-透過-microusb-與-botnana-a2-連線時需先安裝-rndis-驅動程式">WINDOWS 10 透過 MicroUSB 與 Botnana A2 連線時需先安裝 RNDIS 驅動程式</a></h2>
<h4 id="0-將-botnana-a2-microusb埠-與-電腦-連接"><a class="header" href="#0-將-botnana-a2-microusb埠-與-電腦-連接">0. 將 Botnana-A2 microUSB埠 與 電腦 連接。</a></h4>
<p>註解︰若已嘗試過安裝 RNDIS 驅動程式，請從步驟 1 開始；否則，請直接從步驟 3 開始。</p>
<h4 id="1-裝置管理員-出現如下裝置"><a class="header" href="#1-裝置管理員-出現如下裝置">1. 裝置管理員 出現如下裝置</a></h4>
<p><img src="faq/./win10_1_com_port.png" alt="" /></p>
<h4 id="2-解除安裝裝置"><a class="header" href="#2-解除安裝裝置">2. 解除安裝裝置</a></h4>
<p><img src="faq/./win10_2_remove_com_device.png" alt="" /></p>
<h4 id="3-修改-cwindowsinfusbserinf-關於-usbserinf-權限問題"><a class="header" href="#3-修改-cwindowsinfusbserinf-關於-usbserinf-權限問題">3. 修改 C:\Windows\INF\usbser.inf （<a href="faq/./win10_permission.html">關於 usbser.inf 權限問題</a>）</a></h4>
<p>將底下這個 
<img src="faq/./win10_3_modify_usbser_inf.png" alt="" />
改成如下
<img src="faq/./win10_4_mark_usbser_inf_com_port.png" alt="" /></p>
<h4 id="4-選裝置管理員中的--botnana-a2並更新驅動程式"><a class="header" href="#4-選裝置管理員中的--botnana-a2並更新驅動程式">4. 選裝置管理員中的  Botnana-A2，並更新驅動程式</a></h4>
<p><img src="faq/./win10_5_upgrade_drive.png" alt="" /></p>
<h4 id="5-選-瀏覽電腦上的驅動程式軟體"><a class="header" href="#5-選-瀏覽電腦上的驅動程式軟體">5. 選 瀏覽電腦上的驅動程式軟體</a></h4>
<p><img src="faq/./win10_6_browse_drive.png" alt="" /></p>
<h4 id="6-選-讓我從電腦上的可用驅動程式清單中挑選"><a class="header" href="#6-選-讓我從電腦上的可用驅動程式清單中挑選">6. 選 讓我從電腦上的可用驅動程式清單中挑選</a></h4>
<p><img src="faq/./win10_7_choose_drive.png" alt="" /></p>
<h4 id="7-硬體類型選-網路介面卡"><a class="header" href="#7-硬體類型選-網路介面卡">7. 硬體類型選 網路介面卡</a></h4>
<p><img src="faq/./win10_8_select_network_interface.png" alt="" /></p>
<h4 id="8-製造商--型號microsoft--usb-rndis介面卡"><a class="header" href="#8-製造商--型號microsoft--usb-rndis介面卡">8. 製造商 / 型號︰Microsoft / USB RNDIS介面卡</a></h4>
<p><img src="faq/./win10_9_select_rndis_drive.png" alt="" /></p>
<h4 id="9-忽略警告訊息"><a class="header" href="#9-忽略警告訊息">9. 忽略警告訊息</a></h4>
<p><img src="faq/./win10_10_ignore_warning.png" alt="" /></p>
<h4 id="10-驅動程式更新成功"><a class="header" href="#10-驅動程式更新成功">10. 驅動程式更新成功</a></h4>
<p><img src="faq/./win10_11_install_rndis_ok.png" alt="" /></p>
<h4 id="11-檢查是否出現這個裝置裝置管理員網路介面卡usb-rndis介面卡"><a class="header" href="#11-檢查是否出現這個裝置裝置管理員網路介面卡usb-rndis介面卡">11. 檢查是否出現這個裝置︰裝置管理員/網路介面卡/USB RNDIS介面卡</a></h4>
<p><img src="faq/./win10_12_got_usb_rndis_interface.png" alt="" /></p>
<h4 id="12-連線測試假設用-putty-連線軟體"><a class="header" href="#12-連線測試假設用-putty-連線軟體">12. 連線測試（假設用 PuTTY 連線軟體）</a></h4>
<p><img src="faq/./win10_13_connect_by_ssh.png" alt="" /></p>
<h4 id="13-username--password-debian--temppwd"><a class="header" href="#13-username--password-debian--temppwd">13. username / password: debian / temppwd</a></h4>
<p><img src="faq/./win10_14_login.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="修改權限的步驟"><a class="header" href="#修改權限的步驟">修改權限的步驟<a id="permission"></a></a></h2>
<ol>
<li>以 C:\Windows\INF\usbstor.inf 檔案為範例</li>
<li>假設登入 Windows 10 的使用者帳號為 felix</li>
</ol>
<h4 id="step-1-將滑鼠移到-usbstorinf-上並按滑鼠右鍵選-內容-"><a class="header" href="#step-1-將滑鼠移到-usbstorinf-上並按滑鼠右鍵選-內容-">step 1. 將滑鼠移到 usbstor.inf 上，並按滑鼠右鍵，選 內容 。</a></h4>
<h4 id="step-2-選-安全性---進階-"><a class="header" href="#step-2-選-安全性---進階-">step 2. 選 安全性 -〉 進階 。</a></h4>
<p><img src="faq/./win10_15_mod_permission_0.png" alt="" /></p>
<h4 id="step-3-按-變更-擁有者輸入使用者帳號按-檢查名稱此時會顯示完整的帳號資訊按-確定-離開"><a class="header" href="#step-3-按-變更-擁有者輸入使用者帳號按-檢查名稱此時會顯示完整的帳號資訊按-確定-離開">step 3. 按 變更 擁有者，輸入使用者帳號，按 檢查名稱，此時會顯示完整的帳號資訊，按 確定 離開。</a></h4>
<p><img src="faq/./win10_15_mod_permission_1.png" alt="" />
<img src="faq/./win10_15_mod_permission_2.png" alt="" /></p>
<h4 id="step-4-回到上一層後按-套用-顯示警告訊息按-確定"><a class="header" href="#step-4-回到上一層後按-套用-顯示警告訊息按-確定">step 4. 回到上一層後，按 套用 ，顯示警告訊息，按 確定。</a></h4>
<p><img src="faq/./win10_15_mod_permission_3.png" alt="" />
<img src="faq/./win10_15_mod_permission_4.png" alt="" /></p>
<h4 id="step-5-將顯示-usbstorinf-內容的視窗全部關閉後再重開-內容-視窗"><a class="header" href="#step-5-將顯示-usbstorinf-內容的視窗全部關閉後再重開-內容-視窗">step 5. 將顯示 usbstor.inf 內容的視窗全部關閉後，再重開 內容 視窗。</a></h4>
<h4 id="step-6-新增-一個主體"><a class="header" href="#step-6-新增-一個主體">step 6. 新增 一個主體。</a></h4>
<p><img src="faq/./win10_15_mod_permission_5.png" alt="" /></p>
<h4 id="step-7-選取一個主體"><a class="header" href="#step-7-選取一個主體">step 7. 選取一個主體。</a></h4>
<p><img src="faq/./win10_15_mod_permission_6.png" alt="" /></p>
<h4 id="step-8-輸入帳號並檢查名稱再按確定"><a class="header" href="#step-8-輸入帳號並檢查名稱再按確定">step 8. 輸入帳號並檢查名稱，再按確定。</a></h4>
<p><img src="faq/./win10_15_mod_permission_7.png" alt="" />
<img src="faq/./win10_15_mod_permission_8.png" alt="" /></p>
<h4 id="step-9-修改基本權限後按確定"><a class="header" href="#step-9-修改基本權限後按確定">step 9. 修改基本權限後，按確定。</a></h4>
<p><img src="faq/./win10_15_mod_permission_9.png" alt="" /></p>
<h4 id="step-10-確認帳號已正確加入並擁有完全控制的權限"><a class="header" href="#step-10-確認帳號已正確加入並擁有完全控制的權限">step 10. 確認帳號已正確加入，並擁有完全控制的權限。</a></h4>
<p><img src="faq/./win10_15_mod_permission_10.png" alt="" /></p>
<h4 id="step-11-按-套用及確定顯示安全警告的訊息按-是"><a class="header" href="#step-11-按-套用及確定顯示安全警告的訊息按-是">step 11. 按 套用及確定，顯示安全警告的訊息，按 是。</a></h4>
<p><img src="faq/./win10_15_mod_permission_11.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usb-隨身碟掛載"><a class="header" href="#usb-隨身碟掛載">USB 隨身碟掛載</a></h2>
<ul>
<li><strong>在插入 USB 隨身碟前先使用 <code>fdisk -l </code>或是 <code>lsblk</code> 查看系統目前所能識別的儲存裝置。內容可能如下：</strong></li>
</ul>
<pre><code>debian@arm:~$ sudo fdisk -l

Disk /dev/mmcblk0: 3.6 GiB, 3867148288 bytes, 7553024 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xe67298e5

Device         Boot  Start     End Sectors  Size Id Type
/dev/mmcblk0p1 *      2048  206847  204800  100M  e W95 FAT16 (LBA)
/dev/mmcblk0p2      206848 7553023 7346176  3.5G 83 Linux

Disk /dev/mmcblk0boot1: 2 MiB, 2097152 bytes, 4096 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk /dev/mmcblk0boot0: 2 MiB, 2097152 bytes, 4096 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</code></pre>
<ul>
<li><strong>插入 USB 隨身碟，再次使用 <code>fdisk -l </code>，查看新增的儲存裝置。與第一次內容相比，新增的內容可能如下，由此內容可以得知新增的儲存裝置代號是 <code>/dev/sda1</code>。</strong></li>
</ul>
<pre><code>Disklabel type: dos
Disk identifier: 0x0009fbbc

Device     Boot Start       End   Sectors  Size Id Type
/dev/sda1  *     2048 121110527 121108480 57.8G  7 HPFS/NTFS/exFAT

</code></pre>
<ul>
<li><strong>掛載指令，以儲存裝置代號是 <code>/dev/sda1</code> 為範例。</strong></li>
</ul>
<pre><code>debian@arm:~$ sudo mkdir /mnt/usb
debian@arm:~$ sudo mount /dev/sda1 /mnt/usb 
</code></pre>
<ul>
<li><strong>掛載後就可以在 /mnt/usb 的目錄下對 USB 隨身碟的資料進行訪問或是操作。</strong></li>
<li><strong>卸載指令，以儲存裝置代號是 <code>/dev/sda1</code> 為範例。</strong></li>
</ul>
<pre><code>debian@arm:~$ sudo unmount /dev/sda1 
</code></pre>
<h2 id="microsd-card-掛載"><a class="header" href="#microsd-card-掛載">MicroSD Card 掛載</a></h2>
<p>掛載的方式與 USB 類似，也是由 <code>fdisk -l</code> 指令找出掛載的磁碟名稱。</p>
<ul>
<li><strong><code>fdisk -l</code> 查詢後的範例如下：</strong></li>
</ul>
<pre><code>Disklabel type: dos
Disk identifier: 0x003a8823

Device         Boot Start      End  Sectors  Size Id Type
/dev/mmcblk1p1 *     2048 62333951 62331904 29.7G  c W95 FAT32 (LBA)
</code></pre>
<ul>
<li><strong>掛載指令，以儲存裝置代號是 <code>/dev/mmcblk1p1</code> 為範例。</strong></li>
</ul>
<pre><code>debian@arm:~$ sudo mkdir /mnt/mmc
debian@arm:~$ sudo mount /dev/mmcblk1p1 /mnt/mmc 
</code></pre>
<ul>
<li><strong>掛載後就可以在 /mnt/mmc 的目錄下對 MicroSD Card 的資料進行訪問或是操作。</strong></li>
<li><strong>卸載指令，以儲存裝置代號是 <code>/dev/mmcblk1p1</code>為範例。</strong></li>
</ul>
<pre><code>debian@arm:~$ sudo unmount /dev/mmcblk1p1 
</code></pre>
<p><strong>注意事項：</strong></p>
<p>BN-A2A/BN-B2A 預設會以 MicroSD Card 開機，如果只是資料的訪問或是操作，建議在開機後再插入 MicroSD Card。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手動安裝-botnana-control-更新檔deb"><a class="header" href="#手動安裝-botnana-control-更新檔deb">手動安裝 Botnana Control 更新檔(.deb)</a></h1>
<p>一般來說建議使用 Botnana Web Utils 進行更新檔安裝，說明可參考<a href="faq/manual_install_deb/../../update-software.html">軟體更新</a>。</p>
<p>若是安裝過程發生意外錯誤，導致無法再使用 Botnana Web Utils 進行安裝，則可以手動執行安裝進行修復，步驟如下。</p>
<h2 id="1-傳送安裝檔至-botnana"><a class="header" href="#1-傳送安裝檔至-botnana">1. 傳送安裝檔至 Botnana</a></h2>
<h3 id="在-windows-上操作"><a class="header" href="#在-windows-上操作">在 Windows 上操作</a></h3>
<p>請至<a href="https://winscp.net/eng/download.php">這裡</a>下載並安裝 winscp 。</p>
<p><img src="faq/manual_install_deb/./winscp_1.png" alt="" /></p>
<ol>
<li>開啟 winscp 後建立新站台</li>
<li>輸入 Botnana 的 ip 位址，預設為 192.168.7.2</li>
<li>輸入 Botnana 上預設的使用者名稱 debian</li>
<li>輸入密碼 temppwd</li>
<li>登入</li>
</ol>
<p><img src="faq/manual_install_deb/./winscp_2.png" alt="" /><br />
登入後視窗左邊為 PC 本機的磁碟目錄，右邊為 Botnana 上的磁碟目錄。</p>
<ol>
<li>本機索引至 Botnana Control 更新檔存放的位置</li>
<li>Botnana 索引至 /home/debian</li>
<li>將安裝檔拖曳至 Botnana 中</li>
</ol>
<h3 id="在-linux-上操作"><a class="header" href="#在-linux-上操作">在 Linux 上操作</a></h3>
<p>索引至安裝檔所的位置，例如在家目錄 Downloads 中</p>
<pre><code>$ cd ~/Downloads/
</code></pre>
<p>使用 <code>scp</code> 指令將安裝檔複製到 Botnana 上，例如安裝檔名稱為 <code>botnana-control_1.15.4-1202_armhf.deb</code></p>
<pre><code>$ scp botnana-control_1.15.4-1202_armhf.deb debian@192.168.7.2:~
</code></pre>
<p>依照提示輸入密碼 <code>temppwd</code>，顯示下列訊息表示成功</p>
<pre><code>botnana-control_1.15.4-1202_armhf.deb              100%   16MB   3.2MB/s   00:05
</code></pre>
<h2 id="2-ssh-連線登入-botnana"><a class="header" href="#2-ssh-連線登入-botnana">2. ssh 連線登入 Botnana</a></h2>
<h3 id="在-windows-上操作-1"><a class="header" href="#在-windows-上操作-1">在 Windows 上操作</a></h3>
<p>請至<a href="https://www.putty.org/">這裡</a>下載並安裝 putty 。</p>
<p><img src="faq/manual_install_deb/./putty_1.png" alt="" /><br />
按照上圖輸入使用者名稱與 ip 位址後開啟連線，並依據提示輸入密碼 <code>temppwd</code></p>
<h3 id="在-linux-上操作-1"><a class="header" href="#在-linux-上操作-1">在 Linux 上操作</a></h3>
<p>在終端機中輸入</p>
<pre><code>$ ssh debian@192.168.7.2
</code></pre>
<p>並依據提示輸入密碼 <code>temppwd</code></p>
<h2 id="3-手動安裝更新檔"><a class="header" href="#3-手動安裝更新檔">3. 手動安裝更新檔</a></h2>
<p>輸入 <code>dpkg -l botnana-control</code> 可以查看目前安裝的 botnana-control 版本，例如</p>
<pre><code>debian@arm:~$ dpkg -l botnana-control
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name              Version    Architecture    Description
+++-=================-==========-===============-==============================
ii  botnana-control   1.13.25    armhf           Botnana Control IIOT Platform
</code></pre>
<p>輸入 <code>sudo dpkg -r botnana-control</code> 可以移除目前安裝的 botnana-control，例如</p>
<pre><code>debian@arm:~$ sudo dpkg -r botnana-control
[sudo] password for debian: 
(Reading database ... 50512 files and directories currently installed.)
Removing botnana-control (1.13.25) ...
Processing triggers for systemd (215-17+deb8u2) ...
</code></pre>
<p>將 botnana-control 更新檔移至更新目錄，例如</p>
<pre><code>debian@arm:~$ sudo mv botnana-control_1.15.4-1202_armhf.deb /opt/mapacode/botnana-control/update/
debian@arm:~$ cd /opt/mapacode/botnana-control/update/
debian@arm:/opt/mapacode/botnana-control/update$ ls
botnana-control_1.15.4-1202_armhf.deb  dpkg.log
</code></pre>
<p>若發現 update 目錄裡有殘留舊的安裝檔可以將其移除，例如有一個舊的安裝檔名稱為<code>botnana-control_1.13.0-0101_armhf.deb</code></p>
<pre><code>sudo rm botnana-control_1.13.0-0101_armhf.deb
</code></pre>
<p>安裝 botnana-control 更新檔，例如</p>
<pre><code>debian@arm:/opt/mapacode/botnana-control/update$ sudo dpkg -i botnana-control_1.15.4-1202_armhf.deb 
Selecting previously unselected package botnana-control.
(Reading database ... 28587 files and directories currently installed.)
Preparing to unpack botnana-control_1.15.4-1202_armhf.deb ...
Unpacking botnana-control (1.15.4) ...
Setting up botnana-control (1.15.4) ...
Processing triggers for systemd (215-17+deb8u2) ...
</code></pre>
<p>查看安裝結果</p>
<pre><code>debian@arm:/opt/mapacode/botnana-control/update$ sudo dpkg -l botnana-control
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name              Version   Architecture   Description
+++-=================-=========-==============-=============================
ii  botnana-control   1.15.4    armhf          Botnana Control IIOT Platform
</code></pre>
<p>botnana-control 名稱前面顯示 <code>ii</code> 表示正確安裝</p>
<p>如安裝檔的位置是在 <code>/opt/mapacode/botnana-control/update</code>，安裝完畢後，建議刪除安裝檔，避免重開機時再安裝一次。</p>
<pre><code>debian@arm:/opt/mapacode/botnana-control/update$ sudo rm botnana-control_1.15.4-1202_armhf.deb
</code></pre>
<p>重新啟動 Botnana</p>
<pre><code>$ sudo reboot
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
